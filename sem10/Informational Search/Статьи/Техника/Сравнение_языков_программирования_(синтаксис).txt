В этой статье сравнивается более 50 языков программирования по основным свойствам синтаксиса.

Выражения
Выражения в языках программирования в широком смысле могут быть подразделены на 4 типа по синтаксической структуре:

префиксная записьЛисп (* (+ 2 3) (expt 4 5))инфиксная записьФортран (2 + 3) * (4 ** 5)суффиксная, постфиксная или Обратная польская записьФорт 2 3 + 4 5 ** *запись выражений в математическом стилеWolfram (2 + 3)(4^5) (* отметим неявный оператор умножения *)

Операторы
Как правило в языках программирования имеются следующие соглашения по операторам:

о разделителях операторов;
о терминаторах операторов; и
о продолжении строкиРазделитель операторов используется для демаркации границы между двумя отдельными операторами. Терминатор операторов используется для маркировки конца отдельного оператора. Языки, которые интерпретируют конец строки как конец оператора называются однострочными языками программирования.
«Продолжение строки» — это соглашение для однострочных языков о ситуациях, когда символ окончания строки может быть неправильно интерпретирован как окончание оператора. В таких языках «продолжение строки» позволяет оператору охватывать более одной строки.

Продолжение строки
Операция продолжения строки обычно происходит на стадии лексического анализа: как правило символ новой строки не добавляет токен в соотв. список, если было обнаружено продолжение строки.

Символы пустого пространства — языки не требующие продолжения строкиАда — Строка обрывается точкой с запятой
C# — Строка обрывается точкой с запятой
JavaScript — Строка обрывается точкой с запятой (возможен неявный обрыв)
Lua
OCamlАмперсанд как последний символ строкиФортран 90, Фортран 95, Фортран 2003, Фортран 2008Обратная косая черта как последний символ строкиBash и др. оболочки Unix
Препроцессор Си и Си++
Mathematica and Wolfram Language
Python
Ruby
JavaScript — в текстовых константах, обрамлённых одной или двумя кавычкамиГравис как последний символ строкиPowerShellДефис как последний символ строкиSQL*PlusПодчёркивание как последний символ строкиAutoIt
Cobra
Visual Basic
XojoМноготочие (три точки, а не отдельный спец. символ)MATLAB: Многоточие не должно являться последним символом строки, однако все последующие символы игнорируются. (По сути оно начинает комментарий, который продолжается и на следующей строке, в отличие от однострочного комментария, который продолжается лишь до окончания строки.)Запятая как последний символ строкиRuby (за запятой может быть комментарий)
Левая скобка как последний символ строкиBat-файл: начало блока, обрамленного скобками разрешает продолжение строки
Ruby: Левая скобка — круглая, квадратная либо фигурнаяОператор в качестве последнего объекта строкиRuby (за оператором может быть комментарий)Оператор в начале продолжающейся строкиAutoHotkey: Любой оператор выражений за исключением ++ и --, а также точка или запятаяОбратная косая черта в начале продолжающейся строкиVimscriptКакая-либо форма однострочных комментариев как продолжение строкиTurbo Assembler: \
m4: dnl
TeX: %Позиция символаФортран 77: Строка не являющаяся комментарием будет продолжением предыдущей строки не комментария в случае если на позиции 6 находится не пробел. Строки являющиеся комментариями не могут быть продолжены.
Кобол: Текстовые константы могут быть продолжены, если не закончить их в предложении PICTURE символом ', а затем вставить символ - в 7 м столбце (на той же позиции, на которой использовался символ * для комментария)
TUTOR: Строки, начинающиеся символом табуляции (после требуемого контекстом отступа) продолжают предыдущую команду.Использование кавычекПрепроцессор Си и Си++: Использование кавычки в начале строки продолжает предыдущую строку после обычного окончания.

Библиотеки
Импорт библиотеки — это способ добавить внешние (возможно откомпилированные) процедуры, программы или пакеты. Импорты классифицируют по уровню (модуль, пакет, класс, процедура,…) и по синтаксису (директивы, атрибуты,…)

Импорт файловASP: #include file="filename"
AutoHotkey, AutoIt, Си, Си++: #include "filename", #include <filename>
Кобол: COPY filename.
Falcon: load "filename"
Фортран: include 'filename'
Lua: require("filename")
Mathematica и Wolfram: Import["filename"]
MATLAB: addpath(directory)
Objective-C: #import "filename", #import <filename>
Perl: require "filename";
PHP: include "filename";, require "filename";
Pick Basic: include [filename] program, #include [filename] program
R: source(""filename"")
Rust: include!( "filename");Импорт пакетовАда: with package
Си, Си++: #include filename
Cobra: use Package.Name
D: import package.module;, import altname = package.module;
Falcon: load module, load module.submodule
Фортран 90+: use module, use module, only : identifier
Go: import altname "package/name"
Haskell: import Module, import qualified Module as M
Java, MATLAB, Kotlin: import package.*
JavaScript: import altname from "modname";, import "modname";
Lua: require("modname")
Mathematica и Wolfram: <<name
Оберон (Oberon): IMPORT module
Objective-C: @import module;
Паскаль: uses unit
Perl: use Module;, use Module qw(import options);
Python: import module, from module import *
Rust: mod modname;, #[path = "filename"] mod altname;, extern crate libname;, extern crate libname as altname;
R: library("package")
Scala: import package._, import package
Swift: import moduleИмпорт классовFalcon: import class
Java, MATLAB, Kotlin: import package.class
JavaScript: import class from "modname";, import {class} from "modname";, import {class as altname} from "modname";
PHP: use Namespace\ClassName;, use Namespace\ClassName as AliasName;
Python: from module import class
Scala: import package.class, import package.{ class1 => alternativeName, class2 }, import package._Импорт процедур/функцийD: import package.module : symbol;, import package.module : altsymbolname = symbol;
Haskell: import Module (function)
JavaScript: import function from "modname";, import {function} from "modname";, import {function as altname} from "modname";
MATLAB: import package.function
Perl: use Module ('symbol');
PHP: use function Namespace\function_name;, use Namespace\function_name as function_alias_name;
Python: from module import function
Rust: use module::submodule::symbol;, use module::submodule::{symbol1, symbol2};, use module::submodule::symbol as altname;
Scala: import package.class.function, import package.class.{ function => alternativeName, otherFunction }Импорт константPHP: use const Namespace\CONST_NAME;Вышеуказанные операторы также могут быть разделены на 2 группы — являются ли они синтаксическим удобством (просто добавляют элементам краткое название, при этом элементы всё равно доступны по своему полному названию), либо нужны для доступа к коду (без этого оператора доступ к элементам невозможен даже при наличии полного имени).

Синтаксическое удобствоJava: import package.*, import package.class
OCaml: open moduleНеобходимы для доступа к кодуGo: import altname "package/name"
JavaScript: import altname from "modname";
Python: import module

Блоки
Блок представляет собой способ группировки двух или более отдельных операторов, выражений или иных элементов кода, которые должны представлять собой целое..

Скобки (фигурные скобки) { … }
Си, Си++, Objective-C, Go, Java, JavaScript/ECMAScript, C#, D, Perl, PHP (циклы for и loop , передача блоков как аргументов), Rust, Scala, S-Lang, Swift, Windows PowerShell, Haskell (в do-нотации), AutoHotkeyсм. также Curly bracket programming language

Круглые скобки ( … )OCaml, Standard MLКвадратные скобки [ … ]Smalltalk (блоки — объекты первого класса, т. н. замыкания)begin … end
Ада, Алгол, Паскаль, Ruby (циклы for, do/while и do/until), OCaml, Simula, Erlang.do … end
ПЛ/1 (PL/I), REXXdo … done
Bash (циклы for и while), Visual Basic, Фортран, TUTOR (тело блока обязано быть с отступом), Visual Prologdo … endLua, Ruby (блоки передаются как аргументы, цикл for), Seed7 (тело цикла заключено между do и end)X … end (напр. if … end):Ruby (операторы if, while, until, def, class, module), OCaml (циклы for и while), MATLAB (операторы if и switch, циклы for и while, предложение try , блоки package, classdef, properties, methods, events и function), Lua (then / else и function)(begin …)
Scheme(progn …)
Лисп(do …)
ClojureОтступыЗначимые (см. Off-side rule languages): Cobra, CoffeeScript, F#, Haskell (в do-нотации без скобок), Occam, Python
Не имеют значения (см. Free-form languages): потомки Алгола (включая Си, Паскаль и Perl); языки семейства ЛиспДругоеАда, Visual Basic, Seed7: if … end if
Bash, sh, and ksh: if … fi, do … done, case … esac;
Алгол 68: begin … end, ( … ), if … fi, do … od
Lua, Паскаль (язык программирования), Модула-2, Seed7: repeat … until
Кобол: IF … END-IF, PERFORM … END-PERFORM и т. д. для операторов; … . для предложений.
Visual Basic .NET: If … End If, For … Next, Do … Loop
Small Basic: If … EndIf, For … EndFor, While … EndWhile

Комментарии
Комментарии подразделяются по:

стилю (однострочные/многострочные)
правилам разбора/трансляции (ингорируются/интерполируются/сохраняются в памяти)
рекурсивности (вкладываемые/не-вкладываемые)
использованию (для документации (см. docstrings)/отбрасываемые/другие)

Однострочные комментарии
Как правило эти комментарии простираются до символа перевода строки, и используют оговоренную последовательность токенов для индикации начала комментария.
Примеры:

Многострочные комментарии
Как правило многострочные комментарии используют оговоренные последовательности символов для маркировки начала и конца комментария. В этом контексте символы пустого места или перевода строки игнорируются.
Примеры:

Уникальные варианты
Фортран
Решающее значение в Фортранe 66/77 имеют отступы. Основной оператор находится в столбцах с 7 по 72. Любой не пробел в столбце 6 указывает на то, что строка является продолжением предыдущей строки. Символ 'C' в первом столбце указывает на то, что строка является комментарием . Столбцы с 1-го по 5-й могут содержать число, являющееся меткой. Столбцы с 73-го по 80-й игнорируются и могут быть комментарием; ранее в этих местах наносился номер перфокарты, что позволяло отсортировать их в случае падения колоды. В Фортране 90 правило отступов было упразднено и были добавлены однострочные комментарии с использованием символа !.

Кобол
Отступы значимы в формате фиксированного кода. Содержание столбцов с 1-го по 6-й и после 73-го игнорируется. Если в 7-м столбце содержался символ * или / строка являлась комментарием. До версии Кобол 2002 если строка содержала в 7-м столбце символ D или d — это обозначало отладочную строку, которая могла игнорироваться в зависимости от режима компилирования.

Cobra
Cobra поддерживает многострочные комментарии «/# … #/» похожие на встречающиеся в Си-подобных языках «/* … */», однако с некоторыми отличиями. Символ # используется в однострочной форме комментариев «# …» и многострочные комментарии могут быть вложенными, что удобно при комментировании больших кусков кода.

Curl
Curl поддерживает многострочные комментарии при помощи пользовательских тегов |foo# ... #foo|.

Lua
Как и в текстовых константах, в многострочном комментарии может использоваться произвольное число символов =, при условии, что такое же их число используется и в закрывающей последовательности; это позволяет реализовать множественное вложение комментариев и текстовых констант если все они используют различное количество знаков = в обрамляющих тегах: --[[comment --[=[ nested comment ]=] ]]. Lua игнорирует первый перенос строки, который следует сразу за открывающим тегом.

Perl 5
Многострочные комментарии в Perl 5 считаются частью документации и именуются «Простая старая документация» (англ. Plain Old Documentation — POD). Технически в Perl 5 нет соглашения о многострочных комментариях, но POD повсеместно используются в этом качестве.

Perl 6
В Perl 6 для многострочных комментариев используется конструкция #`(...). Фактически Perl 6 позволяет использовать любые пары скобок после #` (напр. #`(...), #`[...], #`{...}, #`<...>, и даже более сложные #`{{...}} являются полноценными комментариями). Скобки также можно вкладывать внутри комментариев (напр. в конструкции #`{ a { b } c } комментарий продолжается до последней закрывающей скобки).

PHP
PHP поддеживает стандартные комментарии в стиле C/C++ а также комментарии в стиле Perl.

Python
Иногда для комментирования строк кода используются три двойных кавычки """. На самом деле они создают не комментарий, а пустой оператор с текстовой константой, который Python игнорирует (за исключением случая, когда текстовая константа — первый оператор в теле модуля, класса или функции; см docstring)

Ruby
Также как Python и Perl, Ruby не имеет определённого синтаксиса многострочных комментариев. Однако в качестве комментариев, как и в Perl, могут использоваться блоки документации, поскольку интерпретатор игнорирует их.

S-Lang
Интерпретатор игнорирует регион кода обрамленный #<tag> и #</tag>. Имя тега может быть любой алфавитно-цифровой последовательностью символов и указывать на способ обработки кода. Например, #<latex> может указывать на документацию в формате LaTeX.

Scheme and Racket
Следующий полный синтаксический элемент (s-выражение) может быть откомментирован при помощи #; .

ABAP
ABAP поддерживает два типа комментариев. Если первый символ строки (вкл. отступ) является звёздочкой (*) вся строка считается комментарием, а кавычками (") начинается комментарий до конца строки. Комментарии в ABAP невозможны между операторами EXEC SQL и ENDEXEC поскольку в SQL имеется другое применение этим символам. В большинстве диалектов SQL вместо этого используется двойной дефис (--).

Эзотерические языки программирования
Большинство эзотерических языков программирования следует соглашению о том, что любой не исполняющийся (напр. Befunge) или не имеющий значения (напр. Brainfuck) кусок кода считается комментарием.

Сравнение комментариев
Существует большое разнообразие способов объявления комментариев в исходном коде.
BlockComment курсивом указывает многострочное тело комментария.
InlineComment курсивом указывает однострочное тело комментария.

Примечания
Ссылки
Эволюция современных языков программирования | Мир ПК | Издательство «Открытые системы» (рус.) osp.ru
Компьютерра: Java vs .NET (рус.) computerra