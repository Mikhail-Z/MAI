В приведённой ниже таблице отмечено наличие или отсутствие тех или иных возможностей в некоторых популярных сегодня языках программирования. Столбцы упорядочены по алфавиту. Если возможность в языке недоступна напрямую, но может быть эмулирована с помощью других средств, то в таблице отмечено, что её нет.
При заполнении таблицы учтены только фактические данные, при том, что наличие возможности не обязательно является преимуществом языка, а отсутствие — недостатком.

Парадигмы
Типизация
Компилятор/интерпретатор
Управление памятью
Управление потоком вычислений
Типы и структуры данных
Объектно-ориентированные возможности
Функциональные возможности
Разное
Стандартизация
Примечания
Терминология
Парадигмы
Императивная
Противоположность декларативному. Императивный язык должен описывать не столько саму задачу (описание, «ЧТО» нужно получить), сколько её решение («КАК» получить). Некоторыми авторами считается, что данное определение скорее относится к «процедурной» парадигме, которая, помимо императивного, включает в себя функциональное программирование.

Объектно-ориентированная
Основана на представлении всего в виде объектов, являющихся экземплярами того или иного класса и воплощает применение концепции абстрагирования. Объект при этом соединяет внутри себя как данные, так и методы, их обрабатывающие. Как правило, поддерживаются характерные возможности: наследование, инкапсуляция и полиморфизм. Некоторые авторы языки без наследования относят к просто «объектным».

Рефлексивная
Наличие в языке мощных механизмов интроспекции, функции eval. Возможность программы на данном языке оперировать собственным кодом как данными.

Функциональная
Позволяет записывать программу как композицию функций. В чистом функциональном языке нет переменных. Так как функции не имеют побочных эффектов, они могут выполняться в любом порядке.

Обобщенное программирование
Обобщенное программирование позволяет записывать алгоритмы, принимающие данные любого типа.

Логическая
Программа представляет собой описание фактов и правил вывода в некотором логическом исчислении. Желаемый результат, который часто записывается как вопрос, получается системой в результате попытки применения описанных правил — путём логического вывода. Интересными особенностями являются отсутствие детерминированности в общем случае, внутренняя склонность к распараллеливанию.

Доказательная
Направлен на разработку алгоритмов и программ с доказательствами их правильности с использованием спецификаций программ.

Декларативная
Противоположность императивному. Декларативный язык описывает не столько решение задачи, сколько саму задачу («ЧТО» нужно получить), а каким образом получить решение, уже должен определять компьютер.

Распределенная
Язык, содержащий специальные конструкции для поддержки распараллеливания программы на несколько компьютеров.

Типизация
Статическая типизация
(См. статическая типизация). Переменные и параметры методов/функций связываются с типами в момент объявления и не могут быть изменены позже.

Динамическая типизация
(См. динамическая типизация). Переменные и параметры методов/функций связываются с типами в момент присваивания значения (или передачи параметра в метод/функцию), а не в момент объявления переменной или параметра. Одна и та же переменная в разные моменты может хранить значения разных типов.

Явная типизация
Типы переменных и параметров указываются явно.

Неявная типизация
Типы переменных и параметров не указываются явно. Неявная типизация может быть и статической, в таком случае типы переменных и параметров вычисляются компилятором.

Явное приведение типов
Для использования переменной какого-либо типа там, где предполагается использование переменной другого типа, нужно (возможно) явно выполнить преобразование типа.

Неявное приведение типов без потери данных
Неявное приведение типов в таких ситуациях, где не происходит потери данных — например, использование целого числа там, где предполагалось использование числа с плавающей точкой.

Неявное приведение типов с потерей данных
Неявное приведение типов в таких ситуациях, где может произойти потеря данных — например, использование числа с плавающей точкой там, где предполагалось использование целого числа.

Неявное приведение типов в неоднозначных ситуациях
Например, использование строки там, где предполагалось число или наоборот. Классический пример: сложить число 1 со строкой «2» — результат может быть как число 3, так и строка «12». Другой пример — использование целого числа там, где ожидается логическое значение (boolean).

Алиасы типов
Возможность определить видимый глобально (за пределами единицы компиляции) алиас типа, полностью эквивалентный исходному типу. Например, typedef в Си. Директива using в C# не подходит под этот критерий из-за локальной области действия.

Вывод типов переменных из инициализатора
Возможность не указывать явно тип переменной, если для неё задан инициализатор. Если возможность действует для локальных переменных, но не действует для полей класса, все равно ставьте +. Характеристика не применима к языкам с динамической типизацией.

Вывод типов переменных из использования
Возможность не указывать явно тип переменной, если её тип может быть выведен из дальнейшего использования. Если возможность действует для локальных переменных, но не действует для полей класса, все равно ставьте +. Характеристика не применима к языкам с динамической типизацией.

Вывод типов-аргументов при вызове метода
Возможность не указывать явно типы-аргументы при вызове generic-метода, если они могут быть выведены из типов обычных аргументов.

Вывод сигнатуры для локальных функций
Может ли сигнатура локальной функции быть выведена из использования. Неприменимо для языков с динамической типизацией. Ставьте -, если язык не поддерживает локальные функции.

Параметрический полиморфизм
Наличие типобезопасного параметрического полиморфизма (aka generic types). Подразумевает возможность указывать constraints или type classes для типов-параметров.

Параметрический полиморфизм с ковариантностью
Наличие ко- и контравариантных type parameters. В некоторых языках может быть лишь частичная поддержка (например, только в интерфейсах и делегатах). В таком случае, отмечайте +/-.

Параметрический полиморфизм высших порядков
Возможность создавать type constructors высших порядков (как в Scala). См. Towards Equal Rights for Higher-kinded Types

Информация о типах в runtime
Возможность узнать точный тип объекта в runtime.

Информация о типах-параметрах в runtime
Возможность узнать в runtime информацию о типе, с которым инстанциирован generic-тип. Если язык не поддерживает generic-типы, то ставьте -. Если информация о типах стирается в runtime (используется erasure), то ставьте -.

Компилятор/интерпретатор
Open-source компилятор (интерпретатор)
Наличие полноценного open-source компилятора (для интерпретируемых языков — интерпретатора). Если существует open-source компилятор, но он поддерживает не все возможности языка, то ставьте +/- или -/+.

Возможность компиляции
Возможность компиляции в нативный код или в byte-код с возможностью JIT-компиляции. Если язык компилируется в код на другом языке (например, C), который потом компилируется в нативный код, то тоже ставьте +.

Bootstrapping
Наличие полноценного bootstrapping-компилятора (то есть компилятора, написанного на том же языке, который он компилирует, и успешно компилирующего самого себя). Если существует bootstrapping-компилятор, но он поддерживает не все возможности языка, то ставьте +/- или -/+.

Многопоточная компиляция
Возможность компилятора на многопроцессорных системах использовать несколько потоков для ускорения компиляции. Если язык не поддерживает компиляцию, то ставьте x (неприменимо).

Интерпретатор командной строки
Возможность вводить инструкции языка строка за строкой с их немедленным выполнением. Может использоваться в качестве калькулятора.

Условная компиляция
Возможность включать/выключать части кода в зависимости от значения символов условной компиляции (например, с помощью #if … #endif в C++)

Управление памятью
Объекты на стеке
Возможность создавать экземпляры объектов не в куче, а на стеке.

Неуправляемые указатели
Наличие неуправляемых указателей, адресная арифметика, прямой доступ к памяти.

Ручное управление памятью
Возможность явного выделения и освобождения памяти в куче (например, с помощью операторов new и delete в C++).

Сборка мусора
Возможность использовать автоматический процесс сборки мусора (освобождения памяти в куче, занятой неиспользуемыми объектами).

Управление потоком вычислений
Инструкция goto
Поддержка инструкции goto (безусловный переход на метку).

Инструкция break без метки
Поддержка инструкции break без метки (безусловный выход из ближайшего цикла), и соответствующей инструкции continue. Наличие в языке инструкции break, относящегося к switch или другой конструкции, не влияет на это поле.

Инструкция break с меткой
Поддержка инструкции break с меткой (безусловный выход из цикла, помеченного меткой), и соответствующей инструкции continue. Наличие в языке инструкции break, относящегося к switch или другой конструкции, не влияет на это поле.

Поддержка try/catch
Поддержка обработки исключений с помощью try/catch или эквивалентной конструкции.

Блок finally
Поддержка блока finally при обработке исключений или эквивалентной конструкции.

Блок else (исключения)
Поддержка блока else при обработке исключений (действия, выполняющиеся при завершении блока try без исключения).

Перезапуски
Исключения, не раскручивающие стек вызовов. Возможность из места перехвата исключения вернуться в место установки перезапуска.

Легковесные процессы
Эмуляция многопоточности рантаймом самого языка. В пределах одного потока ОС (или нескольких) выполняется множество потоков исходного кода

Типы и структуры данных
Многомерные массивы
Наличие встроенных в язык многомерных массивов. Если язык поддерживает только массивы массивов, ставьте +/-

Динамические массивы
Наличие встроенных в язык динамических массивов (способных изменять свой размер во время выполнения программы). Если динамические массивы представлены только векторами (то есть только одномерными массивами) или векторами векторов, ставьте +/-

Ассоциативные массивы
Наличие встроенных в язык ассоциативных массивов или хеш-таблиц.

Цикл foreach
Наличие возможности перебрать все элементы коллекции с помощью цикла foreach. Если в языке есть эквивалентная или более сильная возможность (наподобие list comprehensions), то будет +.

Списковые включения
Наличие списковых включений (или их аналога).

Кортежи
Возможность вернуть из функции/метода кортеж (tuple) — неименованный тип данных, содержащий несколько безымянных полей произвольного типа.

Целые числа произвольной длины
Поддержка целых чисел неограниченной разрядности. Должна быть возможность записать сколь угодно большое целое число с помощью литерала.

Целые числа с контролем границ
Возможность определить тип, значениями которого могут быть целые числа только определённого интервала, например [-5..27], при этом присвоение переменной такого типа значения, выходящего за указанные рамки, должно вызывать ошибку.

Объектно-ориентированные возможности
Интерфейсы
Семантическая и синтаксическая конструкция в коде программы, используемая для специфицирования услуг, предоставляемых классом.

Множественное наследование
Возможность наследовать класс сразу от нескольких классов (не интерфейсов).

Мультиметоды
Динамическая (run time) диспетчеризация функции в зависимости от типов нескольких аргументов.
В языках с «message passing» ООП похожая функциональность реализуется паттерном «Visitor».

Переименование членов при наследовании
Возможность в наследнике изменить имя поля/метода предка.

Решение конфликта имен при множественном наследовании
При множественном наследовании — решение для случая ромбовидного наследования (B потомок A, C потомок A, D потомок B и C). Решение может приниматься как для всего класса, так и для каждого поля/метода в отдельности.

Функциональные возможности
First class functions
Функции в данном языке являются объектами первого класса.

Лексические замыкания
Возможность использовать локальную или лямбда-функцию (анонимный делегат) за пределами функции-контейнера с автоматическим сохранением контекста (локальных переменных) функции-контейнера

Частичное применение
Возможность фиксировать часть аргументов функции, то есть имея функцию 
  
    
      
        f
        :
        (
        A
        ×
        B
        )
        →
        C
      
    
    {\displaystyle f\colon (A\times B)\to C}
  , создать функцию 
  
    
      
        P
        (
        f
        ,
        a
        )
        :
        B
        →
        C
      
    
    {\displaystyle P(f,a)\colon B\to C}
  , где 
  
    
      
        (
        P
        (
        f
        ,
        a
        )
        )
        (
        b
        )
        =
        f
        (
        a
        ,
        b
        )
      
    
    {\displaystyle (P(f,a))(b)=f(a,b)}
  . Не следует путать с каррированием (оператор каррирования — один из вариантов реализации частичного применения).

Разное
Макросы
Наличие в языке макро-системы, обрабатывающей код программы до времени её компиляции и/или выполнения. Например, макросы Лиспа, препроцессор Си или шаблоны С++.

Шаблоны/Generics
Наличие в данном статически типизированном языке инструмента для обобщенного программирования, наподобие templates в C++ или generics в C#.

Поддержка Unicode в идентификаторах
Возможность включения Unicode-символов (например, букв национальных алфавитов) в идентификаторы.

Перегрузка функций
Возможность перегрузки функций/методов по количеству и типам параметров.

Динамические переменные
Возможность создавать переменные, имеющие динамическую область видимости (англ.).

Именованные параметры
Возможность при вызове функции/метода указывать имена параметров и менять их местами.

Значения параметров по умолчанию
Возможность при вызове функции/метода опускать некоторые параметры, чтобы при этом подставлялось значение по умолчанию, указанное при определении функции.

Локальные функции
Возможность определять локальную функцию внутри другой функции/метода. Подразумевается возможность использовать внутри локальной функции локальные переменные из внешнего блока.

Сопоставление с образцом
Наличие сопоставления с образцом.

Контрактное программирование
Возможность задавать пред- и пост-условия для методов и инварианты для классов.

Ссылки
Эволюция современных языков программирования | Мир ПК | Издательство «Открытые системы» (рус.) osp.ru
Компьютерра: Java vs .NET (рус.) computerra
Таблица сравнения языков от создателей D (+ обсуждение на RSDN)
Созданная на её основе поклонниками других языков более объемлющая таблица (англ.)
Microbenchmarking C++, C#, and Java (англ.)