Межпроцедурная оптимизация (англ. Interprocedural Optimization, IPO), или полнопрограммная оптимизация программ (англ. whole program optimization) — оптимизация компилятора, которая использует глобальный анализ потока управления и затрагивает множество процедур, даже находящихся в разных модулях, за счёт чего может достигаться существенный прирост быстродействия.
С ростом объёма программ разработчики стали делать свой код всё более удобочитаемым и повторно используемым. Зачастую это приводит к тому, что процедуры становятся предельно общими, в то время как в конкретной программе можно обойтись и частным случаем. Задача межпроцедурной оптимизации — именно генерация таких частных случаев.
Межпроцедурная оптимизация выполняется компилятором автоматически (иногда с указанием специальных директив). Её активация может приводить к существенному увеличению времени компиляции. К компиляторам, умеющим выполнять указанную оптимизацию, относятся MLton и MLKit для Standard ML, Stalin для Scheme, JHC для Haskell, Intel C++ Compiler.

Примеры
Замена параметра функции константой
Пройдя по коду, компилятор убеждается, что один из параметров всегда константа, и уничтожает его.

Было
Стало
Замена виртуального вызова статическим
Здесь компилятор убеждается, что все реально выполняющиеся виртуальные вызовы ведут к вызову одной и той же функции. Вместо того, чтобы обращаться к таблице виртуальных методов, компилятор делает прямой вызов функции.
В том же примере, если Object::name() — виртуальный метод, оптимизированная функция будет выглядеть так.

Удаление незадействованного кода
После удаления получится:

Заодно может происходить чистка таблиц виртуальных методов.

Инлайнинг
Если функция используется однократно, она напрямую включается в то место, из которого она вызывается.
Небольшие функции также можно напрямую включать в вызывающий код.
Многие языки программирования (Паскаль, Java, D) не имеют ключевого слова inline, и решение инлайнировать функцию принимается оптимизатором (в случае Java — обфускатором).

Было


==== Стало ====