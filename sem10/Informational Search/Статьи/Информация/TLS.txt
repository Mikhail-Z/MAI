TLS (англ. transport layer security — Протокол защиты транспортного уровня), как и его предшественник SSL (англ. secure sockets layer — слой защищённых сокетов), — криптографические протоколы, обеспечивающие защищённую передачу данных между узлами в сети Интернет. TLS и SSL используют асимметричное шифрование для аутентификации, симметричное шифрование для конфиденциальности и коды аутентичности сообщений для сохранения целостности сообщений.
Данный протокол широко используется в приложениях, работающих с сетью Интернет, таких как веб-браузеры, работа с электронной почтой, обмен мгновенными сообщениями и IP-телефония (VoIP).
TLS-протокол основан на спецификации протокола SSL версии 3.0, разработанной компанией Netscape Communications.
Сейчас развитием стандарта TLS занимается IETF. Последнее обновление протокола было в RFC 5246 (август 2008) и RFC 6176 (март 2011).

Описание
TLS даёт возможность клиент-серверным приложениям осуществлять связь в сети таким образом, что нельзя производить прослушивание пакетов и осуществить несанкционированный доступ.
Так как большинство протоколов связи может быть использовано как с, так и без TLS (или SSL), при установке соединения необходимо явно указать серверу, хочет ли клиент устанавливать TLS. Это может быть достигнуто либо с помощью использования унифицированного номера порта, по которому соединение всегда устанавливается с использованием TLS (как, например, порт 443 для HTTPS), либо с использованием произвольного порта и специальной команды серверу со стороны клиента на переключение соединения на TLS с использованием специальных механизмов протокола (как, например, STARTTLS для протоколов электронной почты).
Как только клиент и сервер договорились об использовании TLS, им необходимо установить защищённое соединение. Это делается с помощью процедуры подтверждения связи. Во время этого процесса клиент и сервер принимают соглашение относительно различных параметров, необходимых для установки безопасного соединения.
Основные шаги процедуры создания защищённого сеанса связи:

клиент подключается к серверу, поддерживающему TLS, и запрашивает защищённое соединение;
клиент предоставляет список поддерживаемых алгоритмов шифрования и хеш-функций;
сервер выбирает из списка, предоставленного клиентом, наиболее надёжные алгоритмы среди тех, которые поддерживаются сервером, и сообщает о своём выборе клиенту;
сервер отправляет клиенту цифровой сертификат для собственной аутентификации. Обычно цифровой сертификат содержит имя сервера, имя удостоверяющего центра сертификации и открытый ключ сервера;
клиент, до начала передачи данных, проверяет валидность (аутентичность) полученного серверного сертификата относительно имеющихся у клиента корневых сертификатов удостоверяющих центров (центров сертификации). Клиент также может проверить, не отозван ли серверный сертификат, связавшись с сервисом доверенного удостоверяющего центра;
для шифрования сессии используется сеансовый ключ. Получение общего секретного сеансового ключа клиентом и сервером проводится по протоколу Диффи-Хеллмана. Существует исторический метод передачи сгенерированного клиентом секрета на сервер при помощи шифрования асимметричной криптосистемой RSA (используется ключ из сертификата сервера). Данный метод не рекомендован, но иногда продолжает встречаться на практике.На этом заканчивается процедура подтверждения связи. Между клиентом и сервером установлено безопасное соединение, данные, передаваемые по нему, шифруются и расшифровываются с использованием симметричной криптосистемы до тех пор, пока соединение не будет завершено.
При возникновении проблем на некоторых из вышеуказанных шагов подтверждение связи может завершиться с ошибкой, а безопасное соединение не будет установлено.

История и версии
Первые попытки реализовать зашифрованные сетевые сокеты предпринимались в 1993 году. Оригинальные протоколы SSL были разработаны Netscape: версия 1.0 в силу ряда недостатков не была опубликована, версия 2.0 представлена в 1995 году и замещена версией 3.0 в 1996 году. Версия SSL 3.0 представляла собой полную переработку протокола, выполненную Paul Kocher и сотрудниками Netscape Phil Karlton и Alan Freier и реализованную при участии компании Consensus Development. Последующие версии SSL и TLS основаны на SSL 3.0. Черновик стандарта 1996 года был опубликован IETF как RFC 6101. Использование SSL 2.0 было прекращено в 2011 году с выпуском документа RFC 6176. В 2014 году против блочных шифров SSL 3.0 была предложена атака POODLE, а единственный поддерживаемый потоковый шифр RC4 имел иные проблемы с безопасностью в том виде, как он использовался. В июне 2015 года SSL 3.0 был признан устаревшим (RFC 7568).
TLS 1.0 появился в 1999 году в виде обновления для SSL 3.0 и описан в RFC 2246. В 2018 году PCI DSS призывала корпорации отказаться от TLS 1.0 и в октябре 2018 крупнейшие игроки на рынке браузеров и ОС (Apple, Google, Microsoft, Mozilla) объявили, что прекратят поддержку TLS версий 1.0 и 1.1 в марте 2020 года.TLS 1.1 был описан в RFC 4346 в апреле 2006 года. Он добавил к TLS 1.0 ряд защит от атак на CBC режимы шифрования и на ошибки дополнения данных до размера блока, начал использовать явный вектор инициализации и регистрацию числовых кодов для параметров в IANA.
TLS 1.2 появился в августе 2008 года как обновление версии 1.1, описан в RFC 5246. Были запрещены устаревшие криптографические хэш-функции MD5 и SHA-1 (заменены на SHA-256), улучшен механизм согласования сторонами списков поддерживаемых методов, введены методы AEAD (GCM и CCM для AES).В марте 2011 года документ RFC 6176 запретил реализацию обратной совместимости со старыми версиями SSL во всех протоколах TLS.
Новейшим обновлением стал TLS 1.3, описанный в августе 2018 года в RFC 8446. В этой версии были разделены процессы согласования ключей, аутентификации и наборы шифрования; запрещены слабые и редкие эллиптические кривые, хэши MD5 и SHA-224; введена обязательность цифровой подписи; внедрена HKDF и полуэфемерная система DH. Вместо механизма возобновления применен PSK и система мандатов, ускорены процессы соединения (1-RTT и 0-RTT), постулирована обязательность perfect forward secrecy для сессионных ключей через протоколы генерации DH и ECDH. Были запрещены такие устаревшие и небезопасные опции как сжатие данных, пересогласование, шифры без аутентификации сообщений (т.е. не AEAD режимы), несекретные методы получения сессионных ключей (RSA, статический DH, группы DHE), вспомогательные сообщения (Change Cipher Spec, HELLO, поле длины AD). Прекращена обратная совместимость с SSL или RC4. Появились поточный шифр ChaCha20 с MAC кодом Poly1305, подписи Ed25519 и Ed448, протоколы обмена ключами x25519 и x448.
Поддержка TLS 1.3 появилась в Mozilla Network Security Services (NSS) в феврале 2017 года (включено в Firefox 60). Google Chrome некоторое время поддерживал TLS 1.3 в 2017 но отключил его ради Blue Coat web proxу. OpenSSL добавил эту версию в выпуск 1.1.1 от сентября 2018 года. Electronic Frontier Foundation похвалил TLS 1.3 и предостерег от путаницы с сходным клептографическим протокольным гибридом "ETS" или "eTLS" (в нём намерено выключены важные свойства безопасности из TLS 1.3).

Безопасность
TLS имеет множество мер безопасности:

Защита от понижения версии протокола к предыдущей (менее защищённой) версии или менее надёжному алгоритму шифрования;
Нумерация последовательных записей приложения и использование порядкового номера в коде аутентификации сообщения (MAC);
Использование ключа в идентификаторе сообщения (только владелец ключа может сгенерировать код аутентификации сообщения). Алгоритм вычисления кода аутентификации (HMAC), используемый во многих сессиях TLS, определён в RFC 2104;
Сообщение, которым заканчивается подтверждение связи («Finished»), используется для подтверждения аутентичности ранее переданных сообщений и, таким образом, выбранных параметров TLS-соединения.Уязвимость протокола TLS 1.0, которая считалась теоретической, была продемонстрирована на конференции Ekoparty в сентябре 2011 года. Демонстрация включала в себя дешифрование cookies, использованных для аутентификации пользователя.
Уязвимость в фазе возобновления соединения, обнаруженная в августе 2009 года, позволяла криптоаналитику, способному взломать https-соединение, добавлять собственные запросы в сообщения, отправленные от клиента к серверу. Так как криптоаналитик не может дешифровать переписку сервера и клиента, этот тип атаки отличается от стандартной атаки, типа человек посередине. В случае, если пользователь не обращает внимания на индикацию браузера о том, что сессия является безопасной (обычно значок замка), уязвимость может быть использована для атаки типа человек посередине. Для устранения этой уязвимости было предложено как на стороне клиента, так и на стороне сервера добавлять информацию о предыдущем соединении и осуществлять проверку при возобновлении соединения. Это было представлено в стандарте RFC 5746, а также реализовано в последних версиях OpenSSL и других библиотеках.
Также существуют варианты атак, основанные непосредственно на программной реализации протокола, а не на его алгоритме.

Процедура подтверждения связи в TLS в деталях
Согласно протоколу TLS, приложения обмениваются записями, инкапсулирующими (хранящими внутри себя) информацию, которая должна быть передана. Каждая из записей может быть сжата, дополнена, зашифрована или идентифицирована MAC (код аутентификации сообщения) в зависимости от текущего состояния соединения (состояния протокола). Каждая запись в TLS содержит следующие поля: Content Type (определяет тип содержимого записи), Version (поле, указывающее версию протокола TLS) и Length (поле, указывающее длину пакета).
Когда соединение только устанавливается, взаимодействие идёт по протоколу TLS handshake, content type которого - 22.

Простое подтверждение связи в TLS
Далее показан простой пример установления соединения, при котором сервер (но не клиент) проходит аутентификацию по его сертификату.

Фаза переговоров:
Клиент посылает сообщение ClientHello, указывая последнюю версию поддерживаемого TLS-протокола, случайное число и список поддерживаемых шифронаборов (методов шифрования, англ. cipher suites), подходящих для работы с TLS;
Сервер отвечает сообщением ServerHello, содержащим: выбранную сервером версию протокола, случайное число, сгенерированное сервером, выбранный шифронабор из списка, предоставленного клиентом;
Сервер посылает сообщение Certificate, которое содержит цифровой сертификат сервера (в зависимости от алгоритма шифрования этот этап может быть пропущен);
Если переданных сервером данных недостаточно для выработки общего симметричного секретного ключа в рамках выбранного шифронабора, сервер передаёт сообщение ServerKeyExchange, в котором передаются необходимые данные. Например, в  ServerKeyExchange передаётся серверная часть обмена для протокола Диффи-Хеллмана;
Сервер отсылает сообщение ServerHelloDone, идентифицирующее окончание первого раунда установления соединения;
Клиент отвечает сообщением ClientKeyExchange, которое содержит клиентскую часть протокола Диффи-Хеллмана или зашифрованный открытым ключом из сертификата сервера секрет (PreMasterSecret);
Клиент и сервер, используя ключ PreMasterSecret и случайно сгенерированные числа, вычисляют общий секрет. Вся остальная информация о сеансовом ключе будет получена из общего секрета;
Клиент посылает сообщение ChangeCipherSpec, которое указывает на то, что вся последующая информация будет зашифрована установленным в процессе подтверждения связи алгоритмом, используя общий секретный ключ. Это сообщение уровня записей и поэтому имеет тип 20, а не 22;
Клиент посылает сообщение Finished, которое содержит хеш и MAC, сгенерированные на основе предыдущих сообщений процедуры подтверждения связи;
Сервер пытается расшифровать Finished-сообщение клиента и проверить хеш и МАС. Если процесс расшифровки или проверки не удаётся, подтверждение связи считается неудавшимся, и соединение должно быть оборвано;
Сервер посылает ChangeCipherSpec и зашифрованное сообщение Finished, и в свою очередь клиент тоже выполняет расшифровку и проверку.С этого момента подтверждение связи считается завершённым, протокол - установленным. Всё последующее содержимое пакетов идёт с типом 23, а все данные будут зашифрованы.

Подтверждение связи с аутентификацией клиента
В данном примере показана полная аутентификация клиента (в дополнение к аутентификации сервера, как в предыдущем примере) с помощью обмена сертификатами между сервером и клиентом.

Фаза переговоров:
Клиент посылает сообщение ClientHello, указывая последнюю версию поддерживаемого TLS-протокола, случайное число и список поддерживаемых методов шифрования и сжатия, подходящих для работы с TLS;
Сервер отвечает сообщением ServerHello, содержащим: выбранную сервером версию протокола, случайное число, посланное клиентом, подходящий алгоритм шифрования и сжатия из списка предоставленного клиентом;
Сервер посылает сообщение Certificate, которое содержит цифровой сертификат сервера (в зависимости от алгоритма шифрования этот этап может быть пропущен);
Сервер посылает сообщение CertificateRequest, которое содержит запрос сертификата клиента для взаимной проверки подлинности;
Клиент посылает сообщение Certificate, которое содержит цифровой сертификат клиента;
Сервер отсылает сообщение ServerHelloDone, идентифицирующее окончание подтверждения связи;
Клиент отвечает сообщением ClientKeyExchange, которое содержит открытый ключ PreMasterSecret или ничего (опять же зависит от алгоритма шифрования);
Клиент и сервер, используя ключ PreMasterSecret и случайно сгенерированные числа, вычисляют общий секретный ключ. Вся остальная информация о ключе будет получена из общего секретного ключа (и сгенерированных клиентом и сервером случайных значений);
Клиент посылает сообщение ChangeCipherSpec, которое указывает на то, что вся последующая информация будет зашифрована установленным в процессе подтверждения связи алгоритмом, используя общий секретный ключ. Это сообщения уровня записей и поэтому имеет тип 20, а не 22;
Клиент посылает сообщение Finished, которое содержит хеш и MAC, сгенерированные на основе предыдущих сообщений процедуры подтверждения связи;
Сервер пытается расшифровать Finished-сообщение клиента и проверить хеш и МАС. Если процесс расшифровки или проверки не удаётся, подтверждение связи считается неудавшимся, и соединение должно быть оборвано.
Сервер посылает ChangeCipherSpec и зашифрованное сообщение Finished, и в свою очередь клиент тоже выполняет расшифровку и проверку.С этого момента подтверждение связи считается завершённым, протокол установленным. Всё последующее содержимое пакетов идёт с типом 23, а все данные будут зашифрованы.

Возобновление TLS-соединения
Алгоритмы асимметричного шифрования, использующиеся при генерации сеансового ключа, обычно являются дорогими с точки зрения вычислительных мощностей. Для того чтобы избежать их повторения при возобновлении соединения, TLS создаёт специальный ярлык при подтверждении связи, использующийся для возобновления соединения. При этом при обычном подтверждении связи клиент добавляет в сообщение ClientHello идентификатор предыдущей сессии session id. Клиент связывает идентификатор session id с IP-адресом сервера и TCP-портом так, чтобы при соединении к серверу можно было использовать все параметры предыдущего соединения. Сервер сопоставляет идентификатор предыдущей сессии session id c параметрами соединения, такими как использованный алгоритм шифрования и master secret. Обе стороны должны иметь одинаковый master secret, иначе соединение не будет установлено. Это предотвращает использование session id криптоаналитиком для получения несанкционированного доступа. Случайные цифровые последовательности в сообщениях ClientHello и ServerHello позволяют гарантировать, что сгенерированный сеансовый ключ будет отличаться от сеансового ключа при предыдущем соединении. В RFC такой тип подтверждения связи называется сокращённым.

Фаза переговоров:Клиент посылает сообщение ClientHello, указывая последнюю версию поддерживаемого TLS-протокола, случайное число и список поддерживаемых методов шифрования и сжатия, подходящих для работы с TLS; Также в сообщение добавляется идентификатор предыдущего соединения session id.
Сервер отвечает сообщением ServerHello, содержащим: выбранную сервером версию протокола, случайное число, посланное клиентом, подходящий алгоритм шифрования и сжатия из списка предоставленного клиентом. Если сервер узнал идентификатор сессии session id, то он добавляет в сообщение ServerHello тот же самый идентификатор session id. Это является сигналом для клиента о том, что можно использовать возобновление предыдущей сессии. Если сервер не узнал идентификатор сессии session id, то он добавляет в сообщение ServerHello другое значение вместо session id. Для клиента это означает, что использовать возобновлённое соединение нельзя. Таким образом, сервер и клиент должны иметь одинаковый master secret и случайные числа для генерации сеансового ключа;
Сервер посылает сообщение ChangeCipherSpec, которое указывает на то, что вся последующая информация будет зашифрована установленным в процессе подтверждения связи алгоритмом, используя общий секретный ключ. Это сообщения уровня записей и поэтому имеет тип 20, а не 22;
Сервер посылает зашифрованное сообщение Finished, которое содержит хеш и MAC, сгенерированные на основе предыдущих сообщений процедуры подтверждения связи;
Клиент пытается расшифровать Finished сообщение сервера и проверить хеш и МАС. Если процесс расшифровки или проверки не удаётся, подтверждение связи считается неудавшимся, и соединение должно быть оборвано;
Клиент посылает сообщение ChangeCipherSpec, которое указывает на то, что вся последующая информация будет зашифрована установленным в процессе подтверждения связи алгоритмом, используя общий секретный ключ.
Клиент посылает своё зашифрованное сообщение Finished;
Сервер схожим образом пытается расшифровать Finished-сообщение клиента и проверить хеш и MAC;
С этого момента подтверждение связи считается завершённым, протокол - установленным. Всё последующее содержимое пакетов идёт с типом 23, а все данные будут зашифрованы.Кроме преимуществ с точки зрения производительности, алгоритм возобновления соединения может быть использован для реализации единого входа, поскольку гарантируется, что исходная сессия, как и любая возобновлённая сессия, инициирована тем же самым клиентом (RFC 5077). Это имеет особенно важное значение для реализации FTPS протокола, который в противном случае был бы уязвим к атаке типа "человек посередине", при которой злоумышленник мог бы перехватить содержание данных при установлении повторного соединения.

Мандаты сессий
RFC 5077 расширяет TLS через использование мандатов сессий (англ. session tickets) вместо идентификаторов соединений (session id). Он определяет способ возобновления сеанса TLS, не требуя session id предыдущей сессии, состояние которой хранится на TLS-сервере.
При использовании сессионных мандатов TLS-сервер хранит сеансовое состояние в мандате сеанса и посылает мандат для хранения на TLS-клиенте. Клиент возобновляет TLS-сессию, отправив мандат сеанса на сервер, а сервер возобновляет TLS-сессию в соответствии с параметрами конкретной сессии, сохранёнными в принятом мандате. Сессионный мандат шифруется, в зашифрованном виде проходит аутентификацию на сервере, и сервер проверяет обоснованность мандата прежде, чем использовать его содержимое.
Одна из слабостей этого метода — для шифрования и аутентификации передаваемых сессионных мандатов всегда используется только метод AES128-CBC-SHA256, независимо от того, какие параметры TLS выбраны и используются для самого TLS-соединения. Это означает, что информация о TLS-сессии (сохраняемая в сессионном мандате) не так хорошо защищена, как в рамках самой TLS-сессии. Особую озабоченность вызывает хранение OpenSSL-ключей в контексте приложения (SSL_CTX) в течение времени жизни приложения, не допуская их повторного ввода из AES128-CBC-SHA256 сессионных мандатов без сброса OpenSSL-контекста всего приложения (что редкость, подвержено ошибкам и часто требует ручного вмешательства администратора).

Алгоритмы, использующиеся в TLS
В текущей версии протокола доступны следующие алгоритмы:

Для обмена ключами и проверки их подлинности применяются комбинации алгоритмов: RSA (асимметричный шифр), Diffie-Hellman (безопасный обмен ключами), DSA (алгоритм цифровой подписи), ECDSA;
Для симметричного шифрования: RC4, IDEA, Triple DES, SEED, Camellia или AES;
Для хеш-функций: MD5, SHA, SHA-256/384.Алгоритмы могут дополняться в зависимости от версии протокола. До версии протокола TLS 1.2 были доступны также следующие алгоритмы симметричного шифрования, но они были убраны как небезопасные: RC2, IDEA, DES.

Сравнение с аналогами
Одной из областей применения TLS-соединения является соединение узлов в виртуальной частной сети. Кроме TLS, также могут использоваться набор протоколов IPSec и SSH-соединение. Каждый из этих подходов к реализации виртуальной частной сети имеет свои преимущества и недостатки.

TLS/SSL
Преимущества:
Невидим для протоколов более высокого уровня;
Популярность использования в Интернет-соединениях и приложениях электронной коммерции;
Отсутствие постоянного соединения между сервером и клиентом;
Позволяет создать туннель для приложений, использующих TCP, таких как электронная почта, инструменты программирования и т. д.
Недостатки:
Невозможность использования с протоколами UDP и ICMP;
Необходимость отслеживания состояния соединения;
Наличие дополнительных требований к программному обеспечению о поддержке TLS.
IPsec
Преимущества:
Безопасность и надёжность защиты данных протокола проверена и доказана, так как протокол был принят как Интернет-стандарт;
Работа в верхнем слое сетевого протокола и шифрование данных над уровнем сетевого протокола.
Недостатки:
Сложность реализации, создающая потенциал для уязвимостей;
Дополнительные требования к оборудованию сети (маршрутизаторы и т. п.);
Существует много различных реализаций, не всегда корректно взаимодействующих друг с другом.
SSH
Преимущества:
Позволяет создать туннель для приложений, использующих TCP/IP, таких как электронная почта, инструменты программирования и т. д.;
Слой безопасности невидим для пользователя.
Недостатки:
Трудность использования в сетях с большим числом шлюзов, таких как маршрутизаторы или брандмауэры;
Большая нагрузка на внутрисетевой трафик;
Невозможность использования с протоколами UDP и ICMP.
Не имеет PKI (PKI, основанная на DNSSEC, малораспространена).

См. также
SSL
Server Name Indication (SNI)
JSSE
STARTTLS

Примечания
Ссылки
Transport Layer Security (tls) — Documents (англ.). Дата обращения 18 февраля 2011. Архивировано 9 февраля 2012 года.
Александр Венедюхин, Ключи, шифры, сообщения: как работает TLS (Техническое описание TLS), 04/09/2015
What is TLS/SSL?: Logon and Authentication (англ.)
How TLS/SSL Works: Logon and Authentication (англ.)