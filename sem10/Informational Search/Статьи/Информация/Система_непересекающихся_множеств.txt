Система непересекающихся множеств (англ. disjoint-set, или union–find data structure) — структура данных, которая позволяет администрировать множество элементов, разбитое на непересекающиеся подмножества. При этом каждому подмножеству назначается его представитель — элемент этого подмножества. Абстрактная структура данных определяется множеством трёх операций: 
  
    
      
        {
        
          U
          n
          i
          o
          n
        
        ,
        
          F
          i
          n
          d
        
        ,
        
          M
          a
          k
          e
          S
          e
          t
        
        }
      
    
    {\displaystyle \{\mathrm {Union} ,\mathrm {Find} ,\mathrm {MakeSet} \}}
  .
Применяется для хранения компонент связности в графах, в частности, алгоритму Краскала необходима подобная структура данных для эффективной реализации.

Определение
Пусть 
  
    
      
        S
      
    
    {\displaystyle S}
   конечное множество, разбитое на непересекающиеся подмножества (классы) 
  
    
      
        
          X
          
            i
          
        
      
    
    {\displaystyle X_{i}}
  :

  
    
      
        S
        =
        
          X
          
            0
          
        
        ∪
        
          X
          
            1
          
        
        ∪
        
          X
          
            2
          
        
        ∪
        …
        ∪
        
          X
          
            k
          
        
        :
        
          X
          
            i
          
        
        ∩
        
          X
          
            j
          
        
        =
        ∅
        
        ∀
        i
        ,
        j
        ∈
        {
        0
        ,
        1
        ,
        …
        ,
        k
        }
        ,
        i
        ≠
        j
      
    
    {\displaystyle S=X_{0}\cup X_{1}\cup X_{2}\cup \ldots \cup X_{k}:X_{i}\cap X_{j}=\varnothing \quad \forall i,j\in \lbrace 0,1,\ldots ,k\rbrace ,i\neq j}
  .Каждому подмножеству 
  
    
      
        
          X
          
            i
          
        
      
    
    {\displaystyle X_{i}}
   назначается представитель 
  
    
      
        
          r
          
            i
          
        
        ∈
        
          X
          
            i
          
        
      
    
    {\displaystyle r_{i}\in X_{i}}
  .
Соответствующая система непересекающихся множеств поддерживает следующие операции:

  
    
      
        
          M
          a
          k
          e
          S
          e
          t
        
        (
        x
        )
      
    
    {\displaystyle \mathrm {MakeSet} (x)}
  : создаёт для элемента 
  
    
      
        x
      
    
    {\displaystyle x}
   новое подмножество. Назначает этот же элемент представителем созданного подмножества.

  
    
      
        
          U
          n
          i
          o
          n
        
        (
        r
        ,
        s
        )
      
    
    {\displaystyle \mathrm {Union} (r,s)}
  : объединяет оба подмножества, принадлежащие представителям 
  
    
      
        r
      
    
    {\displaystyle r}
   и 
  
    
      
        s
      
    
    {\displaystyle s}
  , и назначает 
  
    
      
        r
      
    
    {\displaystyle r}
   представителем нового подмножества.

  
    
      
        
          F
          i
          n
          d
        
        (
        x
        )
      
    
    {\displaystyle \mathrm {Find} (x)}
  : определяет для 
  
    
      
        x
        ∈
        S
      
    
    {\displaystyle x\in S}
   подмножество, к которому принадлежит элемент, и возвращает его представителя.

Алгоритмическая реализация
Тривиальная реализация сохраняет принадлежность элементов из 
  
    
      
        S
      
    
    {\displaystyle S}
   и представителей 
  
    
      
        
          r
          
            i
          
        
      
    
    {\displaystyle r_{i}}
   в индексном массиве. На практике же чаще используются множества деревьев. Это позволяет существенно сократить время, необходимое для операции Find. При этом представитель записывается в корень дерева, а остальные элементы класса в узлы под ним.

  
    
      
        
          U
          n
          i
          o
          n
        
        (
        r
        ,
        s
        )
      
    
    {\displaystyle \mathrm {Union} (r,s)}
  : вешает корень более низкого дерева под корень более высокого дерева. Если при этом 
  
    
      
        r
      
    
    {\displaystyle r}
   становится потомком 
  
    
      
        s
      
    
    {\displaystyle s}
  , оба узла меняются местами.

  
    
      
        
          F
          i
          n
          d
        
        (
        x
        )
      
    
    {\displaystyle \mathrm {Find} (x)}
  : проходит путь от 
  
    
      
        x
      
    
    {\displaystyle x}
   до корня дерева и возвращает его (корень в данном случае является представителем).

Эвристики
Для ускорения операций Union и Find могут быть использованы эвристики Union-By-Size, Union-By-Height, Random-Union и сжатие путей.
В эвристике Union-By-Size во время операции 
  
    
      
        
          U
          n
          i
          o
          n
        
        (
        r
        ,
        s
        )
      
    
    {\displaystyle \mathrm {Union} (r,s)}
   корень меньшего дерева вешается под корень большего дерева. Благодаря этому подходу сохраняется балансировка дерева. Глубина каждого поддерева 
  
    
      
        T
      
    
    {\displaystyle T}
   не может превысить величину 
  
    
      
        log
        ⁡
        
          |
          T
          |
        
      
    
    {\displaystyle \log \left|T\right|}
  . При использовании этой эвристики время операции Find в худшем случае уменьшается с 
  
    
      
        O
        (
        log
        ⁡
        n
        )
      
    
    {\displaystyle O(\log n)}
   до 
  
    
      
        O
        (
        n
        )
      
    
    {\displaystyle O(n)}
  . Для эффективной реализации предлагается сохранять в корне количество узлов в дереве.
Эвристика Union-By-Height аналогична Union-By-Size, но использует высоту дерева вместо размера.
В эвристике Random-Union используется тот факт, что можно не тратить дополнительные 
  
    
      
        O
        (
        n
        )
      
    
    {\displaystyle O(n)}
   памяти на сохранение количества узлов в дереве: достаточно выбирать корень случайным образом — такое решение даёт на случайных запросах скорость, вполне сравнимую с другими реализациями. Тем не менее, если имеется много запросов вида «объединить большое множество с маленьким», данная эвристика улучшает матожидание (то есть среднее время работы) всего в два раза, поэтому использовать её без эвристики сжатия путей не рекомендуется.
Эвристика сжатия путей используется, чтобы ускорить операцию 
  
    
      
        
          F
          i
          n
          d
        
        (
        x
        )
      
    
    {\displaystyle \mathrm {Find} (x)}
  . При каждом новом поиске все элементы, находящиеся на пути от корня до искомого элемента, вешаются под корень дерева. В этом случае операция Find будет работать в среднем 
  
    
      
        α
        (
        n
        )
      
    
    {\displaystyle \alpha (n)}
  , где 
  
    
      
        α
      
    
    {\displaystyle \alpha }
   — функция, обратная функции Аккермана. Это позволяет значительно ускорить работу, так как 
  
    
      
        α
      
    
    {\displaystyle \alpha }
   для всех применяемых на практике значений принимает значение, меньшее 5.

Пример реализации
Реализация на C++:

Реализация на Free Pascal:

См. также
Лес непересекающихся множеств

Литература
Galler, Bernard A., and Michael J. Fisher. «An improved equivalence algorithm.» // Communications of the ACM, 7.5 (1964): 301—303. (англ.)
Tarjan, Robert E., and Jan Van Leeuwen. «Worst-case analysis of set union algorithms.» // Journal of the ACM 31.2 (1984): 245—281. (англ.)
Томас Кормен и др. Алгоритмы: построение и анализ = Introduction to Algorithms. — 2-е изд. — М.: «Вильямс», 2006. — С. 1296. — ISBN 0-07-013151-1.

Ссылки
Union-Find / Kevin Wayne, Pearson-Addison Wesley (англ.)
Chapter 22: Data Structures For Disjoint Sets / Introduction to Algorithms, Thomas H. Cormen, Charles E. Leiserson, and Ronald L. Rivest (англ.)
Визуализатор работы некоторых структур данных для непересекающихся множеств / ИТМО
Реализация непересекающихся множеств в коллекции библиотек C++ Boost, 2006