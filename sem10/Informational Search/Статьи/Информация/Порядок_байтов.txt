В современной вычислительной технике и цифровых системах связи информация обычно представлена в виде последовательности байтов. В том случае, если число не может быть представлено одним байтом, имеет значение, в каком порядке байты записываются в памяти компьютера или передаются по линиям связи. Часто выбор порядка записи байтов произволен и определяется только соглашениями.
В общем случае, для представления числа M, большего 255 (здесь 
  
    
      
        255
        =
        
          2
          
            8
          
        
        −
        1
      
    
    {\displaystyle 255=2^{8}-1}
   — максимальное целое число, записываемое одним байтом), приходится использовать несколько байтов. При этом число M записывается в позиционной системе счисления по основанию 256:

  
    
      
        M
        =
        
          ∑
          
            i
            =
            0
          
          
            n
          
        
        
          A
          
            i
          
        
        ⋅
        
          256
          
            i
          
        
        =
        
          A
          
            0
          
        
        ⋅
        
          256
          
            0
          
        
        +
        
          A
          
            1
          
        
        ⋅
        
          256
          
            1
          
        
        +
        
          A
          
            2
          
        
        ⋅
        
          256
          
            2
          
        
        +
        ⋯
        +
        
          A
          
            n
          
        
        ⋅
        
          256
          
            n
          
        
        .
      
    
    {\displaystyle M=\sum _{i=0}^{n}A_{i}\cdot 256^{i}=A_{0}\cdot 256^{0}+A_{1}\cdot 256^{1}+A_{2}\cdot 256^{2}+\dots +A_{n}\cdot 256^{n}.}
  Набор целых чисел 
  
    
      
        
          A
          
            0
          
        
        ,
        …
        ,
        
          A
          
            n
          
        
      
    
    {\displaystyle A_{0},\dots ,A_{n}}
  , каждое из которых лежит в интервале от 0 до 255, является последовательностью байтов, составляющих M. При этом 
  
    
      
        
          A
          
            0
          
        
      
    
    {\displaystyle A_{0}}
   называется младшим байтом, а 
  
    
      
        
          A
          
            n
          
        
      
    
    {\displaystyle A_{n}}
   — старшим байтом числа M.
Поскольку компьютер не адресует отдельных битов (их можно получать только через битовые поля), порядок битов в байте важен только при физической организации хранения и передачи данных, может отличаться от устройства к устройству и прикладному программисту обычно не нужен.

Варианты записи
Порядок от старшего к младшему
Порядок от старшего к младшему (англ. big-endian — большим концом): 
  
    
      
        
          A
          
            n
          
        
        ,
        …
        ,
        
          A
          
            0
          
        
      
    
    {\displaystyle A_{n},\dots ,A_{0}}
  . Этот порядок соответствует привычному порядку записи арабских цифр, например, число сто двадцать три было бы записано при таком порядке как 123. В этом же порядке принято записывать байты в технической и учебной литературе, если другой порядок явно не обозначен.
Этот порядок является стандартным для протоколов TCP/IP, он используется в заголовках пакетов данных и во многих протоколах более высокого уровня, разработанных для использования поверх TCP/IP. Поэтому порядок байтов от старшего к младшему часто называют «сетевым порядком байтов» (англ. network byte order). Этот порядок байтов используется процессорами IBM 360/370/390, SPARC, Motorola 68000 (отсюда третье название — порядок байтов Motorola, англ. Motorola byte order).
При таком порядке байтов удобно проводить сравнение строк (можно сравнивать их целочисленными большей разрядности, каждое из которых содержит несколько символов сразу).
Порядок байтов от старшего к младшему применяется также во многих форматах файлов — например, PNG, FLV, EBML, JPEG.

Порядок от младшего к старшему
Порядок от младшего к старшему (англ. little-endian — малым концом): 
  
    
      
        
          A
          
            0
          
        
        ,
        …
        ,
        
          A
          
            n
          
        
      
    
    {\displaystyle A_{0},\dots ,A_{n}}
  
Это обратный порядок по отношению к привычному порядку записи арабских цифр, например, число сто двадцать три было бы записано при таком порядке как 321.
Этот порядок записи принят в памяти персональных компьютеров с процессорами архитектуры x86, в связи с чем иногда его называют интеловский порядок байтов (по названию компании-создателя архитектуры x86). Современные процессоры x86 позволяют работать с одно-, двух-, четырёх- и восьмибайтовыми операндами. При таком порядке байтов очень удобно то обстоятельство, что при увеличении размера («байтовости») операнда его значение не изменится (при порядке от старшего к младшему значение изменилось бы, например: 0123 → 0123’0000; а при порядке от младшего к старшему значение остаётся прежним: 3210 → 3210’0000).
Кроме x86, такой порядок байтов применяется в архитектурах VAX (отсюда ещё одно название англ. VAX byte order), DEC Alpha и многих других.
Также порядок от младшего к старшему применяется в USB, PCI, таблице разделов GUID, он рекомендован FidoNet. Но в целом соглашение little-endian поддерживают меньше кросс-платформенных протоколов и форматов данных, чем big-endian.

Переключаемый порядок
Многие процессоры могут работать и в порядке от младшего к старшему, и в обратном, например, ARM (по умолчанию — little endian), PowerPC (но не PowerPC 970), DEC Alpha, MIPS, PA-RISC и IA-64. Обычно порядок байтов выбирается программно во время инициализации операционной системы, но может быть выбран и аппаратно перемычками на материнской плате. В этом случае правильнее говорить о порядке байтов операционной системы. Переключаемый порядок байтов иногда называют англ. bi-endian.

Смешанный порядок
Смешанный порядок байтов (англ. middle-endian) иногда используется при работе с числами, длина которых превышает машинное слово. Число представляется последовательностью машинных слов, которые записываются в формате, естественном для данной архитектуры, но сами слова следуют в обратном порядке.
В процессорах VAX и ARM используется смешанное представление для длинных вещественных чисел.

Пример
Далее приведён пример, в котором описывается размещение 4-байтового числа в ОЗУ ЭВМ, доступ к которому может производиться и как к 32-разрядному слову, и побайтно.
Все числа записаны в 16-ричной системе счисления.

Определение порядка байтов
Порядок байтов в конкретной машине можно определить с помощью программы на языке Си (testbyteorder.c):

Результаты запуска на big-endian машине (SPARC):

Результаты запуска на little-endian машине (x86):

Вещественные числа
Хранение вещественных чисел может зависеть от порядка байт; так, на x86 используются форматы IEEE 754 со знаком и порядком числа в старших байтах.

Юникод
Если Юникод записан в виде UTF-16 или UTF-32, то порядок байтов является существенным. Одним из способов обозначения порядка байтов в юникодовых текстах является постановка в начале специального символа BOM (byte order mark, маркер последовательности байтов, U+FEFF) — «перевёрнутый» вариант этого символа (U+FFFE) не существует и не допускается в текстах.
Символ U+FEFF изображается в UTF-16 последовательностью байтов 0xFE 0xFF (big-endian) или 0xFF 0xFE (little-endian), а в UTF-32 — последовательностью 0x00 0x00 0xFE 0xFF (big-endian) или 0xFF 0xFE 0x00 0x00 (little-endian).

Проблемы совместимости и конвертация
Запись многобайтового числа из памяти компьютера в файл или передача по сети требует соблюдения соглашений о том, какой из байтов передается первым. Прямая запись в том порядке, в котором байты расположены в ячейках памяти, приводит к проблемам при переносе приложения с платформы на платформу.
Для преобразования между сетевым порядком байтов (англ. network byte order), который всегда big-endian, и порядком байтов, использующимся на машине (англ. host byte order), стандарт POSIX предусматривает функции htonl(), htons(), ntohl(), ntohs():

uint32_t htonl(uint32_t hostlong); — конвертирует 32-битную беззнаковую величину из локального порядка байтов в сетевой;
uint16_t htons(uint16_t hostshort); — конвертирует 16-битную беззнаковую величину из локального порядка байтов в сетевой;
uint32_t ntohl(uint32_t netlong); — конвертирует 32-битную беззнаковую величину из сетевого порядка байтов в локальный;
uint16_t ntohs(uint16_t netshort); — конвертирует 16-битную беззнаковую величину из сетевого порядка байтов в локальный.В случае совпадения текущего порядка байтов и сетевого функции могут быть «пустыми» (то есть, не менять порядка байтов). Стандарт также допускает, чтобы эти функции были реализованы макросами.
Существует много языков и библиотек со средствами конвертации в оба основных порядка байт и обратно.
Ядро Linux: le16_to_cpu(), cpu_to_be32(), cpu_to_le16p(), и так далее;
Ядро FreeBSD: htobe16(), le32toh(), и так далее;
Erlang:

Python:

Perl:

данные примеры для Erlang, Python, Perl содержат идентичную функциональность.
Процессоры Intel x86-64 имеют инструкцию BSWAP для смены порядка байт.

Этимология названия
Термины big-endian и little-endian первоначально не имели отношения к информатике. В сатирическом произведении Джонатана Свифта «Путешествия Гулливера» описываются вымышленные государства Лилипутия и Блефуску, в течение многих лет ведущие между собой войны из-за разногласия по поводу того, с какого конца следует разбивать варёные яйца. Тех, кто считает, что их нужно разбивать с тупого конца, в произведении называют Big-endians («тупоконечники»).
Споры между сторонниками big-endian и little-endian в информатике также часто носят характер т. н. «религиозных войн». Термины big-endian и little-endian ввёл Коэн (англ. Danny Cohen) в 1980 году в своей статье «On Holy Wars and a Plea for Peace» («О священных войнах и призыв к миру»).

См. также
Компьютерная сеть

Примечания
Ссылки
Сетевой порядок байтов, функции htons(), htonl(), ntohs(), ntohl()
Порядок байтов
Порядок байтов