Обнаруже́ние оши́бок в технике связи — действие, направленное на контроль целостности данных при записи/воспроизведении информации или при её передаче по линиям связи. Исправление ошибок (коррекция ошибок) — процедура восстановления информации после чтения её из устройства хранения или канала связи.
Для обнаружения ошибок используют коды обнаружения ошибок, для исправления — корректирующие коды (коды, исправляющие ошибки, коды с коррекцией ошибок, помехоустойчивые коды).

Способы борьбы с ошибками
В процессе хранения данных и передачи информации по сетям связи неизбежно возникают ошибки. Контроль целостности данных и исправление ошибок — важные задачи на многих уровнях работы с информацией (в частности, физическом, канальном, транспортном уровнях сетевой модели OSI).
В системах связи возможны несколько стратегий борьбы с ошибками:

обнаружение ошибок в блоках данных и автоматический запрос повторной передачи повреждённых блоков — этот подход применяется, в основном, на канальном и транспортном уровнях;
обнаружение ошибок в блоках данных и отбрасывание повреждённых блоков — такой подход иногда применяется в системах потокового мультимедиа, где важна задержка передачи и нет времени на повторную передачу;
исправление ошибок (англ. forward error correction) применяется на физическом уровне.

Коды обнаружения и исправления ошибок
Корректирующие коды — коды, служащие для обнаружения или исправления ошибок, возникающих при передаче информации под влиянием помех, а также при её хранении.
Для этого при записи (передаче) в полезные данные добавляют специальным образом структурированную избыточную информацию (контрольное число), а при чтении (приёме) её используют для того, чтобы обнаружить или исправить ошибки. Естественно, что число ошибок, которое можно исправить, ограничено и зависит от конкретного применяемого кода.
С кодами, исправляющими ошибки, тесно связаны коды обнаружения ошибок. В отличие от первых, последние могут только установить факт наличия ошибки в переданных данных, но не исправить её.
В действительности используемые коды обнаружения ошибок принадлежат к тем же классам кодов, что и коды, исправляющие ошибки. Фактически любой код, исправляющий ошибки, может быть также использован для обнаружения ошибок (при этом он будет способен обнаружить большее число ошибок, чем был способен исправить).
По способу работы с данными коды, исправляющие ошибки, делятся на блоковые, делящие информацию на фрагменты постоянной длины и обрабатывающие каждый из них в отдельности, и свёрточные, работающие с данными как с непрерывным потоком.

Блоковые коды
Пусть кодируемая информация делится на фрагменты длиной 
  
    
      
        k
      
    
    {\displaystyle k}
   бит, которые преобразуются в кодовые слова длиной 
  
    
      
        n
      
    
    {\displaystyle n}
   бит. Тогда соответствующий блоковый код обычно обозначают 
  
    
      
        (
        n
        ,
        
        k
        )
      
    
    {\displaystyle (n,\;k)}
  . При этом число 
  
    
      
        R
        =
        
          
            k
            n
          
        
      
    
    {\displaystyle R={\frac {k}{n}}}
   называется скоростью кода.
Если исходные 
  
    
      
        k
      
    
    {\displaystyle k}
   бит код оставляет неизменными, и добавляет 
  
    
      
        n
        −
        k
      
    
    {\displaystyle n-k}
   проверочных, такой код называется систематическим, иначе — несистематическим.
Задать блоковый код можно по-разному, в том числе таблицей, где каждой совокупности из 
  
    
      
        k
      
    
    {\displaystyle k}
   информационных бит сопоставляется 
  
    
      
        n
      
    
    {\displaystyle n}
   бит кодового слова. Однако хороший код должен удовлетворять как минимум следующим критериям:

способность исправлять как можно большее число ошибок,
как можно меньшая избыточность,
простота кодирования и декодирования.Нетрудно видеть, что приведённые требования противоречат друг другу. Именно поэтому существует большое количество кодов, каждый из которых пригоден для своего круга задач.
Практически все используемые коды являются линейными. Это связано с тем, что нелинейные коды значительно сложнее исследовать, и для них трудно обеспечить приемлемую лёгкость кодирования и декодирования.

Линейные коды общего вида
Линейный блоковый код — такой код, что множество его кодовых слов образует 
  
    
      
        k
      
    
    {\displaystyle k}
  -мерное линейное подпространство (назовём его 
  
    
      
        C
      
    
    {\displaystyle C}
  ) в 
  
    
      
        n
      
    
    {\displaystyle n}
  -мерном линейном пространстве, изоморфное пространству 
  
    
      
        k
      
    
    {\displaystyle k}
  -битных векторов.
Это значит, что операция кодирования соответствует умножению исходного 
  
    
      
        k
      
    
    {\displaystyle k}
  -битного вектора на невырожденную матрицу 
  
    
      
        G
      
    
    {\displaystyle G}
  , называемую порождающей матрицей.
Пусть 
  
    
      
        
          C
          
            ⊥
          
        
      
    
    {\displaystyle C^{\perp }}
   — ортогональное подпространство по отношению к 
  
    
      
        C
      
    
    {\displaystyle C}
  , а 
  
    
      
        H
      
    
    {\displaystyle H}
   — матрица, задающая базис этого подпространства. Тогда для любого вектора 
  
    
      
        
          
            v
            →
          
        
        ∈
        C
      
    
    {\displaystyle {\overrightarrow {v}}\in C}
   справедливо:

  
    
      
        
          
            v
            →
          
        
        
          H
          
            T
          
        
        =
        
          
            0
            →
          
        
        .
      
    
    {\displaystyle {\overrightarrow {v}}H^{T}={\overrightarrow {0}}.}

Минимальное расстояние и корректирующая способность
Расстоянием Хемминга (метрикой Хемминга) между двумя кодовыми словами 
  
    
      
        
          
            u
            →
          
        
      
    
    {\displaystyle {\overrightarrow {u}}}
   и 
  
    
      
        
          
            v
            →
          
        
      
    
    {\displaystyle {\overrightarrow {v}}}
   называется количество отличных бит на соответствующих позициях:

  
    
      
        
          d
          
            H
          
        
        (
        
          
            u
            →
          
        
        ,
        
        
          
            v
            →
          
        
        )
        =
        
          ∑
          
            s
          
        
        
          
            |
          
          
            u
            
              (
              s
              )
            
          
          −
          
            v
            
              (
              s
              )
            
          
          
            |
          
        
      
    
    {\displaystyle d_{H}({\overrightarrow {u}},\;{\overrightarrow {v}})=\sum _{s}{|u^{(s)}-v^{(s)}|}}
  .Минимальное расстояние Хемминга 
  
    
      
        
          d
          
            min
          
        
        =
        
          min
          
            u
            ≠
            v
          
        
        
          d
          
            H
          
        
        (
        
          
            u
            →
          
        
        ,
        
        
          
            v
            →
          
        
        )
      
    
    {\displaystyle d_{\min }=\min _{u\neq v}d_{H}({\overrightarrow {u}},\;{\overrightarrow {v}})}
   является важной характеристикой линейного блокового кода. Она показывает, насколько «далеко» расположены коды друг от друга. Она определяет другую, не менее важную характеристику — корректирующую способность:

  
    
      
        t
        =
        
          ⌊
          
            
              
                
                  d
                  
                    min
                  
                
                −
                1
              
              2
            
          
          ⌋
        
      
    
    {\displaystyle t=\left\lfloor {\frac {d_{\min }-1}{2}}\right\rfloor }
  .Корректирующая способность определяет, сколько ошибок передачи кода (типа 
  
    
      
        1
        ↔
        0
      
    
    {\displaystyle 1\leftrightarrow 0}
  ) можно гарантированно исправить. То есть вокруг каждого кодового слова 
  
    
      
        A
      
    
    {\displaystyle A}
   имеем 
  
    
      
        t
      
    
    {\displaystyle t}
  -окрестность 
  
    
      
        
          A
          
            t
          
        
      
    
    {\displaystyle A_{t}}
  , которая состоит из всех возможных вариантов передачи кодового слова 
  
    
      
        A
      
    
    {\displaystyle A}
   с числом ошибок (
  
    
      
        1
        ↔
        0
      
    
    {\displaystyle 1\leftrightarrow 0}
  ) не более 
  
    
      
        t
      
    
    {\displaystyle t}
  . Никакие две окрестности двух любых кодовых слов не пересекаются друг с другом, так как расстояние между кодовыми словами (то есть центрами этих окрестностей) всегда больше двух их радиусов 
  
    
      
        
          d
          
            H
          
        
        (
        A
        ,
        
        B
        )
        ⩾
        
          d
          
            min
          
        
        >
        2
        t
      
    
    {\displaystyle d_{H}(A,\;B)\geqslant d_{\min }>2t}
  .
Таким образом, получив искажённую кодовую комбинацию из 
  
    
      
        
          A
          
            t
          
        
      
    
    {\displaystyle A_{t}}
  , декодер принимает решение, что исходной была кодовая комбинация 
  
    
      
        A
      
    
    {\displaystyle A}
  , исправляя тем самым не более 
  
    
      
        t
      
    
    {\displaystyle t}
   ошибок.
Поясним на примере. Предположим, что есть два кодовых слова 
  
    
      
        A
      
    
    {\displaystyle A}
   и 
  
    
      
        B
      
    
    {\displaystyle B}
  , расстояние Хемминга между ними равно 3. Если было передано слово 
  
    
      
        A
      
    
    {\displaystyle A}
  , и канал внёс ошибку в одном бите, она может быть исправлена, так как даже в этом случае принятое слово ближе к кодовому слову 
  
    
      
        A
      
    
    {\displaystyle A}
  , чем к любому другому, и, в частности, к 
  
    
      
        B
      
    
    {\displaystyle B}
  . Но если каналом были внесены ошибки в двух битах (в которых 
  
    
      
        A
      
    
    {\displaystyle A}
   отличалось от 
  
    
      
        B
      
    
    {\displaystyle B}
  ), то результат ошибочной передачи 
  
    
      
        A
      
    
    {\displaystyle A}
   окажется ближе к 
  
    
      
        B
      
    
    {\displaystyle B}
  , чем 
  
    
      
        A
      
    
    {\displaystyle A}
  , и декодер примет решение, что передавалось слово 
  
    
      
        B
      
    
    {\displaystyle B}
  .

Коды Хемминга
Коды Хемминга — простейшие линейные коды с минимальным расстоянием 3, то есть способные исправить одну ошибку. Код Хемминга может быть представлен в таком виде, что синдром

  
    
      
        
          
            s
            →
          
        
        =
        
          
            r
            →
          
        
        
          H
          
            T
          
        
      
    
    {\displaystyle {\overrightarrow {s}}={\overrightarrow {r}}H^{T}}
  , где 
  
    
      
        
          
            r
            →
          
        
      
    
    {\displaystyle {\overrightarrow {r}}}
   — принятый вектор, будет равен номеру позиции, в которой произошла ошибка. Это свойство позволяет сделать декодирование очень простым.

Общий метод декодирования линейных кодов
Любой код (в том числе нелинейный) можно декодировать с помощью обычной таблицы, где каждому значению принятого слова 
  
    
      
        
          
            
              r
              →
            
          
          
            i
          
        
      
    
    {\displaystyle {\overrightarrow {r}}_{i}}
   соответствует наиболее вероятное переданное слово 
  
    
      
        
          
            
              u
              →
            
          
          
            i
          
        
      
    
    {\displaystyle {\overrightarrow {u}}_{i}}
  . Однако данный метод требует применения огромных таблиц уже для кодовых слов сравнительно небольшой длины.
Для линейных кодов этот метод можно существенно упростить. При этом для каждого принятого вектора 
  
    
      
        
          
            
              r
              →
            
          
          
            i
          
        
      
    
    {\displaystyle {\overrightarrow {r}}_{i}}
   вычисляется синдром 
  
    
      
        
          
            
              s
              →
            
          
          
            i
          
        
        =
        
          
            
              r
              →
            
          
          
            i
          
        
        
          H
          
            T
          
        
      
    
    {\displaystyle {\overrightarrow {s}}_{i}={\overrightarrow {r}}_{i}H^{T}}
  . Поскольку 
  
    
      
        
          
            
              r
              →
            
          
          
            i
          
        
        =
        
          
            
              v
              →
            
          
          
            i
          
        
        +
        
          
            
              e
              →
            
          
          
            i
          
        
      
    
    {\displaystyle {\overrightarrow {r}}_{i}={\overrightarrow {v}}_{i}+{\overrightarrow {e}}_{i}}
  , где 
  
    
      
        
          
            
              v
              →
            
          
          
            i
          
        
      
    
    {\displaystyle {\overrightarrow {v}}_{i}}
   — кодовое слово, а 
  
    
      
        
          
            
              e
              →
            
          
          
            i
          
        
      
    
    {\displaystyle {\overrightarrow {e}}_{i}}
   — вектор ошибки, то 
  
    
      
        
          
            
              s
              →
            
          
          
            i
          
        
        =
        
          
            
              e
              →
            
          
          
            i
          
        
        
          H
          
            T
          
        
      
    
    {\displaystyle {\overrightarrow {s}}_{i}={\overrightarrow {e}}_{i}H^{T}}
  . Затем с помощью таблицы по синдрому определяется вектор ошибки, с помощью которого определяется переданное кодовое слово. При этом таблица получается гораздо меньше, чем при использовании предыдущего метода.

Линейные циклические коды
Несмотря на то, что декодирование линейных кодов значительно проще декодирования большинства нелинейных, для большинства кодов этот процесс всё ещё достаточно сложен. Циклические коды, кроме более простого декодирования, обладают и другими важными свойствами.
Циклическим кодом является линейный код, обладающий следующим свойством: если 
  
    
      
        
          
            v
            →
          
        
      
    
    {\displaystyle {\overrightarrow {v}}}
   является кодовым словом, то его циклическая перестановка также является кодовым словом.
Слова циклического кода удобно представлять в виде многочленов. Например, кодовое слово 
  
    
      
        
          
            v
            →
          
        
        =
        (
        
          v
          
            0
          
        
        ,
        
        
          v
          
            1
          
        
        ,
        
        …
        ,
        
        
          v
          
            n
            −
            1
          
        
        )
      
    
    {\displaystyle {\overrightarrow {v}}=(v_{0},\;v_{1},\;\ldots ,\;v_{n-1})}
   представляется в виде полинома 
  
    
      
        v
        (
        x
        )
        =
        
          v
          
            0
          
        
        +
        
          v
          
            1
          
        
        x
        +
        …
        +
        
          v
          
            n
            −
            1
          
        
        
          x
          
            n
            −
            1
          
        
      
    
    {\displaystyle v(x)=v_{0}+v_{1}x+\ldots +v_{n-1}x^{n-1}}
  . При этом циклический сдвиг кодового слова эквивалентен умножению многочлена на 
  
    
      
        x
      
    
    {\displaystyle x}
   по модулю 
  
    
      
        
          x
          
            n
          
        
        −
        1
      
    
    {\displaystyle x^{n}-1}
  .
В дальнейшем, если не указано иное, мы будем считать, что циклический код является двоичным, то есть 
  
    
      
        
          v
          
            0
          
        
        ,
        
        
          v
          
            1
          
        
        ,
        
        …
      
    
    {\displaystyle v_{0},\;v_{1},\;\ldots }
   могут принимать значения 0 или 1.

Порождающий (генераторный) полином
Можно показать, что все кодовые слова конкретного циклического кода кратны определённому порождающему полиному 
  
    
      
        g
        (
        x
        )
      
    
    {\displaystyle g(x)}
  . Порождающий полином является делителем 
  
    
      
        
          x
          
            n
          
        
        −
        1
      
    
    {\displaystyle x^{n}-1}
  .
С помощью порождающего полинома осуществляется кодирование циклическим кодом. В частности:

несистематическое кодирование осуществляется путём умножения кодируемого вектора на 
  
    
      
        g
        (
        x
        )
      
    
    {\displaystyle g(x)}
  : 
  
    
      
        v
        (
        x
        )
        =
        u
        (
        x
        )
        g
        (
        x
        )
      
    
    {\displaystyle v(x)=u(x)g(x)}
  ;
систематическое кодирование осуществляется путём «дописывания» к кодируемому слову остатка от деления 
  
    
      
        
          x
          
            n
            −
            k
          
        
        u
        (
        x
        )
      
    
    {\displaystyle x^{n-k}u(x)}
   на 
  
    
      
        g
        (
        x
        )
      
    
    {\displaystyle g(x)}
  , то есть 
  
    
      
        v
        (
        x
        )
        =
        
          x
          
            n
            −
            k
          
        
        u
        (
        x
        )
        +
        [
        
          x
          
            n
            −
            k
          
        
        u
        (
        x
        )
        
        
          mod
          
            
          
        
        g
        (
        x
        )
        ]
      
    
    {\displaystyle v(x)=x^{n-k}u(x)+[x^{n-k}u(x)\,{\bmod {\,}}g(x)]}
  .

Коды CRC
Коды CRC (англ. cyclic redundancy check — циклическая избыточная проверка) являются систематическими кодами, предназначенными не для исправления ошибок, а для их обнаружения. Они используют способ систематического кодирования, изложенный выше: «контрольная сумма» вычисляется путём деления 
  
    
      
        
          x
          
            n
            −
            k
          
        
        u
        (
        x
        )
      
    
    {\displaystyle x^{n-k}u(x)}
   на 
  
    
      
        g
        (
        x
        )
      
    
    {\displaystyle g(x)}
  . Ввиду того, что исправление ошибок не требуется, проверка правильности передачи может производиться точно так же.
Таким образом, вид полинома 
  
    
      
        g
        (
        x
        )
      
    
    {\displaystyle g(x)}
   задаёт конкретный код CRC. Примеры наиболее популярных полиномов:

Коды БЧХ
Коды Боуза — Чоудхури — Хоквингема (БЧХ) являются подклассом циклических кодов. Их отличительное свойство — возможность построения кода БЧХ с минимальным расстоянием не меньше заданного. Это важно, потому что, вообще говоря, определение минимального расстояния кода есть очень сложная задача.

Коды коррекции ошибок Рида — Соломона
Коды Рида — Соломона — недвоичные циклические коды, позволяющие исправлять ошибки в блоках данных. Элементами кодового вектора являются не биты, а группы битов (блоки). Очень распространены коды Рида-Соломона, работающие с байтами (октетами).
Математически коды Рида — Соломона являются кодами БЧХ.

Преимущества и недостатки блоковых кодов
Хотя блоковые коды, как правило, хорошо справляются с редкими, но большими пачками ошибок, их эффективность при частых, но небольших ошибках (например, в канале с АБГШ), менее высока.

Свёрточные коды
Свёрточные коды, в отличие от блоковых, не делят информацию на фрагменты и работают с ней как со сплошным потоком данных.
Свёрточные коды, как правило, порождаются дискретной линейной инвариантной во времени системой. Поэтому, в отличие от большинства блоковых кодов, свёрточное кодирование — очень простая операция, чего нельзя сказать о декодировании.
Кодирование свёрточным кодом производится с помощью регистра сдвига, отводы от которого суммируются по модулю два. Таких сумм может быть две (чаще всего) или больше.
Декодирование свёрточных кодов, как правило, производится по алгоритму Витерби, который пытается восстановить переданную последовательность согласно критерию максимального правдоподобия.

Преимущества и недостатки свёрточных кодов
Свёрточные коды эффективно работают в канале с белым шумом, но плохо справляются с пакетами ошибок. Более того, если декодер ошибается, на его выходе всегда возникает пакет ошибок.

Каскадное кодирование. Итеративное декодирование
Преимущества разных способов кодирования можно объединить, применив каскадное кодирование. При этом информация сначала кодируется одним кодом, а затем другим, в результате получается код-произведение.
Например, популярной является следующая конструкция: данные кодируются кодом Рида-Соломона, затем перемежаются (при этом символы, расположенные близко, помещаются далеко друг от друга) и кодируются свёрточным кодом. На приёмнике сначала декодируется свёрточный код, затем осуществляется обратное перемежение (при этом пачки ошибок на выходе свёрточного декодера попадают в разные кодовые слова кода Рида — Соломона), и затем осуществляется декодирование кода Рида — Соломона.
Некоторые коды-произведения специально сконструированы для итеративного декодирования, при котором декодирование осуществляется в несколько проходов, каждый из которых использует информацию от предыдущего. Это позволяет добиться большой эффективности, однако декодирование требует больших ресурсов. К таким кодам относят турбо-коды и LDPC-коды (коды Галлагера).

Сетевое кодирование
Оценка эффективности кодов
Эффективность кодов определяется количеством ошибок, которые тот может исправить, количеством избыточной информации, добавление которой требуется, а также сложностью реализации кодирования и декодирования (как аппаратной, так и в виде программы для ЭВМ).

Граница Хемминга и совершенные коды
Пусть имеется двоичный блоковый 
  
    
      
        (
        n
        ,
        k
        )
      
    
    {\displaystyle (n,k)}
   код с корректирующей способностью 
  
    
      
        t
      
    
    {\displaystyle t}
  . Тогда справедливо неравенство (называемое границей Хемминга):

  
    
      
        
          ∑
          
            i
            =
            0
          
          
            t
          
        
        
          
            
              (
            
            
              n
              i
            
            
              )
            
          
        
        ⩽
        
          2
          
            n
            −
            k
          
        
        .
      
    
    {\displaystyle \sum _{i=0}^{t}{n \choose i}\leqslant 2^{n-k}.}
  Коды, удовлетворяющие этой границе с равенством, называются совершенными. К совершенным кодам относятся, например, коды Хемминга. Часто применяемые на практике коды с большой корректирующей способностью (такие, как коды Рида — Соломона) не являются совершенными.

Энергетический выигрыш
При передаче информации по каналу связи вероятность ошибки зависит от отношения сигнал/шум на входе демодулятора, таким образом, при постоянном уровне шума решающее значение имеет мощность передатчика. В системах спутниковой и мобильной, а также других типов связи остро стоит вопрос экономии энергии. Кроме того, в определённых системах связи (например, телефонной) неограниченно повышать мощность сигнала не дают технические ограничения.
Поскольку помехоустойчивое кодирование позволяет исправлять ошибки, при его применении мощность передатчика можно снизить, оставляя скорость передачи информации неизменной. Энергетический выигрыш определяется как разница отношений с/ш при наличии и отсутствии кодирования.

Применение кодов, исправляющих ошибки
Коды, исправляющие ошибки, применяются:

в системах цифровой связи, в том числе: спутниковой, радиорелейной, сотовой, передаче данных по телефонным каналам.
в системах хранения информации, в том числе магнитных и оптических.Коды, обнаруживающие ошибки, применяются в сетевых протоколах различных уровней.

Автоматический запрос повторной передачи
Системы с автоматическим запросом повторной передачи (ARQ — Automatic Repeat reQuest) основаны на технологии обнаружения ошибок. Распространены следующие методы автоматического запроса:

Запрос ARQ с остановками (stop-and-wait ARQ)
Идея этого метода заключается в том, что передатчик ожидает от приемника подтверждения успешного приема предыдущего блока данных перед тем, как начать передачу следующего. В случае, если блок данных был принят с ошибкой, приемник передает отрицательное подтверждение (negative acknowledgement, NAK), и передатчик повторяет передачу блока. Данный метод подходит для полудуплексного канала связи. Его недостатком является низкая скорость из-за высоких накладных расходов на ожидание.

Непрерывный запрос ARQ с возвратом (continuous ARQ with pullback)
Для этого метода необходим полнодуплексный канал. Передача данных от передатчика к приемнику производится одновременно. В случае ошибки передача возобновляется, начиная с ошибочного блока (то есть передается ошибочный блок и все последующие).

Непрерывный запрос ARQ с выборочным повторением (continuous ARQ with selective repeat)
При этом подходе осуществляется передача только ошибочно принятых блоков данных.

См. также
Цифровая связь
Код ответа (Код причины завершения)
Линейный код
Циклический код
Код Боуза — Чоудхури — Хоквингема
Код Рида — Соломона
LDPC
Свёрточный код
Турбо-код

Литература
Блейхут Р. Теория и практика кодов, контролирующих ошибки = Theory and Practice of Error Control Codes. — М.: Мир, 1986. — 576 с.
Мак-Вильямс Ф. Дж., Слоэн Н. Дж. А. Теория кодов, исправляющих ошибки. М.: Радио и связь, 1979.
Морелос-Сарагоса Р. Искусство помехоустойчивого кодирования. Методы, алгоритмы, применение / пер. с англ. В. Б. Афанасьева. — М.: Техносфера, 2006. — 320 с. — (Мир связи). — 2000 экз. — ISBN 5-94836-035-0.

Ссылки

Помехоустойчивое кодирование (неопр.) (11 ноября 2001). — реферат по проблеме кодирования сообщений с исправлением ошибок. Дата обращения 25 декабря 2006. Архивировано 25 августа 2011 года.
Коды Рида-Соломона. Простой пример. Просто, доступно, на конкретных числах. Для начинающих.