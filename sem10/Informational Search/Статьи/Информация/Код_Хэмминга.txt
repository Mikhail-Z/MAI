Код Хэ́мминга — вероятно, наиболее известный из первых самоконтролирующихся и самокорректирующихся кодов. Построен применительно к двоичной системе счисления. Позволяет исправлять одиночную ошибку (ошибка в одном бите) и находить двойную.
Названы в честь американского математика Ричарда Хэмминга, предложившего их.

История
В середине 1940-х годов в лаборатории фирмы Белл (Bell Labs) была создана счётная машина Bell Model V. Это была электромеханическая машина, использующая релейные блоки, скорость которых была очень низка: один оборот за несколько секунд. Данные вводились в машину с помощью перфокарт, поэтому в процессе чтения часто происходили ошибки. В рабочие дни использовались специальные коды, чтобы обнаруживать и исправлять найденные ошибки, при этом оператор узнавал об ошибке по свечению лампочек, исправлял и снова запускал машину. В выходные дни, когда не было операторов, при возникновении ошибки машина автоматически выходила из программы и запускала другую.
Хэмминг часто работал в выходные дни, и все больше и больше раздражался, потому что часто должен был перезагружать свою программу из-за ненадежности перфокарт. На протяжении нескольких лет он проводил много времени над построением эффективных алгоритмов исправления ошибок. В 1950 году он опубликовал способ, который известен как код Хэмминга.

Систематические коды
Систематические коды образуют большую группу из блочных, разделимых кодов (в которых все символы слова можно разделить на проверочные и информационные). Особенностью систематических кодов является то, что проверочные символы образуются в результате линейных операций над информационными символами. Кроме того, любая разрешенная кодовая комбинация может быть получена в результате линейных операций над набором линейно независимых кодовых комбинаций.

Самоконтролирующиеся коды
Коды Хэмминга являются самоконтролирующимися кодами, то есть кодами, позволяющими автоматически обнаруживать ошибки при передаче данных. Для их построения достаточно приписать к каждому слову один добавочный (контрольный) двоичный разряд и выбрать цифру этого разряда так, чтобы общее количество единиц в изображении любого числа было, например, нечетным. Одиночная ошибка в каком-либо разряде передаваемого слова (в том числе, может быть, и в контрольном разряде) изменит четность общего количества единиц. Счетчики по модулю 2, подсчитывающие количество единиц, которые содержатся среди двоичных цифр числа, могут давать сигнал о наличии ошибок.
При этом невозможно узнать, в каком именно разряде произошла ошибка, и, следовательно, нет возможности исправить её. Остаются незамеченными также ошибки, возникающие одновременно в двух, четырёх, и т. д. — в четном количестве разрядов. Впрочем, двойные, а тем более четырёхкратные ошибки полагаются маловероятными.

Самокорректирующиеся коды
Коды, в которых возможно автоматическое исправление ошибок, называются самокорректирующимися. Для построения самокорректирующегося кода, рассчитанного на исправление одиночных ошибок, одного контрольного разряда недостаточно. Как видно из дальнейшего, количество контрольных разрядов k должно быть выбрано так, чтобы удовлетворялось неравенство 
  
    
      
        
          2
          
            k
          
        
        ≥
        k
        +
        m
        +
        1
      
    
    {\displaystyle 2^{k}\geq k+m+1}
   или 
  
    
      
        k
        ≥
        
          log
          
            2
          
        
        ⁡
        (
        k
        +
        m
        +
        1
        )
      
    
    {\displaystyle k\geq \log _{2}(k+m+1)}
  , где m — количество основных двоичных разрядов кодового слова.
Минимальные значения k при заданных значениях m, найденные в соответствии с этим неравенством, приведены в таблице.

В настоящее время наибольший интерес представляют двоичные блочные корректирующие коды. При использовании таких кодов информация передаётся в виде блоков одинаковой длины и каждый блок кодируется и декодируется независимо друг от друга. Почти во всех блочных кодах символы можно разделить на информационные и проверочные. Таким образом, все комбинации кодов разделяются на разрешенные (для которых соотношение информационных и проверочных символов возможно) и запрещенные.
Основными характеристиками самокорректирующихся кодов являются:

Число разрешенных и запрещенных комбинаций. Если n — число символов в блоке, r — число проверочных символов в блоке, k — число информационных символов, то 
  
    
      
        
          2
          
            n
          
        
      
    
    {\displaystyle 2^{n}}
   — число возможных кодовых комбинаций, 
  
    
      
        
          2
          
            k
          
        
      
    
    {\displaystyle 2^{k}}
   — число разрешенных кодовых комбинаций, 
  
    
      
        
          2
          
            n
          
        
        −
        
          2
          
            k
          
        
      
    
    {\displaystyle 2^{n}-2^{k}}
   — число запрещенных комбинаций.
Избыточность кода. Величину 
  
    
      
        
          
            
              r
              n
            
          
        
      
    
    {\displaystyle {\tfrac {r}{n}}}
   называют избыточностью корректирующего кода.
Минимальное кодовое расстояние. Минимальным кодовым расстоянием d называется минимальное число искаженных символов, необходимое для перехода одной разрешенной комбинации в другую.
Число обнаруживаемых и исправляемых ошибок. Если g — количество ошибок, которое код способен исправить, то необходимо и достаточно, чтобы 
  
    
      
        d
        ≥
        2
        g
        +
        1
      
    
    {\displaystyle d\geq 2g+1}
  
Корректирующие возможности кодов.Граница Плоткина даёт верхнюю границу кодового расстояния

  
    
      
        d
        ⩽
        
          
            
              
                n
                ⋅
                
                  2
                  
                    k
                    −
                    1
                  
                
              
              
                
                  2
                  
                    k
                  
                
                −
                1
              
            
          
        
      
    
    {\displaystyle d\leqslant {\tfrac {n\cdot 2^{k-1}}{2^{k}-1}}}
  или

  
    
      
        r
        ≥
        2
        ⋅
        (
        d
        −
        1
        )
        −
        
          log
          
            2
          
        
        ⁡
        d
      
    
    {\displaystyle r\geq 2\cdot (d-1)-\log _{2}d}
  при 
  
    
      
        n
        ≥
        2
        ⋅
        d
        −
        1
      
    
    {\displaystyle n\geq 2\cdot d-1}
  
Граница Хемминга устанавливает максимально возможное число разрешенных кодовых комбинаций

  
    
      
        
          2
          
            k
          
        
        ≤
        
          
            2
            
              n
            
          
        
        
          /
        
        
          ∑
          
            i
            =
            0
          
          
            
              
                
                  d
                  −
                  1
                
                2
              
            
          
        
        
          C
          
            n
          
          
            i
          
        
      
    
    {\displaystyle 2^{k}\leq {2^{n}}/\sum _{i=0}^{\tfrac {d-1}{2}}C_{n}^{i}}
  где 
  
    
      
        
          C
          
            n
          
          
            i
          
        
      
    
    {\displaystyle C_{n}^{i}}
   — число сочетаний из n элементов по i элементам. Отсюда можно получить выражение для оценки числа проверочных символов: :
  
    
      
        r
        ≥
        l
        o
        
          g
          
            2
          
        
        (
        
          ∑
          
            i
            =
            0
          
          
            
              
                
                  d
                  −
                  1
                
                2
              
            
          
        
        
          C
          
            n
          
          
            i
          
        
        )
      
    
    {\displaystyle r\geq log_{2}(\sum _{i=0}^{\tfrac {d-1}{2}}C_{n}^{i})}
  
Для значений 
  
    
      
        (
        d
        
          /
        
        n
        )
        ≤
        0.3
      
    
    {\displaystyle (d/n)\leq 0.3}
   разница между границей Хемминга и границей Плоткина невелика.
Граница Варшамова — Гилберта для больших n определяет нижнюю границу числа проверочных символов

  
    
      
        r
        ≥
        l
        o
        
          g
          
            2
          
        
        (
        
          ∑
          
            i
            =
            0
          
          
            d
            −
            2
          
        
        
          C
          
            n
            −
            1
          
          
            i
          
        
        )
      
    
    {\displaystyle r\geq log_{2}(\sum _{i=0}^{d-2}C_{n-1}^{i})}
  Все вышеперечисленные оценки дают представление о верхней границе d при фиксированных n и k или оценку снизу числа проверочных символов

Код Хэмминга
Построение кодов Хэмминга основано на принципе проверки на четность числа единичных символов: к последовательности добавляется такой элемент, чтобы число единичных символов в получившейся последовательности было четным.

  
    
      
        
          r
          
            1
          
        
        =
        
          i
          
            1
          
        
        ⊕
        
          i
          
            2
          
        
        ⊕
        .
        .
        .
        ⊕
        
          i
          
            k
          
        
        .
      
    
    {\displaystyle r_{1}=i_{1}\oplus i_{2}\oplus ...\oplus i_{k}.}
  знак 
  
    
      
        ⊕
      
    
    {\displaystyle \oplus }
   здесь означает сложение по модулю 2

  
    
      
        S
        =
        
          i
          
            1
          
        
        ⊕
        
          i
          
            2
          
        
        ⊕
        .
        .
        .
        ⊕
        
          i
          
            n
          
        
        ⊕
        
          r
          
            1
          
        
      
    
    {\displaystyle S=i_{1}\oplus i_{2}\oplus ...\oplus i_{n}\oplus r_{1}}
  .
  
    
      
        S
        =
        0
      
    
    {\displaystyle S=0}
   — ошибки нет, 
  
    
      
        S
        =
        1
      
    
    {\displaystyle S=1}
   однократная ошибка.
Такой код называется 
  
    
      
        (
        k
        +
        1
        ,
        k
        )
      
    
    {\displaystyle (k+1,k)}
   или 
  
    
      
        (
        n
        ,
        n
        −
        1
        )
      
    
    {\displaystyle (n,n-1)}
  . Первое число — количество элементов последовательности, второе — количество информационных символов.
Для каждого числа проверочных символов 
  
    
      
        r
        =
        3
        ,
        4
        ,
        5..
      
    
    {\displaystyle r=3,4,5..}
   существует классический код Хэмминга с маркировкой

  
    
      
        (
        n
        ,
        k
        )
        =
        (
        
          2
          
            r
          
        
        −
        1
        ,
        
          2
          
            r
          
        
        −
        1
        −
        r
        )
      
    
    {\displaystyle (n,k)=(2^{r}-1,2^{r}-1-r)}
   то есть — 
  
    
      
        (
        7
        ,
        4
        )
        ,
        (
        15
        ,
        11
        )
        ,
        (
        31
        ,
        26
        )
      
    
    {\displaystyle (7,4),(15,11),(31,26)}
  . При иных значениях k получается так называемый усеченный код, например международный телеграфный код МТК-2, у которого 
  
    
      
        k
        =
        5
      
    
    {\displaystyle k=5}
  . Для него необходим код Хэмминга 
  
    
      
        (
        9
        ,
        5
        )
      
    
    {\displaystyle (9,5)}
  , который является усеченным от классического 
  
    
      
        (
        15
        ,
        11
        )
      
    
    {\displaystyle (15,11)}
  .
Для примера рассмотрим классический код Хемминга 
  
    
      
        (
        7
        ,
        4
        )
      
    
    {\displaystyle (7,4)}
  . Сгруппируем проверочные символы следующим образом:

  
    
      
        
          r
          
            1
          
        
        =
        
          i
          
            1
          
        
        ⊕
        
          i
          
            2
          
        
        ⊕
        
          i
          
            3
          
        
      
    
    {\displaystyle r_{1}=i_{1}\oplus i_{2}\oplus i_{3}}
  

  
    
      
        
          r
          
            2
          
        
        =
        
          i
          
            2
          
        
        ⊕
        
          i
          
            3
          
        
        ⊕
        
          i
          
            4
          
        
      
    
    {\displaystyle r_{2}=i_{2}\oplus i_{3}\oplus i_{4}}
  

  
    
      
        
          r
          
            3
          
        
        =
        
          i
          
            1
          
        
        ⊕
        
          i
          
            2
          
        
        ⊕
        
          i
          
            4
          
        
      
    
    {\displaystyle r_{3}=i_{1}\oplus i_{2}\oplus i_{4}}
  Получение кодового слова выглядит следующим образом:

  
    
      
        
          
            (
            
              
                
                  
                    i
                    
                      1
                    
                  
                
                
                  
                    i
                    
                      2
                    
                  
                
                
                  
                    i
                    
                      3
                    
                  
                
                
                  
                    i
                    
                      4
                    
                  
                
                
              
            
            )
          
        
      
    
    {\displaystyle {\begin{pmatrix}i_{1}&i_{2}&i_{3}&i_{4}&\\\end{pmatrix}}}
  
  
    
      
        
          
            (
            
              
                
                  1
                
                
                  0
                
                
                  0
                
                
                  0
                
                
                  1
                
                
                  0
                
                
                  1
                
              
              
                
                  0
                
                
                  1
                
                
                  0
                
                
                  0
                
                
                  1
                
                
                  1
                
                
                  1
                
              
              
                
                  0
                
                
                  0
                
                
                  1
                
                
                  0
                
                
                  1
                
                
                  1
                
                
                  0
                
              
              
                
                  0
                
                
                  0
                
                
                  0
                
                
                  1
                
                
                  0
                
                
                  1
                
                
                  1
                
              
            
            )
          
        
      
    
    {\displaystyle {\begin{pmatrix}1&0&0&0&1&0&1\\0&1&0&0&1&1&1\\0&0&1&0&1&1&0\\0&0&0&1&0&1&1\\\end{pmatrix}}}
   = 
  
    
      
        
          
            (
            
              
                
                  
                    i
                    
                      1
                    
                  
                
                
                  
                    i
                    
                      2
                    
                  
                
                
                  
                    i
                    
                      3
                    
                  
                
                
                  
                    i
                    
                      4
                    
                  
                
                
                  
                    r
                    
                      1
                    
                  
                
                
                  
                    r
                    
                      2
                    
                  
                
                
                  
                    r
                    
                      3
                    
                  
                
              
            
            )
          
        
      
    
    {\displaystyle {\begin{pmatrix}i_{1}&i_{2}&i_{3}&i_{4}&r_{1}&r_{2}&r_{3}\\\end{pmatrix}}}
  На вход декодера поступает кодовое слово

  
    
      
        V
        =
        (
        
          i
          
            1
          
          ′
        
        ,
        
          i
          
            2
          
          ′
        
        ,
        
          i
          
            3
          
          ′
        
        ,
        
          i
          
            4
          
          ′
        
        ,
        
          r
          
            1
          
          ′
        
        ,
        
          r
          
            2
          
          ′
        
        ,
        
          r
          
            3
          
          ′
        
        )
      
    
    {\displaystyle V=(i_{1}',i_{2}',i_{3}',i_{4}',r_{1}',r_{2}',r_{3}')}
   где штрихом помечены символы, которые могут исказиться в результате помехи. В декодере в режиме исправления ошибок строится последовательность синдромов:

  
    
      
        
          S
          
            1
          
        
        =
        
          r
          
            1
          
        
        ⊕
        
          i
          
            1
          
        
        ⊕
        
          i
          
            2
          
        
        ⊕
        
          i
          
            3
          
        
      
    
    {\displaystyle S_{1}=r_{1}\oplus i_{1}\oplus i_{2}\oplus i_{3}}
  

  
    
      
        
          S
          
            2
          
        
        =
        
          r
          
            2
          
        
        ⊕
        
          i
          
            2
          
        
        ⊕
        
          i
          
            3
          
        
        ⊕
        
          i
          
            4
          
        
      
    
    {\displaystyle S_{2}=r_{2}\oplus i_{2}\oplus i_{3}\oplus i_{4}}
  

  
    
      
        
          S
          
            3
          
        
        =
        
          r
          
            3
          
        
        ⊕
        
          i
          
            1
          
        
        ⊕
        
          i
          
            2
          
        
        ⊕
        
          i
          
            4
          
        
      
    
    {\displaystyle S_{3}=r_{3}\oplus i_{1}\oplus i_{2}\oplus i_{4}}
  
  
    
      
        S
        =
        (
        
          S
          
            1
          
        
        ,
        
          S
          
            2
          
        
        ,
        
          S
          
            3
          
        
        )
      
    
    {\displaystyle S=(S_{1},S_{2},S_{3})}
   называется синдромом последовательности.
Получение синдрома выглядит следующим образом:

  
    
      
        
          
            (
            
              
                
                  
                    i
                    
                      1
                    
                  
                
                
                  
                    i
                    
                      2
                    
                  
                
                
                  
                    i
                    
                      3
                    
                  
                
                
                  
                    i
                    
                      4
                    
                  
                
                
                  
                    r
                    
                      1
                    
                  
                
                
                  
                    r
                    
                      2
                    
                  
                
                
                  
                    r
                    
                      3
                    
                  
                
              
            
            )
          
        
      
    
    {\displaystyle {\begin{pmatrix}i_{1}&i_{2}&i_{3}&i_{4}&r_{1}&r_{2}&r_{3}\\\end{pmatrix}}}
  
  
    
      
        
          
            (
            
              
                
                  1
                
                
                  0
                
                
                  1
                
              
              
                
                  1
                
                
                  1
                
                
                  1
                
              
              
                
                  1
                
                
                  1
                
                
                  0
                
              
              
                
                  0
                
                
                  1
                
                
                  1
                
              
              
                
                  1
                
                
                  0
                
                
                  0
                
              
              
                
                  0
                
                
                  1
                
                
                  0
                
              
              
                
                  0
                
                
                  0
                
                
                  1
                
              
            
            )
          
        
      
    
    {\displaystyle {\begin{pmatrix}1&0&1\\1&1&1\\1&1&0\\0&1&1\\1&0&0\\0&1&0\\0&0&1\\\end{pmatrix}}}
   = 
  
    
      
        
          
            (
            
              
                
                  
                    S
                    
                      1
                    
                  
                
                
                  
                    S
                    
                      2
                    
                  
                
                
                  
                    S
                    
                      3
                    
                  
                
              
            
            )
          
        
      
    
    {\displaystyle {\begin{pmatrix}S_{1}&S_{2}&S_{3}\\\end{pmatrix}}}
  Кодовые слова 
  
    
      
        (
        7
        ,
        4
        )
      
    
    {\displaystyle (7,4)}
   кода Хэмминга

Синдром 
  
    
      
        (
        0
        ,
        0
        ,
        0
        )
      
    
    {\displaystyle (0,0,0)}
   указывает на то, что в последовательности нет искажений. Каждому ненулевому синдрому соответствует определенная конфигурация ошибок, которая исправляется на этапе декодирования.
Для кода 
  
    
      
        (
        7
        ,
        4
        )
      
    
    {\displaystyle (7,4)}
   в таблице указаны ненулевые синдромы и соответствующие им конфигурации ошибок (для вида: 
  
    
      
        
          i
          
            1
          
        
      
    
    {\displaystyle i_{1}}
   
  
    
      
        
          i
          
            2
          
        
      
    
    {\displaystyle i_{2}}
   
  
    
      
        
          i
          
            3
          
        
      
    
    {\displaystyle i_{3}}
   
  
    
      
        
          i
          
            4
          
        
      
    
    {\displaystyle i_{4}}
   
  
    
      
        
          r
          
            1
          
        
      
    
    {\displaystyle r_{1}}
   
  
    
      
        
          r
          
            2
          
        
      
    
    {\displaystyle r_{2}}
   
  
    
      
        
          r
          
            3
          
        
      
    
    {\displaystyle r_{3}}
  ).

Алгоритм кодирования
Предположим, что нужно сгенерировать код Хэмминга для некоторого информационного кодового слова. В качестве примера возьмём 15-битовое кодовое слово x1…x15, хотя алгоритм пригоден для кодовых слов любой длины. В приведённой ниже таблице в первой строке даны номера позиций в кодовом слове, во второй — условное обозначение битов, в третьей — значения битов.

Вставим в информационное слово контрольные биты r0…r4 таким образом, чтобы номера их позиций представляли собой целые степени двойки: 1, 2, 4, 8, 16… Получим 20-разрядное слово с 15 информационными и 5 контрольными битами. Первоначально контрольные биты устанавливаем равными нулю. На рисунке контрольные биты выделены розовым цветом.

В общем случае количество контрольных бит в кодовом слове равно двоичному логарифму числа, на единицу большего, чем количество бит кодового слова (включая контрольные биты); логарифм округляется в большую сторону. Например, информационное слово длиной 1 бит требует двух контрольных разрядов, 2-, 3- или 4-битовое информационное слово — трёх, 5…11-битовое — четырёх, 12…26-битовое — пяти и т. д.
Добавим к таблице 5 строк (по количеству контрольных битов), в которые поместим матрицу преобразования. Каждая строка будет соответствовать одному контрольному биту (нулевой контрольный бит — верхняя строка, четвёртый — нижняя), каждый столбец — одному биту кодируемого слова. В каждом столбце матрицы преобразования поместим двоичный номер этого столбца, причём порядок следования битов будет обратный — младший бит расположим в верхней строке, старший — в нижней. Например, в третьем столбце матрицы будут стоять числа 11000, что соответствует двоичной записи числа три: 00011.

В правой части таблицы мы оставили пустым один столбец, в который поместим результаты вычислений контрольных битов. Вычисление контрольных битов производим следующим образом. Берём одну из строк матрицы преобразования (например, r0) и находим её скалярное произведение с кодовым словом, то есть перемножаем соответствующие биты обеих строк и находим сумму произведений. Если сумма получилась больше единицы, находим остаток от его деления на 2. Иными словами, мы подсчитываем сколько раз в кодовом слове и соответствующей строке матрицы в одинаковых позициях стоят единицы и берём это число по модулю 2.
Если описывать этот процесс в терминах матричной алгебры, то операция представляет собой перемножение матрицы преобразования на матрицу-столбец кодового слова, в результате чего получается матрица-столбец контрольных разрядов, которые нужно взять по модулю 2.
Например, для строки r0:

r0 = (1·0+0·0+1·1+0·0+1·0+0·0+1·1+0·0+1·0+0·0+1·1+0·0+1·1+0·1+1·1+0·0+1·0+0·0+1·0+0·1) mod 2 = 5 mod 2 = 1.Полученные контрольные биты вставляем в кодовое слово вместо стоявших там ранее нулей. По аналогии находим проверочные биты в остальных строках. Кодирование по Хэммингу завершено. Полученное кодовое слово — 11110010001011110001.

Алгоритм декодирования
Алгоритм декодирования по Хэммингу абсолютно идентичен алгоритму кодирования. Матрица преобразования соответствующей размерности умножается на матрицу-столбец кодового слова и каждый элемент полученной матрицы-столбца берётся по модулю 2. Полученная матрица-столбец получила название «матрица синдромов». Легко проверить, что кодовое слово, сформированное в соответствии с алгоритмом, описанным в предыдущем разделе, всегда даёт нулевую матрицу синдромов.
Матрица синдромов становится ненулевой, если в результате ошибки (например, при передаче слова по линии связи с шумами) один из битов исходного слова изменил своё значение. Предположим для примера, что в кодовом слове, полученном в предыдущем разделе, шестой бит изменил своё значение с нуля на единицу (на рисунке обозначено красным цветом). Тогда получим следующую матрицу синдромов.

Заметим, что при однократной ошибке матрица синдромов всегда представляет собой двоичную запись (младший разряд в верхней строке) номера позиции, в которой произошла ошибка. В приведённом примере матрица синдромов (01100) соответствует двоичному числу 00110 или десятичному 6, откуда следует, что ошибка произошла в шестом бите.

Применение
Код Хэмминга используется в некоторых прикладных программах в области хранения данных, особенно в RAID 2; кроме того, метод Хэмминга давно применяется в памяти типа ECC и позволяет «на лету» исправлять однократные и обнаруживать двукратные ошибки.

См. также
Бит чётности
Циклический код
Циклический избыточный код
Код Рида — Соломона

Примечания
Литература
Питерсон У., Уэлдон Э. Коды, исправляющие ошибки: Пер. с англ. М.: Мир, 1976, 594 c.
Пенин П. Е., Филиппов Л. Н. Радиотехнические системы передачи информации. М.: Радио и Связь, 1984, 256 с.
Блейхут Р. Теория и практика кодов, контролирующих ошибки. Пер. с англ. М.: Мир, 1986, 576 с.