HDCP (англ. High-bandwidth Digital Content Protection — «защита широкополосного цифрового содержимого») — технология защиты медиаконтента, разработанная корпорацией Intel и предназначенная для предотвращения незаконного копирования высококачественного видеосигнала, передаваемого через интерфейсы DVI (для этого интерфейса HDCP является необязательной опцией), DisplayPort (для этого интерфейса HDCP является необязательной опцией), HDMI, GVIF или UDI. Защищённый видеосигнал может быть воспроизведён только на оборудовании, поддерживающем HDCP.
Система шифрования была окончательно взломана в 2010 году.

Технология
HDCP создана для защиты передачи медиаконтента между HDCP-передатчиком и HDCP-приёмником. Технология также предусматривает использование HDCP-повторителей с защищёнными портами для нисходящего потока данных (от поставщика к заказчику услуги). В системе может быть до семи уровней HDCP-повторителей и до 128 HDCP-совместимых устройств.
Система защиты состоит из трёх основных компонентов:

Протокол аутентификации
Шифрование передаваемых данных
Защита от подслушивания «третьим лицом»

Нахождение секретной матрицы DCP LLC
14 сентября 2010 несколько онлайн СМИ (ZDNet, Engadget) сообщили о факте открытой публикации мастер-ключа HDCP, с помощью которого можно создавать закрытые ключи устройств HDCP (device private keys) без помощи со стороны оператора ключевой инфраструктуры HDCP (The Digital Content Protection LLC). C публикацией мастер-ключа были нейтрализованы все меры по отзыву ключей устройств, так как вместо старого (отозванного) ключа устройства всегда можно сгенерировать новый. Не вполне ясно, каким образом был получен мастер-ключ, известно, что публикация ключа вместе с инструкцией по использованию произошла через Twitter и pastebin. Engadget считает, что атакующий мог использовать метод Crosby (2001).
Через 2 дня, 16 сентября, компания Intel (создатель HDCP) подтвердила, что данный мастер-ключ реален и что защита HDCP фактически взломана. Intel угрожает, что предпримет юридические действия против любого, кто изготавливает аппаратные устройства для обхода защиты HDCP.

Протокол аутентификации
Протокол аутентификации используется между HDCP-передатчиком и HDCP-приёмником для подтверждения того, что последний является устройством, которому разрешено получать соответствующий контент. Подтверждение — знание секретного набора ключей. Каждое HDCP-устройство снабжается уникальным набором из сорока 56-битных секретных ключей, называемых DPK (англ. device private keys, секретные ключи устройства), получаемых от организации DCP LLC. Во время обмена информацией устройства создают общий секрет, который нельзя подслушать во время этого обмена, и этот секрет далее применяется как симметричный ключ для расшифровки HDCP-контента, предназначенного устройству, прошедшему аутентификацию.
Каждое HDCP-устройство хранит, помимо Device Private Keys, соответствующий 40-битный идентификатор — KSV (англ. key selection vector, вектор выбора ключа), который, также как и DPK, получает от DCP LLC.
Протокол аутентификации можно разбить на три части:

Установление общего секрета
Сообщение HDCP-повторителя о векторах выбора ключа, присоединённых HDCP-получателях
Установление начального состояния шифра HDCP для кодирования содержимого кадра (третья часть происходит во время вертикального интервала, который предшествует каждому кадру, требующему шифрования)

Первая часть протокола аутентификации
На рисунке изображена первая часть работы протокола аутентификации.
Первым шагом HDCP-передатчик (устройство А) посылает инициирующее сообщение HDCP-приёмнику (устройство B). Сообщение содержит KSV передатчика (Aksv) и 64-битное псевдослучайное число (An) (число генерируется функцией hdcpRngCipher).
Передатчик может начать процедуру проверки подлинности в любой момент, даже если предыдущая только что завершилась.
Вторым шагом HDCP-приёмник отвечает сообщением с KSV приёмника (Bksv) и битом REPEATER (повторитель), который указывает, является ли устройство B повторителем или нет. HDCP-передатчик проверяет, что Aksv содержит ровно 20 нулей и 20 единиц и не находится в чёрном списке.
На этом этапе в обоих устройствах вычисляется общий 56-битный секрет Km и Km’.
Вычисление производится следующим образом:
Из набора DPK суммируются ключи в соответствии с битовым представлением полученного KSV: если бит равен единице, то соответствующий ключ используется. Сложение ключей происходит по модулю 
  
    
      
        
          2
          
            56
          
        
      
    
    {\displaystyle 2^{56}}
   без переполнения.

На третьем шаге применяется функция hdcpBlockCipher для вычисления Ks, M0, R0. Инициирующие величины для работы этой функции — Km (или Km’) и конкатенация бита REPEATER с An (бит REPEATER указывает на то, что HDCP-приёмник поддерживает дальнейшую передачу HDCP-контента, то есть является повторителем).

Ks — 56-битный сессионный ключ для работы HDCP шифра
M0 — 64-битная секретная величина, используемая во второй части протокола аутентификации, а также как вспомогательный инициирующий вектор HDCP шифра.
R0’ — 16-битный ответ, который видеоприёмник посылает HDCP-передатчику в подтверждение успеха обмена сообщениями аутентификации. HDCP-передатчик должен прочитать R0’ не позднее 100 миллисекунд после того как отправлено число Aksv видеоприёмнику, если прошло больше времени, то считывать R0’ нельзя.Если аутентификация прошла успешно, то R0 = R0’, иначе в большинстве случаев неравны. Далее, при помощи Ri’, получаемых в течение работы третьей части протокола, можно будет обнаружить, что аутентификация прошла неудачно, в том случае, если величина R0 ошибочно указала успех аутентификации.

Вторая часть протокола аутентификации
Вторая часть протокола аутентификации требуется в том случае, если HDCP-приёмник является HDCP-повторителем.
HDCP-передатчик выполняет вторую часть протокола только тогда, когда установлен бит REPEATER (повторитель),
это значит, что HDCP-приёмник — HDCP-повторитель.
Эта часть протокола составляет список всех KSV устройств, подключенных к HDCP-повторителю ниже по уровню:
HDCP-защищённые порты HDCP-повторителей, HDCP-приёмники. Этот список представлен в виде непрерывного набора байтов,
в котором каждый KSV занимает 5 байт, записанных в прямом порядке.
Общая длина KSV списка = 5 байт * число присоединенных активных HDCP устройств
HDCP-защищённые порты с неактивными HDCP устройствами ничего не добавляют в набор KSV, так же, как и сам HDCP-повторитель, инициирующий создание списка, не добавляет свой KSV в него.
Для того, чтобы добавить KSV-список, полученный от предыдущего HDCP-повторителя, требуется проверка целостности. HDCP-повторитель, запросивший список, вычисляет V и сравнивает его с полученным V’.
V = SHA-1 (список KSV || состояние B || M0)
Где:

список KSV — битовое представление KSV
состояние B — битовое представление состояния устройства B (см. таблицу)
M0 — некоторая секретная величинаВсё битовое представление располагается в прямом порядке.
Если V≠ V’, то проверка на целостность считается неудачной и HDCP-повторитель не должен принимать список. При этом истечет таймер watchdog (сторожевой таймер) и HDCP-передатчик сумеет обнаружить эту ошибку.
Кроме составления списка KSV производится распространение топологической информации (количество и глубина) вверх по дереву устройств до HDCP-передатчика. Количество устройств (англ. device count) рассчитывается как количество всех HDCP-повторителей и приёмников вниз от устройства, которое считает сумму. Глубина (англ. depth) для HDCP-повторителя равна максимальному значения глубины, полученному от нижестоящих в дереве устройств HDCP-повторителю, плюс один. Например, для HDCP-повторителя с четырьмя нижестоящими HDCP-получателями глубина равна единице, а число устройств — четырём.
Число устройств в одном дереве не может превышать 127, а число уровней (глубина) — семи.

Третья часть протокола аутентификации
Третья часть протокола работает в течение вертикального интервала (англ. vertical blanking interval), предшествующего кадру. Каждый из двух HDCP устройств вычисляет новые инициирующие числа Ki, Mi и Ri, где индекс i отображает номер кадра, начиная с единицы для первого кадра с шифрованием (после завершения первой части протокола аутентификации). Индекс увеличивается на единицу с каждым кадром или с каждым зашифрованным кадром в зависимости от того, включен ли режим ADVANCE_CIPHER. Счётчик кадров не увеличивается, если HDCP устройство находится в состоянии HDMI AVMUTE (режим, когда выключается звук, если происходят изменения, которые могут привести к шуму в аудиоканале), и не увеличивается после выхода из этого состояния до первого шифрованного кадра.

Ki — 56-битный ключ, используемый для инициализации HDCP шифра, чтобы зашифровать или расшифровать HDCP контент.
Mi — новая 64-битная инициирующая величина для HDCP шифра.
Ri — 16-битное число, предназначенное для подтверждения целостности соединения (увеличивается каждые 128 кадров, начиная со 128).HDCP-передатчик проверяет Ri’ по собственным вычислениям для того, чтобы подтвердить способность видеоприемника корректно расшифровывать информацию. Эта проверка делается как минимум каждые две секунды, также возможно синхронное чтение Ri во время очередного её изменения (каждые 128 кадров). При этом чтение Ri' должно завершиться в течение одной миллисекунды с того момента, как HDCP-передатчик инициирует это действие, если по каким-либо причинам операция не удалась, то HDCP-передатчик считает, что HDCP-приёмник не прошёл аутентификацию.
С целью увеличения вероятности обнаружения рассинхронизации в шифровании HDCP-передатчик и приёмник дополнительно могут поддерживать Enhanced Link Verification (усиленный контроль за соединением), в котором вычисления для поддержки контроля над синхронизацией шифра выполняются, если передается особый пиксель.
Режим ADVANCE_CIPHER — это дополнительный режим, в котором состояние шифра и счётчик кадров увеличиваются каждый кадр в режиме DVI или каждый кадр в режиме HDMI (если только он не находится в состоянии AVMUTE) вне зависимости от того, включено шифрование или нет.

Шифрование данных
HDCP-шифрование происходит на входе TMDS (англ. Transition Minimized Differential Signaling, дифференциальная передача сигналов с минимизацией перепадов уровней) шифратора, а расшифрование - на выходе TMDS-дешифратора. Процедура шифрования состоит из побитового сложения (XOR) потока данных с псевдослучайной последовательностью, генерируемой HDCP-шифром.

Во время вертикального интервала функция hdcpBlockCipher подготавливает HDCP-шифр к генерации для каждого пикселя входного потока 24-битной псевдослучайной последовательности, зависящей от ключа. Эти биты накладываются на TMDS-каналы, как показано в таблице на примере RGB-видеопотока.

Во время строчного интервала гашения (англ. horizontal-blanking interval) HDCP-шифр переназначает ключ каждые 56 бит, что усложняет задачу построчного взлома шифра.

HDCP-шифр
Общую структуру HDCP-шифра можно разделить на три слоя. Первый слой состоит из четырёх линейных регистров сдвига с обратной связью (англ. linear feedback shift register, LFSR), на выходе которых получается один бит. Если подан сигнал повторного ввода ключа, то этот бит помещается в средний слой. Средний слой состоит из двух схожих частей. Первая часть — функция B раунда — выполняет один раунд блочного шифрования, используя три 28-битных регистра Bx, By, Bz. Вторая часть — функция K раунда — схожа по структуре с функцией B, но работает выходом защёлки Ky (поток 28-битных раундовых ключей к раундовой функции B с частотой один 28-битный ключ в один такт). В нижнем слое каждый такт происходит компрессия четырёх выходов 28-битных регистров By, Bz, Ky, Kz в 24-битный блок псевдослучайной последовательности.

Модуль линейных регистров сдвига с обратной связью
Модуль линейных регистров сдвига состоит из четырёх LFSR различной длины и разных смесителей (англ. combining function). Функция смешения зависит от трёх отводов (англ. tap) каждого регистра.

Функция смешения состоит из четырёх каскадно-соединенных сетей с перемещением каналов (англ. shuffle network), каждая из которых включает в себя два бита состояния. Над одними отводами каждого из четырёх регистров производится операция XOR для того, чтобы сформировать входные данные для первого каскада сети. Другие отводы регистров используются для выбора входа в одну из сетей. Выход четвёртой сети складывается (XOR) с одним отводом от каждого регистра.

Сеть с перемещением каналов
На рисунке схематически изображена сеть с перемещением каналов. В том случае, если в сети содержится пара булевских значений (A, B), на вход поступает булевская величина D, а вход выбора S, то значение параметра S определяет следующее состояние. Если S — ноль, то на выход поступает A и устанавливается состояние (B, D). Если S — единица, то на выходе - B и устанавливается состояние (A, D).

Во всех режимах работы LSFR и функция смешения инициализируются 56-битным числом. 60 битов LSFR-состояния используют эти 56 битов непосредственно, плюс дополнение некоторых четырёх бит. Shuffle-сети инициализируются той же величиной.
Однобитовый выходной поток функции смешения — это единственные данные, получаемые из работы модуля LSFR. Этот поток снабжает модуль блоков материалом для создания ключей, если поступил сигнал на переопределение ключа.

Модуль блоков
Этот модуль состоит из двух отдельных компонент, называемых раундовыми функциями. Одна из компонент - раундовая функция K снабжает другую компоненту — раундовую функцию B — потоком ключей. Каждая компонента работает с соответствующим набором трёх 28-битных регистров.
Если поступил сигнал на переопределение ключа, то в тринадцатый бит регистра Ky записывается бит из выходного потока модуля LSFR.
S-блоки для обеих раундовых функций состоят из семи S-блоков с четырьмя входами и четырьмя выходами. Для раундовой функции K S-блоки названы SK0, SK1.. ,SK6. Для раундовой функции B S-блоки названы SB0, SB1.., SB6. В I-й вход блока J записывается бит под номером I*7+J регистров Bx или Kx, а на выход I блока J подается бит I*7+J регистров Bz, Kz. При этом бит ноль считается младшим разрядом.

Диффузионные сети для раундовой функции К показаны в таблице. Следует заметить, что ни в одной диффузионной сети для этой функции нет дополнительных входов. В половине диффузионных компонент функции B присутствуют дополнительные входы, в которые поступают биты из регистра Ky раундовой функции K.

Логическая функция выхода
Регистры Ky, Kz, By, Bz образуют логическую функцию выхода. Каждый из 24 битов получается путём сложения (XOR) девяти членов, как показывает формула ниже:

  
    
      
        (
        B
        0
        ∗
        K
        0
        )
        
          ⊕
          
            2
          
        
        (
        B
        1
        ∗
        K
        1
        )
        
          ⊕
          
            2
          
        
        (
        B
        2
        ∗
        K
        2
        )
        
          ⊕
          
            2
          
        
        (
        B
        3
        ∗
        K
        3
        )
        
          ⊕
          
            2
          
        
        (
        B
        4
        ∗
        K
        4
        )
        
          ⊕
          
            2
          
        
        (
        B
        5
        ∗
        K
        5
        )
        
          ⊕
          
            2
          
        
        (
        B
        6
        ∗
        K
        6
        )
        
          ⊕
          
            2
          
        
        B
        7
        
          ⊕
          
            2
          
        
        K
        7
      
    
    {\displaystyle (B0*K0)\oplus _{2}(B1*K1)\oplus _{2}(B2*K2)\oplus _{2}(B3*K3)\oplus _{2}(B4*K4)\oplus _{2}(B5*K5)\oplus _{2}(B6*K6)\oplus _{2}B7\oplus _{2}K7}
  
Где 
  
    
      
        
          ⊕
          
            2
          
        
      
    
    {\displaystyle \oplus _{2}}
   — XOR, a 
  
    
      
        ∗
      
    
    {\displaystyle *}
   — логическое умножение

Пример:
Выходной бит 0 вычисляется следующим образом:

  
    
      
        (
        B
        z
        17
        ∗
        K
        z
        3
        )
        
          ⊕
          
            2
          
        
        (
        B
        z
        26
        ∗
        K
        z
        6
        )
        
          ⊕
          
            2
          
        
        (
        B
        z
        22
        ∗
        K
        z
        0
        )
        
          ⊕
          
            2
          
        
      
    
    {\displaystyle (Bz17*Kz3)\oplus _{2}(Bz26*Kz6)\oplus _{2}(Bz22*Kz0)\oplus _{2}}
  
  
    
      
        
          ⊕
          
            2
          
        
        (
        B
        z
        27
        ∗
        K
        z
        9
        )
        
          ⊕
          
            2
          
        
        (
        B
        z
        21
        ∗
        K
        z
        4
        )
        
          ⊕
          
            2
          
        
        (
        B
        z
        18
        ∗
        K
        z
        22
        )
        
          ⊕
          
            2
          
        
      
    
    {\displaystyle \oplus _{2}(Bz27*Kz9)\oplus _{2}(Bz21*Kz4)\oplus _{2}(Bz18*Kz22)\oplus _{2}}
  
  
    
      
        
          ⊕
          
            2
          
        
        (
        B
        z
        2
        ∗
        K
        z
        5
        )
        
          ⊕
          
            2
          
        
        B
        y
        5
        
          ⊕
          
            2
          
        
        K
        y
        10
      
    
    {\displaystyle \oplus _{2}(Bz2*Kz5)\oplus _{2}By5\oplus _{2}Ky10}

Некоторые используемые функции
hdcpBlockCipher
Эта последовательность используется во время первой части протокола аутентификации, чтобы выработать сессионный ключ Ks и во время вертикального интервала, предшествующего шифрованному кадру, чтобы получить ключ кадра Ki.

Для 8-битных чисел a и b результатом конкатенации ab является 16-битное число, где a — старший разряд, а b — младший разряд.
В обеих раундовых функциях B и K регистры x, y, z можно рассматривать как один регистр длиной в 84 бита.
В том случае, когда требуется менее 84 битов регистра, используются биты младшего разряда. Если для инициализации доступно менее 84 бит, то заполняются младшие биты, а оставшиеся устанавливаются в ноль.

Пример:
65-битный результат конкатенации бита REPEATER и величины An будет записан в регистры Bx и By, 
плюс в 9 младших бит регистра Bz,  при этом старшие 19 бит регистра заполнятся нулями.
Откуда берутся биты Mi и Ri, показано в таблице выше.

hdcpRngCipher
Эта функция используется как генератор случайных чисел, причём функция должна поддерживать метод, который позволял бы получать биты из внешнего источника. Должно происходить смешивание битов извне со значениями регистров (без замены). То есть не должно существовать способа определить генерируемую величину.
Внешний источник должен обладать разумной вероятностью, или энтропией. То есть, если, например, дан 1000000 различных циклов, то количество повторяющихся чисел среди 1000000 An не должно превышать 50 %. Это соответствует примерно сорока (если считать, что 
  
    
      
        1000000
        ≈
        
          2
          
            20
          
        
      
    
    {\displaystyle 1000000\approx 2^{20}}
  ) произвольным битам из 64.

Криптоанализ
Для того, чтобы получить общий секрет, устройства складывают свои секретные ключи Ai в зависимости от полученного вектора ключа. В итоге получается 56-битный секрет Km (передатчик) и Km’ (приёмник), причём они должны быть равны.
Затем, после аутентификации приёмник шифрует оказию полученным ключом и отправляет её передатчику. Тот, в свою очередь, проверяет своим ключом Km, что оказия зашифрована верно.
Следовательно, если мы определим 40 линейно независимых векторов 
  
    
      
        
          A
          
            1
          
        
        .
        .
        
          A
          
            40
          
        
      
    
    {\displaystyle A_{1}..A_{40}}
   (секретные ключи устройства), то мы сможем полностью взломать систему, поскольку эти ключи будут составлять базис 40-мерного пространства секретных ключей, и мы сможем составить из них любой набор секретных ключей любого устройства.
С другой стороны, если не все 40 ключей будут линейно независимыми, то мы все равно сможем создать определенные наборы секретных ключей, входящих в найденное подпространство.

Пример:
Предположим, что у нас есть 40 устройств 
  
    
      
        (
        
          A
          
            1
          
        
        …
        
          A
          
            40
          
        
        )
      
    
    {\displaystyle (A_{1}\dots A_{40})}
  , для которых мне известны их векторы выбора ключей и 
наборы секретных ключей   
  
    
      
        (
        (
        
          A
          
            1
          
        
        )
        k
        e
        y
        s
        …
        (
        
          A
          
            40
          
        
        )
        k
        e
        y
        s
        )
      
    
    {\displaystyle ((A_{1})keys\dots (A_{40})keys)}
  , тогда, в результате обмена информацией с устройством, 
которое мы хотим взломать, получится система уравнений:

  
    
      
        
          
            {
            
              
                
                  X
                  k
                  e
                  y
                  s
                  ∗
                  (
                  
                    A
                    
                      1
                    
                  
                  )
                  k
                  s
                  v
                  =
                  (
                  
                    A
                    
                      1
                    
                  
                  )
                  k
                  e
                  y
                  s
                  ∗
                  X
                  k
                  s
                  v
                
              
              
                
                  X
                  k
                  e
                  y
                  s
                  ∗
                  (
                  
                    A
                    
                      2
                    
                  
                  )
                  k
                  s
                  v
                  =
                  (
                  
                    A
                    
                      2
                    
                  
                  )
                  k
                  e
                  y
                  s
                  ∗
                  X
                  k
                  s
                  v
                
              
              
                
                  …
                
              
              
                
                  X
                  k
                  e
                  y
                  s
                  ∗
                  (
                  
                    A
                    
                      4
                    
                  
                  0
                  )
                  k
                  s
                  v
                  =
                  (
                  
                    A
                    
                      40
                    
                  
                  )
                  k
                  e
                  y
                  s
                  ∗
                  X
                  k
                  s
                  v
                
              
            
            
          
        
      
    
    {\displaystyle {\begin{cases}Xkeys*(A_{1})ksv=(A_{1})keys*Xksv\\Xkeys*(A_{2})ksv=(A_{2})keys*Xksv\\\dots \\Xkeys*(A_{4}0)ksv=(A_{40})keys*Xksv\\\end{cases}}}
  
 

решив которую, мы получим секретные ключи атакуемого устройства. Предположение, которое мы делаем — то, что все 40 векторов выбора ключа 
  
    
      
        (
        A
        i
        )
      
    
    {\displaystyle (Ai)}
  ksv линейно независимы.
Если же пространство, охватываемое 
  
    
      
        (
        A
        i
        )
        k
        s
        v
      
    
    {\displaystyle (Ai)ksv}
   не является 40-мерным, то всё равно должна остаться лазейка. Или эти векторы выбора ключа сконструированы так, что будет невозможно составить из них базис сорокамерного пространства, или нам потребуется более 40 KSV, чтобы охватить всё пространство (каждое дополнительное устройство обладает малыми шансами быть линейно зависимым к уже полученному набору, примерно 
  
    
      
        
          
            1
            
              2
              
                40
                −
                n
              
            
          
        
      
    
    {\displaystyle {\frac {1}{2^{40-n}}}}
  , где n — размерность охваченного пространства)
Мы также можем сами создать правильные наборы вектора выбора ключа и секретных ключей устройства из линейной комбинации уже нам известных.
Пример:
1. Выберем произвольное устройство B, если B может аутентифицировать Ai, то выполняется равенство:

  
    
      
        (
        
          K
          
            i
          
        
        )
        
          m
          ′
        
        =
        (
        
          A
          
            1
          
        
        )
        k
        e
        y
        s
        ∗
        B
        k
        s
        v
        =
        B
        k
        e
        y
        s
        ∗
        (
        
          A
          
            i
          
        
        )
        k
        s
        v
        =
        (
        
          K
          
            i
          
        
        )
        m
        .
      
    
    {\displaystyle (K_{i})m'=(A_{1})keys*Bksv=Bkeys*(A_{i})ksv=(K_{i})m.}
  2. Пусть

  
    
      
        X
        k
        s
        v
        =
        
          a
          
            1
          
        
        ∗
        (
        
          A
          
            1
          
        
        )
        k
        s
        v
        +
        
          a
          
            2
          
        
        ∗
        (
        
          A
          
            2
          
        
        )
        k
        s
        v
        .
        .
        .
        
          a
          
            n
          
        
        ∗
        (
        
          A
          
            n
          
        
        )
        k
        s
        v
        .
      
    
    {\displaystyle Xksv=a_{1}*(A_{1})ksv+a_{2}*(A_{2})ksv...a_{n}*(A_{n})ksv.}
  3. Мы знаем, что, когда устройство B аутентифицирует устройство X, используется величина Km:

  
    
      
        K
        m
        =
        B
        k
        e
        y
        s
        ∗
        X
        k
        s
        v
        =
        B
        k
        e
        y
        s
        ∗
        (
        
          a
          
            1
          
        
        ∗
        (
        
          A
          
            1
          
        
        )
        k
        s
        v
        +
        
          a
          
            2
          
        
        ∗
        (
        
          A
          
            2
          
        
        )
        k
        s
        v
        +
        .
        .
        .
        +
        
          a
          
            n
          
        
        (
        
          A
          
            n
          
        
        )
        k
        s
        v
        )
        =
        
          a
          
            1
          
        
        ∗
        (
        
          A
          
            1
          
        
        )
        k
        s
        v
        ∗
        B
        k
        e
        y
        s
        +
        .
        .
        .
        +
        
          a
          
            n
          
        
        ∗
        (
        
          A
          
            n
          
        
        )
        k
        s
        v
        ∗
        B
        k
        e
        y
        s
        =
        
          a
          
            1
          
        
        ∗
        (
        
          K
          
            1
          
        
        )
        m
        +
        a
        +
        2
        ∗
        (
        
          K
          
            2
          
        
        )
        m
        +
        .
        .
        .
        +
        
          a
          
            n
          
        
        (
        
          K
          
            n
          
        
        )
        m
        .
      
    
    {\displaystyle Km=Bkeys*Xksv=Bkeys*(a_{1}*(A_{1})ksv+a_{2}*(A_{2})ksv+...+a_{n}(A_{n})ksv)=a_{1}*(A_{1})ksv*Bkeys+...+a_{n}*(A_{n})ksv*Bkeys=a_{1}*(K_{1})m+a+2*(K_{2})m+...+a_{n}(K_{n})m.}
  4. То есть, вспоминая тот факт, что (Ki)'m = Ki для всех i, мы можем вычислить Km':

  
    
      
        K
        
          m
          ′
        
        =
        
          a
          
            1
          
        
        ∗
        (
        
          K
          
            1
          
        
        )
        
          m
          ′
        
        +
        
          a
          
            2
          
        
        ∗
        (
        
          K
          
            2
          
        
        )
        
          m
          ′
        
        +
        .
        .
        .
        +
        
          a
          
            n
          
        
        ∗
        (
        
          K
          
            n
          
        
        )
        
          m
          ′
        
        =
        
          a
          
            1
          
        
        ∗
        (
        
          A
          
            1
          
        
        )
        k
        e
        y
        s
        ∗
        B
        k
        s
        v
        +
        .
        .
        .
        +
        
          a
          
            n
          
        
        ∗
        (
        
          A
          
            n
          
        
        )
        k
        e
        y
        s
        ∗
        B
        k
        s
        v
        =
        [
        
          a
          
            1
          
        
        ∗
        (
        
          A
          
            1
          
        
        )
        k
        e
        y
        s
        +
        .
        .
        .
        +
        
          a
          
            n
          
        
        ∗
        (
        
          A
          
            n
          
        
        )
        k
        e
        y
        s
        ]
        ∗
        B
        k
        s
        v
        .
      
    
    {\displaystyle Km'=a_{1}*(K_{1})m'+a_{2}*(K_{2})m'+...+a_{n}*(K_{n})m'=a_{1}*(A_{1})keys*Bksv+...+a_{n}*(A_{n})keys*Bksv=[a_{1}*(A_{1})keys+...+a_{n}*(A_{n})keys]*Bksv.}
  5. Так как выбор B был произвольным, то это сработает для любого B, причём

  
    
      
        X
        k
        e
        y
        s
        =
        
          a
          
            1
          
        
        ∗
        (
        
          A
          
            1
          
        
        )
        k
        e
        y
        s
        +
        .
        .
        .
        +
        
          a
          
            n
          
        
        ∗
        (
        
          A
          
            n
          
        
        )
        k
        e
        y
        s
        .
      
    
    {\displaystyle Xkeys=a_{1}*(A_{1})keys+...+a_{n}*(A_{n})keys.}
  Аутентификация между B и X пройдет успешно.
Единственной сложностью может быть конструирование Xksv таким образом, чтобы он состоял из 20 нулей и 20 единиц.

Применение HDCP
Используется в HD DVD и Blu-ray плеерах. Если устройство воспроизведения и, в случае использования компьютера, ПО не поддерживают HDCP, то сигнал не будет транслироваться на выход, либо будет, но c деградированым качеством (англ. Image Constraint Token flag).
Одобрена 4 августа 2004 г. Федеральным агентством по связи США (англ. Federal Communications Commission, FCC) как "Технология защиты цифровых выходов (англ. Digital Output Protection Technology).
Технология поддерживается ОС Windows Vista.
Поддержка HDCP является обязательным условием соответствия марке «HD ready», также его применение насаждается законами США для всех приёмников вещания высокой чёткости.

См. также
AACS
HDTV

Примечания
Ссылки
Digital Content Protection LLC organization (англ.). — Официальный сайт организации, лицензирующей технологию. Архивировано 25 февраля 2012 года.
Digital Content Protection LLC. HDCP specification v1.4 (англ.). — Спецификация технологии HDCP. Архивировано 25 февраля 2012 года.
Scott A. Crosby. Apparent HDCP authentication protocol weaknesses (англ.). — Уязвимости протокола аутентификации HDCP. Архивировано 25 февраля 2012 года.
Keith Irwin. Four Simple Cryptographic Attacks on HDCP (англ.). — Четыре простых атаки на HDCP. Архивировано 25 февраля 2012 года.
Scott Crosby, Ian Goldberg, Robert Johnson, Dawn Song, David Wagner. A Cryptanalysis of the HDCP (англ.). — Детальный криптоанализ HDCP. Архивировано 25 февраля 2012 года.