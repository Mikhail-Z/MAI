Коды Рида — Соломона (англ. Reed–Solomon codes) — недвоичные циклические коды, позволяющие исправлять ошибки в блоках данных. Элементами кодового вектора являются не биты, а группы битов (блоки). Очень распространены коды Рида — Соломона, работающие с байтами (октетами).
Код Рида — Соломона является частным случаем БЧХ-кода.
В настоящее время широко используется в системах восстановления данных с компакт-дисков, при создании архивов с информацией для восстановления в случае повреждений, в помехоустойчивом кодировании.

История
Код Рида — Соломона был изобретён в 1960 году сотрудниками лаборатории Линкольна Массачусетского технологического института Ирвином Ридом и Густавом Соломоном. Идея использования этого кода была представлена в статье «Polynomial Codes over Certain Finite Fields». Эффективные алгоритмы декодирования были предложены в 1969 году Элвином Берлекэмпом и Джэймсом Месси (алгоритм Берлекэмпа — Мэсси) и в 1977 году Давидом Мандельбаумом (метод, использующий Алгоритм Евклида). Первое применение код Рида — Соломона получил в 1982 году в серийном выпуске компакт-дисков.

Формальное описание
Коды Рида — Соломона являются важным частным случаем БЧХ-кода, корни порождающего полинома которого лежат в том же поле, над которым строится код (
  
    
      
        m
        =
        1
      
    
    {\displaystyle m=1}
  ).
Пусть 
  
    
      
        α
      
    
    {\displaystyle \alpha }
   — элемент поля 
  
    
      
        
          G
          F
          (
          q
          )
        
      
    
    {\displaystyle \textstyle GF(q)}
   порядка 
  
    
      
        
          n
        
      
    
    {\displaystyle \textstyle n}
  . Если 
  
    
      
        α
      
    
    {\displaystyle \alpha }
   — примитивный элемент, то его порядок равен 
  
    
      
        q
        −
        1
      
    
    {\displaystyle q-1}
  , то есть 
  
    
      
        
          α
          
            q
            −
            1
          
        
        =
        1
        ,
        
        
          α
          
            i
          
        
        ≠
        1
        ,
        0
        <
        i
        <
        q
        −
        1
      
    
    {\displaystyle \alpha ^{q-1}=1,\quad \alpha ^{i}\neq 1,0<i<q-1}
  . Тогда нормированный полином 
  
    
      
        g
        (
        x
        )
      
    
    {\displaystyle g(x)}
   минимальной степени над полем 
  
    
      
        
          G
          F
          (
          q
          )
        
      
    
    {\displaystyle \textstyle GF(q)}
  , корнями которого являются 
  
    
      
        d
        −
        1
      
    
    {\displaystyle d-1}
   подряд идущих степеней 
  
    
      
        
          α
          
            
              l
              
                0
              
            
          
        
        ,
        
          α
          
            
              l
              
                0
              
            
            +
            1
          
        
        ,
        .
        .
        .
        ,
        
          α
          
            
              l
              
                0
              
            
            +
            d
            −
            2
          
        
      
    
    {\displaystyle \alpha ^{l_{0}},\alpha ^{l_{0}+1},...,\alpha ^{l_{0}+d-2}}
   элемента 
  
    
      
        α
      
    
    {\displaystyle \alpha }
  , является порождающим полиномом кода Рида — Соломона над полем 
  
    
      
        
          G
          F
          (
          q
          )
        
      
    
    {\displaystyle \textstyle GF(q)}
  :

  
    
      
        g
        (
        x
        )
        =
        (
        x
        −
        
          α
          
            
              l
              
                0
              
            
          
        
        )
        (
        x
        −
        
          α
          
            
              l
              
                0
              
            
            +
            1
          
        
        )
        …
        (
        x
        −
        
          α
          
            
              l
              
                0
              
            
            +
            d
            −
            2
          
        
        )
      
    
    {\displaystyle g(x)=(x-\alpha ^{l_{0}})(x-\alpha ^{l_{0}+1})\dots (x-\alpha ^{l_{0}+d-2})}
  где 
  
    
      
        
          l
          
            0
          
        
      
    
    {\displaystyle l_{0}}
   — некоторое целое число (в том числе 0 и 1), с помощью которого иногда удается упростить кодер. Обычно полагается 
  
    
      
        
          l
          
            0
          
        
        =
        1
      
    
    {\displaystyle l_{0}=1}
  . Степень многочлена 
  
    
      
        
          g
          (
          x
          )
        
      
    
    {\displaystyle \textstyle g(x)}
   равна 
  
    
      
        d
        −
        1
      
    
    {\displaystyle d-1}
  .
Длина полученного кода 
  
    
      
        n
      
    
    {\displaystyle n}
  , минимальное расстояние 
  
    
      
        d
      
    
    {\displaystyle d}
   (минимальное расстояние d линейного кода является минимальным из всех расстояний Хемминга всех пар кодовых слов, см. Линейный код). Код содержит 
  
    
      
        r
        =
        d
        −
        1
        =
        deg
        ⁡
        (
        g
        (
        x
        )
        )
      
    
    {\displaystyle r=d-1=\deg(g(x))}
   проверочных символов, где 
  
    
      
        deg
        ⁡
        (
        )
      
    
    {\displaystyle \deg()}
   обозначает степень полинома; число информационных символов 
  
    
      
        k
        =
        n
        −
        r
        =
        n
        −
        d
        +
        1
      
    
    {\displaystyle k=n-r=n-d+1}
  . Таким образом 
  
    
      
        
          d
          =
          n
          −
          k
          +
          1
        
      
    
    {\displaystyle \textstyle d=n-k+1}
   и код Рида — Соломона является разделимым кодом с максимальным расстоянием (является оптимальным в смысле границы Синглтона).
Кодовый полином 
  
    
      
        c
        (
        x
        )
      
    
    {\displaystyle c(x)}
   может быть получен из информационного полинома 
  
    
      
        m
        (
        x
        )
      
    
    {\displaystyle m(x)}
  , 
  
    
      
        deg
        ⁡
        m
        (
        x
        )
        ⩽
        k
        −
        1
      
    
    {\displaystyle \deg m(x)\leqslant k-1}
  , путём перемножения 
  
    
      
        m
        (
        x
        )
      
    
    {\displaystyle m(x)}
   и 
  
    
      
        g
        (
        x
        )
      
    
    {\displaystyle g(x)}
  :

  
    
      
        c
        (
        x
        )
        =
        m
        (
        x
        )
        g
        (
        x
        )
      
    
    {\displaystyle c(x)=m(x)g(x)}

Свойства
Код Рида — Соломона над 
  
    
      
        
          G
          F
          (
          
            q
            
              m
            
          
          )
        
      
    
    {\displaystyle \textstyle GF(q^{m})}
  , исправляющий 
  
    
      
        t
      
    
    {\displaystyle t}
   ошибок, требует 
  
    
      
        2
        t
      
    
    {\displaystyle 2t}
   проверочных символов и с его помощью исправляются произвольные пакеты ошибок длиной 
  
    
      
        t
      
    
    {\displaystyle t}
   и меньше. Согласно теореме о границе Рейгера, коды Рида — Соломона являются оптимальными с точки зрения соотношения длины пакета и возможности исправления ошибок — используя 
  
    
      
        2
        t
      
    
    {\displaystyle 2t}
   дополнительных проверочных символов исправляется 
  
    
      
        t
      
    
    {\displaystyle t}
   ошибок (и менее).
Теорема (граница Рейгера). Каждый линейный блоковый код, исправляющий все пакеты длиной 
  
    
      
        t
      
    
    {\displaystyle t}
   и менее, должен содержать, по меньшей мере, 
  
    
      
        2
        t
      
    
    {\displaystyle 2t}
   проверочных символов.
Код, двойственный коду Рида — Соломона, есть также код Рида — Соломона. Двойственным кодом для циклического кода называется код, порожденный его проверочным многочленом.
Матрица

  
    
      
        G
        =
        [
        
          
            
              
                
                  I
                  
                    k
                    ∗
                    k
                  
                
              
              
                
                  P
                  
                    k
                    ∗
                    (
                    n
                    −
                    k
                    )
                  
                
              
            
          
        
        ]
      
    
    {\displaystyle G=[{\begin{array}{cc}I_{k*k}&P_{k*(n-k)}\\\end{array}}]}
   порождает код Рида — Соломона тогда и только тогда когда любой минор матрицы 
  
    
      
        
          P
          
            k
            ∗
            (
            n
            −
            k
            )
          
        
      
    
    {\displaystyle P_{k*(n-k)}}
   отличен от нуля.
При выкалывании или укорочении кода Рида — Соломона снова получается код Рида — Соломона. Выкалывание — операция, состоящая в удалении одного проверочного символа. Длина 
  
    
      
        n
      
    
    {\displaystyle n}
   кода уменьшается на единицу, размерность 
  
    
      
        k
      
    
    {\displaystyle k}
   сохраняется. Расстояние кода 
  
    
      
        d
      
    
    {\displaystyle d}
   должно уменьшиться на единицу, ибо в противном случае удаленный символ был бы бесполезен. Укорочение — фиксируем произвольный столбец 
  
    
      
        (
        n
        ,
        k
        ,
        d
        )
      
    
    {\displaystyle (n,k,d)}
   кода и выбираем только те векторы, которые в данном столбце содержат 0. Это множество векторов образует подпространство.

Исправление многократных ошибок
Код Рида — Соломона является одним из наиболее мощных кодов, исправляющих многократные пакеты ошибок. Применяется в каналах, где пакеты ошибок могут образовываться столь часто, что их уже нельзя исправлять с помощью кодов, исправляющих одиночные ошибки.

  
    
      
        (
        
          q
          
            m
          
        
        −
        1
        ,
        
          q
          
            m
          
        
        −
        1
        −
        2
        t
        )
      
    
    {\displaystyle (q^{m}-1,q^{m}-1-2t)}
  Код Рида — Соломона над полем 
  
    
      
        
          G
          F
          (
          
            q
            
              m
            
          
          )
        
      
    
    {\displaystyle \textstyle GF(q^{m})}
   с кодовым расстоянием 
  
    
      
        d
        =
        2
        t
        +
        1
      
    
    {\displaystyle d=2t+1}
   можно рассматривать как 
  
    
      
        (
        (
        
          q
          
            m
          
        
        −
        1
        )
        m
        ,
        (
        
          q
          
            m
          
        
        −
        1
        −
        2
        t
        )
        m
        )
      
    
    {\displaystyle ((q^{m}-1)m,(q^{m}-1-2t)m)}
  -код над полем 
  
    
      
        
          G
          F
          (
          q
          )
        
      
    
    {\displaystyle \textstyle GF(q)}
  , который может исправлять любую комбинацию ошибок, сосредоточенную в 
  
    
      
        t
      
    
    {\displaystyle t}
   или меньшем числе блоков из m символов. Наибольшее число блоков длины 
  
    
      
        m
      
    
    {\displaystyle m}
  , которые может затронуть пакет длины 
  
    
      
        
          l
          
            i
          
        
      
    
    {\displaystyle l_{i}}
  , где 
  
    
      
        
          l
          
            i
          
        
        ⩽
        m
        
          t
          
            i
          
        
        −
        (
        m
        −
        1
        )
      
    
    {\displaystyle l_{i}\leqslant mt_{i}-(m-1)}
  , не превосходит 
  
    
      
        
          t
          
            i
          
        
      
    
    {\displaystyle t_{i}}
  , поэтому код, который может исправить 
  
    
      
        t
      
    
    {\displaystyle t}
   блоков ошибок, всегда может исправить и любую комбинацию из 
  
    
      
        p
      
    
    {\displaystyle p}
   пакетов общей длины 
  
    
      
        l
      
    
    {\displaystyle l}
  , если 
  
    
      
        l
        +
        (
        m
        −
        1
        )
        ⩽
        m
        t
      
    
    {\displaystyle l+(m-1)\leqslant mt}
  .

Практическая реализация
Кодирование с помощью кода Рида — Соломона может быть реализовано двумя способами: систематическим и несистематическим (см. [1], описание кодировщика).
При несистематическом кодировании информационное слово умножается на некий неприводимый полином в поле Галуа. Полученное закодированное слово полностью отличается от исходного и для извлечения информационного слова нужно выполнить операцию декодирования и уже потом можно проверить данные на содержание ошибок. Такое кодирование требует большие затраты ресурсов только на извлечение информационных данных, при этом они могут быть без ошибок.

При систематическом кодировании к информационному блоку из 
  
    
      
        k
      
    
    {\displaystyle k}
   символов приписываются 
  
    
      
        2
        t
      
    
    {\displaystyle 2t}
   проверочных символов, при вычислении каждого проверочного символа используются все 
  
    
      
        k
      
    
    {\displaystyle k}
   символов исходного блока. В этом случае нет затрат ресурсов при извлечении исходного блока, если информационное слово не содержит ошибок, но кодировщик/декодировщик должен выполнить 
  
    
      
        k
        (
        n
        −
        k
        )
      
    
    {\displaystyle k(n-k)}
   операций сложения и умножения для генерации проверочных символов. Кроме того, так как все операции проводятся в поле Галуа, то сами операции кодирования/декодирования требуют много ресурсов и времени. Быстрый алгоритм декодирования, основанный на быстром преобразовании Фурье, выполняется за время порядка 
  
    
      
        O
        (
        
          
            l
            n
            (
            
              n
            
            )
          
          
            2
          
        
        )
      
    
    {\displaystyle O({ln({n})}^{2})}
  .

Кодирование
При операции кодирования информационный полином умножается на порождающий многочлен. Умножение исходного слова 
  
    
      
        S
      
    
    {\displaystyle S}
   длины 
  
    
      
        k
      
    
    {\displaystyle k}
   на неприводимый полином при систематическом кодировании можно выполнить следующим образом:

К исходному слову приписываются 
  
    
      
        2
        t
      
    
    {\displaystyle 2t}
   нулей, получается полином 
  
    
      
        
          T
          =
          S
          
            x
            
              2
              t
            
          
        
      
    
    {\displaystyle \textstyle T=Sx^{2t}}
  .
Этот полином делится на порождающий полином 
  
    
      
        G
      
    
    {\displaystyle G}
  , находится остаток 
  
    
      
        R
      
    
    {\displaystyle R}
  , 
  
    
      
        
          S
          
            x
            
              2
              t
            
          
          =
          Q
          G
          +
          R
        
      
    
    {\displaystyle \textstyle Sx^{2t}=QG+R}
  , где 
  
    
      
        Q
      
    
    {\displaystyle Q}
   — частное.
Этот остаток и будет корректирующим кодом Рида — Соломона, он приписывается к исходному блоку символов. Полученное кодовое слово 
  
    
      
        
          C
          =
          S
          
            x
            
              2
              t
            
          
          +
          R
        
      
    
    {\displaystyle \textstyle C=Sx^{2t}+R}
  .Кодировщик строится из сдвиговых регистров, сумматоров и умножителей. Сдвиговый регистр состоит из ячеек памяти, в каждой из которых находится один элемент поля Галуа.
Существует и другая процедура кодирования (более практичная и простая).
Положим 
  
    
      
        
          a
          
            i
          
        
        ∈
        G
        F
        (
        q
        )
        ,
        (
        i
        =
        1
        ,
        2
        ,
        …
        ,
        k
        −
        1
        )
        ,
        α
        ∈
        G
        F
        (
        q
        )
      
    
    {\displaystyle a_{i}\in GF(q),(i=1,2,\ldots ,k-1),\alpha \in GF(q)}
   — примитивный элемент поля 
  
    
      
        G
        F
        (
        q
        )
      
    
    {\displaystyle GF(q)}
  , и пусть 
  
    
      
        a
        =
        (
        
          a
          
            0
          
        
        ,
        
          a
          
            1
          
        
        ,
        …
        ,
        
          a
          
            k
            −
            1
          
        
        )
      
    
    {\displaystyle a=(a_{0},a_{1},\ldots ,a_{k-1})}
   — вектор информационных символов, а значит 
  
    
      
        a
        (
        x
        )
        =
        
          a
          
            0
          
        
        +
        
          a
          
            1
          
        
        x
        +
        …
        +
        
          a
          
            k
            −
            1
          
        
        
          x
          
            k
            −
            1
          
        
      
    
    {\displaystyle a(x)=a_{0}+a_{1}x+\ldots +a_{k-1}x^{k-1}}
   — информационный многочлен. Тогда вектор 
  
    
      
        u
        =
        (
        a
        (
        1
        )
        ,
        a
        (
        α
        )
        ,
        …
        ,
        a
        (
        
          α
          
            q
            −
            2
          
        
        )
        )
      
    
    {\displaystyle u=(a(1),a(\alpha ),\ldots ,a(\alpha ^{q-2}))}
   есть вектор кода Рида — Соломона, соответствующий информационному вектору 
  
    
      
        a
      
    
    {\displaystyle a}
  . Этот способ кодирования показывает, что для кода РС вообще не нужно знать порождающего многочлена и порождающей матрицы кода, достаточно знать разложение поля 
  
    
      
        G
        F
        (
        q
        )
      
    
    {\displaystyle GF(q)}
   по примитивному элементу 
  
    
      
        α
      
    
    {\displaystyle \alpha }
   и размерность кода 
  
    
      
        k
      
    
    {\displaystyle k}
   (длина кода в этом случае определяется как 
  
    
      
        n
        =
        q
        −
        1
      
    
    {\displaystyle n=q-1}
  ). Все дело в том, что за разностью 
  
    
      
        n
        −
        k
      
    
    {\displaystyle n-k}
   полностью скрывается порождающий многочлен 
  
    
      
        g
        (
        x
        )
      
    
    {\displaystyle g(x)}
   и кодовое расстояние.

Декодирование
Декодировщик, работающий по авторегрессивному спектральному методу декодирования, последовательно выполняет следующие действия:

Вычисляет синдром ошибки
Строит полином ошибки
Находит корни данного полинома
Определяет характер ошибки
Исправляет ошибки

Вычисление синдрома ошибки
Вычисление синдрома ошибки выполняется синдромным декодером, который делит кодовое слово на порождающий многочлен. Если при делении возникает остаток, то в слове есть ошибка. Остаток от деления является синдромом ошибки.

Построение полинома ошибки
Вычисленный синдром ошибки не указывает на положение ошибок. Степень полинома синдрома равна 
  
    
      
        2
        t
      
    
    {\displaystyle 2t}
  , что много меньше степени кодового слова 
  
    
      
        n
      
    
    {\displaystyle n}
  . Для получения соответствия между ошибкой и её положением в сообщении строится полином ошибок.
Полином ошибок реализуется с помощью алгоритма Берлекэмпа — Месси, либо с помощью алгоритма Евклида. Алгоритм Евклида имеет простую реализацию, но требует больших затрат ресурсов. Поэтому чаще применяется более сложный, но менее затратоемкий алгоритм Берлекэмпа — Месси. Коэффициенты найденного полинома непосредственно соответствуют коэффициентам ошибочных символов в кодовом слове.

Нахождение корней
На этом этапе ищутся корни полинома ошибки, определяющие положение искаженных символов в кодовом слове. Реализуется с помощью процедуры Ченя, равносильной полному перебору. В полином ошибок последовательно подставляются все возможные значения, когда полином обращается в ноль — корни найдены.

Определение характера ошибки и её исправление
По синдрому ошибки и найденным корням полинома с помощью алгоритма Форни определяется характер ошибки и строится маска искаженных символов.
Однако для кодов РС существует более простой способ отыскания характера ошибок. Как показано в для кодов РС с произвольным множеством 
  
    
      
        2
        
          t
          
            d
          
        
      
    
    {\displaystyle 2t_{d}}
   последовательных нулей 
  
    
      
        
          α
          
            b
          
        
        ,
        
          α
          
            b
            +
            1
          
        
        ,
        …
        ,
        
          α
          
            b
            +
            δ
          
        
        ,
        δ
        =
        2
        
          t
          
            d
          
        
        −
        1
      
    
    {\displaystyle \alpha ^{b},\alpha ^{b+1},\ldots ,\alpha ^{b+\delta },\delta =2t_{d}-1}
  

  
    
      
        
          e
          
            
              j
              
                l
              
            
          
        
        =
        
          
            
              (
              
                α
                
                  
                    j
                    
                      l
                    
                  
                
              
              
                )
                
                  2
                  −
                  b
                
              
              Λ
              (
              
                α
                
                  −
                  
                    j
                    
                      l
                    
                  
                
              
              )
            
            
              
                σ
                ′
              
              (
              
                α
                
                  −
                  
                    j
                    
                      l
                    
                  
                
              
              )
            
          
        
        
        
        
        (
        ∗
        )
      
    
    {\displaystyle e_{j_{l}}={\frac {(\alpha ^{j_{l}})^{2-b}\Lambda (\alpha ^{-j_{l}})}{\sigma '(\alpha ^{-j_{l}})}}\quad \quad \quad (*)}
  

где 
  
    
      
        
          σ
          ′
        
        (
        x
        )
      
    
    {\displaystyle \sigma '(x)}
   формальная производная по 
  
    
      
        x
      
    
    {\displaystyle x}
   многочлена локаторов ошибок 
  
    
      
        σ
        (
        x
        )
      
    
    {\displaystyle \sigma (x)}
   ,а

  
    
      
        Λ
        (
        x
        )
        =
        σ
        (
        x
        )
        S
        (
        x
        )
        
        mod
        
        
        
          x
          
            2
            
              t
              
                d
              
            
            +
            1
          
        
      
    
    {\displaystyle \Lambda (x)=\sigma (x)S(x)\mod x^{2t_{d}+1}}
  
Далее после того как маска найдена, она накладывается на кодовое слово с помощью операции XOR и искаженные символы восстанавливаются. После этого отбрасываются проверочные символы и получается восстановленное информационное слово.

Алгоритм Судана
В данное время стали применяться принципиально новые методы декодирования, например, алгоритм, предложенный в 1997 году Мадху Суданом.

Удлинение кодов РС
Удлинение кодов РС — это процедура, при которой увеличивается длина и расстояние кода (при этом код ещё находится на границе Синглтона и алфавит кода не изменяется), а количество информационных символов кода не изменяется. Такая процедура увеличивает корректирующую способность кода. Рассмотрим удлинение кода РС на один символ. Пусть 
  
    
      
        υ
        =
        (
        
          c
          
            0
          
        
        ,
        
          c
          
            1
          
        
        ,
        …
        ,
        
          c
          
            q
            −
            2
          
        
        )
      
    
    {\displaystyle \upsilon =(c_{0},c_{1},\ldots ,c_{q-2})}
   — вектор кода РС, порождающий многочлен которого есть 
  
    
      
        g
        (
        x
        )
        =
        (
        x
        −
        α
        )
        (
        x
        −
        
          α
          
            2
          
        
        )
        …
        (
        x
        −
        
          α
          
            d
            −
            1
          
        
        )
        ,
        deg
        ⁡
        g
        (
        x
        )
        =
        d
        −
        1
        =
        r
        =
        n
        −
        k
        ,
        n
        =
        q
        −
        1
      
    
    {\displaystyle g(x)=(x-\alpha )(x-\alpha ^{2})\ldots (x-\alpha ^{d-1}),\deg g(x)=d-1=r=n-k,n=q-1}
  . Пусть теперь 
  
    
      
        
          c
          
            q
            −
            1
          
        
        =
        −
        
          ∑
          
            i
            =
            1
          
          
            q
            −
            2
          
        
        
          c
          
            i
          
        
      
    
    {\displaystyle c_{q-1}=-\sum _{i=1}^{q-2}c_{i}}
  . Покажем, что добавление к вектору 
  
    
      
        υ
      
    
    {\displaystyle \upsilon }
   символа 
  
    
      
        
          c
          
            q
            −
            1
          
        
      
    
    {\displaystyle c_{q-1}}
   увеличит его вес до 
  
    
      
        d
        +
        1
      
    
    {\displaystyle d+1}
  ,если 
  
    
      
        
          c
          
            q
            −
            1
          
        
        ≠
        0
      
    
    {\displaystyle c_{q-1}\neq 0}
  . Многочлен, соответствующий вектору кода, можно расписать как 
  
    
      
        υ
        (
        x
        )
        =
        g
        (
        x
        )
        ∗
        z
        (
        x
        )
      
    
    {\displaystyle \upsilon (x)=g(x)*z(x)}
  , но тогда с учётом выражения для 
  
    
      
        
          c
          
            q
            −
            1
          
        
      
    
    {\displaystyle c_{q-1}}
   получим 
  
    
      
        υ
        (
        1
        )
        =
        g
        (
        1
        )
        z
        (
        1
        )
        =
        −
        
          c
          
            q
            −
            1
          
        
      
    
    {\displaystyle \upsilon (1)=g(1)z(1)=-c_{q-1}}
  . 
  
    
      
        g
        (
        1
        )
        ≠
        0
      
    
    {\displaystyle g(1)\neq 0}
  , так как 1 не принадлежит списку корней порождающего многочлена. Но и 
  
    
      
        z
        (
        1
        )
        ≠
        0
      
    
    {\displaystyle z(1)\neq 0}
  , так как в этом случае 
  
    
      
        (
        x
        −
        1
        )
        g
        (
        x
        )
        
          |
        
        υ
        (
        x
        )
      
    
    {\displaystyle (x-1)g(x)|\upsilon (x)}
   ,что увеличило бы расстояние кода вопреки условию, это значит что 
  
    
      
        
          c
          
            q
            −
            1
          
        
        ≠
        0
      
    
    {\displaystyle c_{q-1}\neq 0}
   и вес кода увеличился, за счёт добавления нового символа 
  
    
      
        
          c
          
            q
            −
            1
          
        
      
    
    {\displaystyle c_{q-1}}
  . Новые параметры кода 
  
    
      
        
          n
          
            1
          
        
        =
        n
        +
        1
        ,
        
          k
          
            1
          
        
        =
        k
        ,
        
          d
          
            1
          
        
        =
        d
        +
        1
      
    
    {\displaystyle n_{1}=n+1,k_{1}=k,d_{1}=d+1}
  , удлиненный вектор 
  
    
      
        
          v
          
            1
          
        
        =
        (
        
          c
          
            0
          
        
        ,
        
          c
          
            1
          
        
        ,
        …
        ,
        
          c
          
            q
            −
            2
          
        
        ,
        
          c
          
            q
            −
            1
          
        
        )
      
    
    {\displaystyle v_{1}=(c_{0},c_{1},\ldots ,c_{q-2},c_{q-1})}
  . Проверочная матрица не удлиненного кода имеет вид

      
  
    
      
        H
        =
        
          
            ‖
            
              
                
                  1
                
                
                  α
                
                
                  
                    α
                    
                      2
                    
                  
                
                
                  ⋯
                
                
                  
                    α
                    
                      q
                      −
                      2
                    
                  
                
              
              
                
                  1
                
                
                  
                    α
                    
                      2
                    
                  
                
                
                  
                    α
                    
                      4
                    
                  
                
                
                  ⋯
                
                
                  
                    α
                    
                      2
                      (
                      q
                      −
                      2
                      )
                    
                  
                
              
              
                
                  ⋯
                
                
                  ⋯
                
                
                  ⋯
                
                
                  ⋯
                
                
                  ⋯
                
              
              
                
                  1
                
                
                  
                    α
                    
                      d
                      −
                      1
                    
                  
                
                
                  
                    α
                    
                      2
                      (
                      d
                      −
                      1
                      )
                    
                  
                
                
                  ⋯
                
                
                  
                    α
                    
                      (
                      d
                      −
                      1
                      )
                      (
                      q
                      −
                      2
                      )
                    
                  
                
              
            
            ‖
          
        
      
    
    {\displaystyle H={\begin{Vmatrix}1&\alpha &\alpha ^{2}&\cdots &\alpha ^{q-2}\\1&\alpha ^{2}&\alpha ^{4}&\cdots &\alpha ^{2(q-2)}\\\cdots &\cdots &\cdots &\cdots &\cdots \\1&\alpha ^{d-1}&\alpha ^{2(d-1)}&\cdots &\alpha ^{(d-1)(q-2)}\end{Vmatrix}}}
  

Тогда проверочная матрица, удлиненного на один символ РС кода будет

      
  
    
      
        
          H
          
            1
          
        
        =
        
          
            ‖
            
              
                
                  1
                
                
                  1
                
                
                  1
                
                
                  ⋯
                
                
                  1
                
                
                  1
                
              
              
                
                  1
                
                
                  α
                
                
                  
                    α
                    
                      2
                    
                  
                
                
                  ⋯
                
                
                  
                    α
                    
                      q
                      −
                      2
                    
                  
                
                
                  0
                
              
              
                
                  1
                
                
                  
                    α
                    
                      2
                    
                  
                
                
                  
                    α
                    
                      4
                    
                  
                
                
                  ⋯
                
                
                  
                    α
                    
                      2
                      (
                      q
                      −
                      2
                      )
                    
                  
                
                
                  0
                
              
              
                
                  ⋯
                
                
                  ⋯
                
                
                  ⋯
                
                
                  ⋯
                
                
                  ⋯
                
                
                  ⋯
                
              
              
                
                  1
                
                
                  
                    α
                    
                      d
                      −
                      1
                    
                  
                
                
                  
                    α
                    
                      2
                      (
                      d
                      −
                      1
                      )
                    
                  
                
                
                  ⋯
                
                
                  
                    α
                    
                      (
                      d
                      −
                      1
                      )
                      (
                      q
                      −
                      2
                      )
                    
                  
                
                
                  0
                
              
            
            ‖
          
        
      
    
    {\displaystyle H_{1}={\begin{Vmatrix}1&1&1&\cdots &1&1\\1&\alpha &\alpha ^{2}&\cdots &\alpha ^{q-2}&0\\1&\alpha ^{2}&\alpha ^{4}&\cdots &\alpha ^{2(q-2)}&0\\\cdots &\cdots &\cdots &\cdots &\cdots &\cdots \\1&\alpha ^{d-1}&\alpha ^{2(d-1)}&\cdots &\alpha ^{(d-1)(q-2)}&0\end{Vmatrix}}}

Применение
Сразу после появления (60-е годы 20-го века) коды Рида — Соломона стали применяться в качестве внешних кодов в каскадных конструкциях, использующихся в спутниковой связи. В подобных конструкциях 
  
    
      
        q
      
    
    {\displaystyle q}
  -е символы РС (их может быть несколько) кодируются внутренними сверточными кодами. На приемном конце эти символы декодируются мягким алгоритмом Витерби (эффективный в каналах с АБГШ) . Такой декодер будет исправлять одиночные ошибки в q-ичных символах, когда же возникнут пакетные ошибки и некоторые пакеты q-ичных символов будут декодированы неправильно, тогда внешний декодер Рида — Соломона исправит пакеты этих ошибок. Таким образом будет достигнута требуемая надежность передачи информации ().
В настоящий момент коды Рида — Соломона имеют очень широкую область применения благодаря их способности находить и исправлять многократные пакеты ошибок.

Запись и хранение информации
Код Рида — Соломона используется при записи и чтении в контроллерах оперативной памяти, при архивировании данных, записи информации на жесткие диски (ECC), записи на CD/DVD диски. Даже если поврежден значительный объем информации, испорчено несколько секторов дискового носителя, то коды Рида — Соломона позволяют восстановить большую часть потерянной информации. Также используется при записи на такие носители, как магнитные ленты и штрихкоды.

Запись на CD-ROM
Возможные ошибки при чтении с диска появляются уже на этапе производства диска, так как сделать идеальный диск при современных технологиях невозможно. Также ошибки могут быть вызваны царапинами на поверхности диска, пылью и т. д. Поэтому при изготовлении читаемого компакт-диска используется система коррекции CIRC (Cross Interleaved Reed Solomon Code). Эта коррекция реализована во всех устройствах, позволяющих считывать данные с CD дисков, в виде чипа с прошивкой firmware. Нахождение и коррекция ошибок основана на избыточности и перемежении (redundancy & interleaving). Избыточность примерно 25 % от исходной информации.
При записи на аудиокомпакт-диски используется стандарт Red Book. Коррекция ошибок происходит на двух уровнях, C1 и C2. При кодировании на первом этапе происходит добавление проверочных символов к исходным данным, на втором этапе информация снова кодируется. Кроме кодирования осуществляется также перемешивание (перемежение) байтов, чтобы при коррекции блоки ошибок распались на отдельные биты, которые легче исправляются. На первом уровне обнаруживаются и исправляются ошибочные блоки длиной один и два байта (один и два ошибочных символа, соответственно). Ошибочные блоки длиной три байта обнаруживаются и передаются на следующий уровень. На втором уровне обнаруживаются и исправляются ошибочные блоки, возникшие в C2, длиной 1 и 2 байта. Обнаружение трех ошибочных символов является фатальной ошибкой и не может быть исправлено.

Беспроводная и мобильная связь
Этот алгоритм кодирования используется при передаче данных по сетям WiMAX, в оптических линиях связи, в спутниковой и радиорелейной связи. Метод прямой коррекции ошибок в проходящем трафике (Forward Error Correction, FEC) основывается на кодах Рида — Соломона.

Примеры кодирования
16-ричный (15,11) код Рида — Соломона
Пусть 
  
    
      
        t
        =
        2
        ,
        
          l
          
            0
          
        
        =
        1
      
    
    {\displaystyle t=2,l_{0}=1}
  . Тогда

  
    
      
        g
        (
        x
        )
        =
        (
        x
        −
        α
        )
        (
        x
        −
        
          α
          
            2
          
        
        )
        (
        x
        −
        
          α
          
            3
          
        
        )
        (
        x
        −
        
          α
          
            4
          
        
        )
        =
        
          x
          
            4
          
        
        +
        
          α
          
            13
          
        
        
          x
          
            3
          
        
        +
        
          α
          
            6
          
        
        
          x
          
            2
          
        
        +
        
          α
          
            3
          
        
        x
        +
        
          α
          
            10
          
        
      
    
    {\displaystyle g(x)=(x-\alpha )(x-\alpha ^{2})(x-\alpha ^{3})(x-\alpha ^{4})=x^{4}+\alpha ^{13}x^{3}+\alpha ^{6}x^{2}+\alpha ^{3}x+\alpha ^{10}}
  

.
Степень 
  
    
      
        g
        (
        x
        )
      
    
    {\displaystyle g(x)}
   равна 4, 
  
    
      
        n
        −
        k
        =
        4
      
    
    {\displaystyle n-k=4}
   и 
  
    
      
        k
        =
        11
      
    
    {\displaystyle k=11}
  . Каждому элементу поля 
  
    
      
        
          G
          F
        
        (
        16
        )
      
    
    {\displaystyle \mathrm {GF} (16)}
   можно сопоставить 4 бита. Информационный многочлен является последовательностью 11 символов из 
  
    
      
        
          G
          F
        
        (
        16
        )
      
    
    {\displaystyle \mathrm {GF} (16)}
  , что эквивалентно 44 битам, а все кодовое слово является набором из 60 бит.

8-ричный (7,3) код Рида — Соломона
Пусть 
  
    
      
        t
        =
        2
        ,
        
          l
          
            0
          
        
        =
        4
      
    
    {\displaystyle t=2,l_{0}=4}
  . Тогда

  
    
      
        g
        (
        x
        )
        =
        (
        x
        −
        
          α
          
            4
          
        
        )
        (
        x
        −
        
          α
          
            5
          
        
        )
        (
        x
        −
        
          α
          
            6
          
        
        )
        (
        x
        −
        
          α
          
            0
          
        
        )
        =
        
          x
          
            4
          
        
        +
        
          α
          
            6
          
        
        
          x
          
            3
          
        
        +
        
          α
          
            6
          
        
        
          x
          
            2
          
        
        +
        
          α
          
            3
          
        
        x
        +
        α
      
    
    {\displaystyle g(x)=(x-\alpha ^{4})(x-\alpha ^{5})(x-\alpha ^{6})(x-\alpha ^{0})=x^{4}+\alpha ^{6}x^{3}+\alpha ^{6}x^{2}+\alpha ^{3}x+\alpha }
  

.
Пусть информационный многочлен имеет вид

  
    
      
        m
        (
        x
        )
        =
        
          α
          
            4
          
        
        
          x
          
            2
          
        
        +
        x
        +
        
          α
          
            3
          
        
      
    
    {\displaystyle m(x)=\alpha ^{4}x^{2}+x+\alpha ^{3}}
  

.
Кодовое слово несистематического кода запишется в виде

  
    
      
        c
        (
        x
        )
        =
        m
        (
        x
        )
        g
        (
        x
        )
        =
        (
        
          α
          
            4
          
        
        
          x
          
            2
          
        
        +
        x
        +
        
          α
          
            3
          
        
        )
        (
        
          x
          
            4
          
        
        +
        
          α
          
            6
          
        
        
          x
          
            3
          
        
        +
        
          α
          
            6
          
        
        
          x
          
            2
          
        
        +
        
          α
          
            3
          
        
        x
        +
        α
        )
        =
        
          α
          
            4
          
        
        
          x
          
            6
          
        
        +
        α
        
          x
          
            5
          
        
        +
        
          α
          
            6
          
        
        
          x
          
            4
          
        
        +
        0
        
          x
          
            3
          
        
        +
        0
        
          x
          
            2
          
        
        +
        
          α
          
            5
          
        
        x
        +
        
          α
          
            4
          
        
      
    
    {\displaystyle c(x)=m(x)g(x)=(\alpha ^{4}x^{2}+x+\alpha ^{3})(x^{4}+\alpha ^{6}x^{3}+\alpha ^{6}x^{2}+\alpha ^{3}x+\alpha )=\alpha ^{4}x^{6}+\alpha x^{5}+\alpha ^{6}x^{4}+0x^{3}+0x^{2}+\alpha ^{5}x+\alpha ^{4}}
  

что представляет собой последовательность семи восьмеричных символов.

Альтернативный метод кодирования 9-ричного (8,4) кода Рида — Соломона
Построим поле Галуа 
  
    
      
        G
        F
        (
        
          3
          
            2
          
        
        )
      
    
    {\displaystyle GF(3^{2})}
   по модулю многочлена 
  
    
      
        
          x
          
            2
          
        
        +
        x
        +
        2
      
    
    {\displaystyle x^{2}+x+2}
  .Пусть 
  
    
      
        α
      
    
    {\displaystyle \alpha }
   его корень, тогда 
  
    
      
        
          α
          
            2
          
        
        +
        α
        +
        2
        =
        0
      
    
    {\displaystyle \alpha ^{2}+\alpha +2=0}
  , таблица поля имеет вид:

      
  
    
      
        0
        =
        0
        =
        (
        00
        )
      
    
    {\displaystyle 0=0=(00)}
  
      
  
    
      
        
          α
          
            0
          
        
        =
        1
        =
        (
        10
        )
      
    
    {\displaystyle \alpha ^{0}=1=(10)}
  
      
  
    
      
        
          α
          
            1
          
        
        =
        α
        =
        (
        01
        )
      
    
    {\displaystyle \alpha ^{1}=\alpha =(01)}
  
      
  
    
      
        
          α
          
            2
          
        
        =
        1
        +
        2
        α
        =
        (
        12
        )
      
    
    {\displaystyle \alpha ^{2}=1+2\alpha =(12)}
   
      
  
    
      
        
          α
          
            3
          
        
        =
        2
        +
        2
        α
        =
        (
        22
        )
      
    
    {\displaystyle \alpha ^{3}=2+2\alpha =(22)}
  
      
  
    
      
        
          α
          
            4
          
        
        =
        2
        =
        (
        20
        )
      
    
    {\displaystyle \alpha ^{4}=2=(20)}
  
      
  
    
      
        
          α
          
            5
          
        
        =
        2
        α
        =
        (
        02
        )
      
    
    {\displaystyle \alpha ^{5}=2\alpha =(02)}
  
      
  
    
      
        
          α
          
            6
          
        
        =
        2
        +
        α
        =
        (
        21
        )
      
    
    {\displaystyle \alpha ^{6}=2+\alpha =(21)}
  
      
  
    
      
        
          α
          
            7
          
        
        =
        1
        +
        α
        =
        (
        11
        )
      
    
    {\displaystyle \alpha ^{7}=1+\alpha =(11)}
  

Пусть информационный многочлен 
  
    
      
        a
        (
        x
        )
        =
        1
        +
        α
        x
        +
        
          α
          
            2
          
        
        
          x
          
            2
          
        
        +
        
          α
          
            3
          
        
        
          x
          
            3
          
        
      
    
    {\displaystyle a(x)=1+\alpha x+\alpha ^{2}x^{2}+\alpha ^{3}x^{3}}
  , далее производя соответствующие вычисления над построенным полем получим

  
    
      
        a
        (
        1
        )
        =
        
          α
          
            2
          
        
        ,
        a
        (
        α
        )
        =
        0
        ,
        a
        (
        
          α
          
            2
          
        
        )
        =
        
          α
          
            6
          
        
        ,
        a
        (
        
          α
          
            3
          
        
        )
        =
        0
        ,
        a
        (
        
          α
          
            4
          
        
        )
        =
        
          α
          
            5
          
        
        ,
        a
        (
        
          α
          
            5
          
        
        )
        =
        0
        ,
        a
        (
        
          α
          
            6
          
        
        )
        =
        
          α
          
            7
          
        
        ,
        a
        (
        
          α
          
            7
          
        
        )
        =
        1
      
    
    {\displaystyle a(1)=\alpha ^{2},a(\alpha )=0,a(\alpha ^{2})=\alpha ^{6},a(\alpha ^{3})=0,a(\alpha ^{4})=\alpha ^{5},a(\alpha ^{5})=0,a(\alpha ^{6})=\alpha ^{7},a(\alpha ^{7})=1}
  
В итоге построен вектор кода РС с параметрами 
  
    
      
        n
        =
        8
        ,
        k
        =
        4
        ,
        d
        =
        5
      
    
    {\displaystyle n=8,k=4,d=5}
  .На этом кодирование законченно. Заметим, что при этом способе нам не потребовался порождающий многочлен кода.

Примеры декодирования
Пусть поле 
  
    
      
        G
        F
        (
        
          2
          
            3
          
        
        )
      
    
    {\displaystyle GF(2^{3})}
   генерируется примитивным элементом, неприводимый многочлен которого 
  
    
      
        p
        (
        x
        )
        =
        
          x
          
            3
          
        
        +
        x
        +
        1
      
    
    {\displaystyle p(x)=x^{3}+x+1}
  . Тогда

  
    
      
        p
        (
        α
        )
        =
        
          α
          
            3
          
        
        +
        α
        +
        1
        =
        0
      
    
    {\displaystyle p(\alpha )=\alpha ^{3}+\alpha +1=0}
  . Пусть 
  
    
      
        b
        =
        0
        ,
        
          t
          
            d
          
        
        =
        2
      
    
    {\displaystyle b=0,t_{d}=2}
  . Тогда порождающий многочлен кода РС равен

  
    
      
        g
        (
        x
        )
        =
        (
        x
        +
        1
        )
        (
        x
        +
        α
        )
        (
        x
        +
        
          α
          
            2
          
        
        )
        (
        x
        +
        
          α
          
            3
          
        
        )
        =
        
          x
          
            4
          
        
        +
        
          α
          
            2
          
        
        
          x
          
            3
          
        
        +
        
          α
          
            5
          
        
        
          x
          
            2
          
        
        +
        
          α
          
            5
          
        
        
          x
          
            2
          
        
        +
        
          α
          
            6
          
        
      
    
    {\displaystyle g(x)=(x+1)(x+\alpha )(x+\alpha ^{2})(x+\alpha ^{3})=x^{4}+\alpha ^{2}x^{3}+\alpha ^{5}x^{2}+\alpha ^{5}x^{2}+\alpha ^{6}}
  . Пусть теперь принят многочлен 
  
    
      
        r
        (
        x
        )
        =
        α
        
          x
          
            2
          
        
        +
        
          α
          
            5
          
        
        
          x
          
            4
          
        
      
    
    {\displaystyle r(x)=\alpha x^{2}+\alpha ^{5}x^{4}}
  . Тогда 
  
    
      
        
          S
          
            1
          
        
        =
        r
        (
        1
        )
        =
        α
        +
        
          α
          
            5
          
        
        =
        
          α
          
            6
          
        
        ,
        
          S
          
            2
          
        
        =
        r
        (
        α
        )
        =
        
          α
          
            5
          
        
        ,
        
          S
          
            3
          
        
        =
        α
        ,
        
          S
          
            4
          
        
        =
        α
      
    
    {\displaystyle S_{1}=r(1)=\alpha +\alpha ^{5}=\alpha ^{6},S_{2}=r(\alpha )=\alpha ^{5},S_{3}=\alpha ,S_{4}=\alpha }
  . Тогда ключевая система уравнений получается в виде

  
    
      
        
          
            (
            
              
                
                  
                    α
                    
                      6
                    
                  
                
                
                  
                    α
                    
                      5
                    
                  
                
              
              
                
                  
                    α
                    
                      5
                    
                  
                
                
                  α
                
              
            
            )
          
        
        
          
            (
            
              
                
                  
                    σ
                    
                      2
                    
                  
                
              
              
                
                  
                    σ
                    
                      1
                    
                  
                
              
            
            )
          
        
        =
        
          
            (
            
              
                
                  α
                
              
              
                
                  α
                
              
            
            )
          
        
      
    
    {\displaystyle {\begin{pmatrix}\alpha ^{6}&\alpha ^{5}\\\alpha ^{5}&\alpha \end{pmatrix}}{\begin{pmatrix}\sigma _{2}\\\sigma _{1}\end{pmatrix}}={\begin{pmatrix}\alpha \\\alpha \end{pmatrix}}}
  

Теперь рассмотрим Евклидов алгоритм решения этой системы уравнений.

Начальные условия:
                   
  
    
      
        
          r
          
            0
          
        
        (
        x
        )
        =
        
          x
          
            5
          
        
        ,
        r
        1
        (
        x
        )
        =
        S
        (
        x
        )
        =
        1
        +
        
          α
          
            6
          
        
        x
        +
        
          α
          
            5
          
        
        
          x
          
            2
          
        
        +
        α
        
          x
          
            3
          
        
        +
        α
        
          x
          
            4
          
        
      
    
    {\displaystyle r_{0}(x)=x^{5},r1(x)=S(x)=1+\alpha ^{6}x+\alpha ^{5}x^{2}+\alpha x^{3}+\alpha x^{4}}
  
                   
  
    
      
        
          b
          
            0
          
        
        (
        x
        )
        =
        0
        ,
        
          b
          
            1
          
        
        (
        x
        )
        =
        1
      
    
    {\displaystyle b_{0}(x)=0,b_{1}(x)=1}
  

  
    
      
        i
        =
        2
      
    
    {\displaystyle i=2}
  

  
    
      
        
          x
          
            5
          
        
        =
        (
        1
        +
        
          α
          
            6
          
        
        x
        +
        
          α
          
            5
          
        
        
          x
          
            2
          
        
        +
        α
        
          x
          
            3
          
        
        +
        α
        
          x
          
            4
          
        
        )
        (
        
          α
          
            6
          
        
        x
        +
        
          α
          
            6
          
        
        )
        +
        
          α
          
            5
          
        
        x
        +
        
          x
          
            2
          
        
        +
        α
        x
        +
        
          α
          
            6
          
        
      
    
    {\displaystyle x^{5}=(1+\alpha ^{6}x+\alpha ^{5}x^{2}+\alpha x^{3}+\alpha x^{4})(\alpha ^{6}x+\alpha ^{6})+\alpha ^{5}x+x^{2}+\alpha x+\alpha ^{6}}
  
 
  
    
      
        
          r
          
            2
          
        
        (
        x
        )
        =
        
          α
          
            5
          
        
        
          x
          
            3
          
        
        +
        
          x
          
            2
          
        
        +
        α
        x
        +
        
          α
          
            6
          
        
      
    
    {\displaystyle r_{2}(x)=\alpha ^{5}x^{3}+x^{2}+\alpha x+\alpha ^{6}}
  
 
  
    
      
        
          q
          
            2
          
        
        (
        x
        )
        =
        
          α
          
            6
          
        
        x
        +
        
          α
          
            6
          
        
      
    
    {\displaystyle q_{2}(x)=\alpha ^{6}x+\alpha ^{6}}
  
 
  
    
      
        
          b
          
            2
          
        
        (
        x
        )
        =
        0
        +
        (
        
          α
          
            6
          
        
        x
        +
        
          α
          
            6
          
        
        )
        (
        1
        )
        =
        
          α
          
            6
          
        
        x
        +
        
          α
          
            6
          
        
      
    
    {\displaystyle b_{2}(x)=0+(\alpha ^{6}x+\alpha ^{6})(1)=\alpha ^{6}x+\alpha ^{6}}
  

  
    
      
        i
        =
        3
      
    
    {\displaystyle i=3}
  

  
    
      
        1
        +
        
          α
          
            6
          
        
        x
        +
        
          α
          
            5
          
        
        
          x
          
            2
          
        
        +
        α
        
          x
          
            3
          
        
        +
        α
        
          x
          
            4
          
        
        =
        (
        
          α
          
            5
          
        
        
          x
          
            3
          
        
        +
        
          x
          
            2
          
        
        +
        α
        x
        +
        
          α
          
            6
          
        
        )
        (
        
          α
          
            3
          
        
        x
        +
        
          α
          
            2
          
        
        )
        +
        
          α
          
            6
          
        
        
          x
          
            2
          
        
        +
        α
        x
        +
        
          α
          
            3
          
        
      
    
    {\displaystyle 1+\alpha ^{6}x+\alpha ^{5}x^{2}+\alpha x^{3}+\alpha x^{4}=(\alpha ^{5}x^{3}+x^{2}+\alpha x+\alpha ^{6})(\alpha ^{3}x+\alpha ^{2})+\alpha ^{6}x^{2}+\alpha x+\alpha ^{3}}
  

  
    
      
        
        
         
        
          r
          
            3
          
        
        (
        x
        )
        =
        
          α
          
            6
          
        
        
          x
          
            2
          
        
        +
        α
        x
        +
        
          α
          
            3
          
        
      
    
    {\displaystyle \quad \quad ~r_{3}(x)=\alpha ^{6}x^{2}+\alpha x+\alpha ^{3}}
  

  
    
      
        
        
         
        
          q
          
            3
          
        
        (
        x
        )
        =
        
          α
          
            3
          
        
        x
        +
        
          α
          
            2
          
        
      
    
    {\displaystyle \quad \quad ~q_{3}(x)=\alpha ^{3}x+\alpha ^{2}}
  

  
    
      
        
        
         
        
          b
          
            3
          
        
        (
        x
        )
        =
        1
        +
        (
        
          α
          
            3
          
        
        x
        +
        
          α
          
            2
          
        
        )
        (
        
          α
          
            6
          
        
        x
        +
        
          α
          
            6
          
        
        )
        =
        
          α
          
            3
          
        
        +
        
          α
          
            4
          
        
        x
        +
        
          α
          
            2
          
        
        
          x
          
            2
          
        
      
    
    {\displaystyle \quad \quad ~b_{3}(x)=1+(\alpha ^{3}x+\alpha ^{2})(\alpha ^{6}x+\alpha ^{6})=\alpha ^{3}+\alpha ^{4}x+\alpha ^{2}x^{2}}
  

Алгоритм останавливается, так как 
  
    
      
        deg
        ⁡
        [
        
          r
          
            3
          
        
        (
        x
        )
        ]
        =
        2
        =
        
          t
          
            d
          
        
      
    
    {\displaystyle \deg[r_{3}(x)]=2=t_{d}}
   отсюда следует, что 
  
    
      
        σ
        (
        x
        )
        =
        
          α
          
            3
          
        
        +
        
          α
          
            4
          
        
        x
        +
        
          α
          
            2
          
        
        
          x
          
            2
          
        
      
    
    {\displaystyle \sigma (x)=\alpha ^{3}+\alpha ^{4}x+\alpha ^{2}x^{2}}
  
Далее полный перебор по алгоритму Чени выдает нам позиции ошибок, это 
  
    
      
        
          j
          
            1
          
        
        =
        2
        ,
        
        
          j
          
            2
          
        
        =
        4
      
    
    {\displaystyle j_{1}=2,\quad j_{2}=4}
  .Потом по формуле 
  
    
      
        (
        ∗
        )
      
    
    {\displaystyle (*)}
   получаем что 
  
    
      
        
          e
          
            2
          
        
        =
        α
        ,
        
          e
          
            4
          
        
        =
        α
      
    
    {\displaystyle e_{2}=\alpha ,e_{4}=\alpha }
  
Таким образом декодированный вектор 
  
    
      
        c
        (
        x
        )
        =
        r
        (
        x
        )
        +
        e
        (
        x
        )
        =
        0
      
    
    {\displaystyle c(x)=r(x)+e(x)=0}
  . Декодирование завершено, исправлены две ошибки.

Применение
Код Рида — Соломона используется в некоторых прикладных программах в области хранения данных, например в RAID 6;

Примечания
Литература
Питерсон У., Уэлдон Э. Коды, исправляющие ошибки. — М.: Мир, 1976. — С. 596.
Блейхут Р. Теория и практика кодов, контролирующих ошибки = Theory and Practice of Error Control Codes. — М.: Мир, 1986. — 576 с.
Берлекэмп Э. Алгебраическая теория кодирования = Algebraic Coding Theory. — М.: Мир, 1971. — С. 478.
Егоров С.И. Коррекция ошибок в информационных каналах периферийных устройств ЭВМ. — Курск: КурскГТУ, 2008. — С. 252.
Сагалович Ю. Л. Введение в алгебраические коды — М.: МФТИ, 2007. — 262 с. — ISBN 978-5-7417-0191-1
Морелос-Сарагоса Р. Искусство помехоустойчивого кодирования. Методы, алгоритмы, применение / пер. с англ. В. Б. Афанасьева. — М.: Техносфера, 2006. — 320 с. — (Мир связи). — 2000 экз. — ISBN 5-94836-035-0.
М. Вернер. Основы кодирования. — Техносфера, 2004. — 288 с. — ISBN 5-94836-019-9.

Ссылки
Могущество кодов Рида — Соломона или информация, воскресшая из пепла (статья Криса Касперски)
Помехоустойчивое кодирование в пакетных сетях (статья В. Варгаузина)
Error Correcting Code (ECC)
CD-R диски, технология изнутри
Формат CD
Коды Рида-Соломона
wiki.linuxformat.ru/wiki/LXF134:par2 - использование par2, утилиты восстановления файлов методом Кода Рида-Соломона (рус.)

См. также
Конечное поле
Обнаружение и исправление ошибок
Циклический код
Код Боуза — Чоудхури — Хоквингема
Турбо-код
Код Хэмминга