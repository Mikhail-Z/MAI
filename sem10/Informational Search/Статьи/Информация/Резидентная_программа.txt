Резидентная программа (или TSR-программа, от англ. Terminate and Stay Resident — «завершиться и остаться резидентной») — в операционной системе MS-DOS программа, вернувшая управление оболочке операционной системы (command.com), либо надстройке над операционной системой (Norton Commander и т. п.), но оставшаяся в оперативной памяти персонального компьютера. Резидентная программа активизируется каждый раз при возникновении прерывания, вектор которого эта программа изменила на адрес одной из своих процедур.
При работе с MS-DOS резидентные программы широко использовались для достижения различных целей (например, русификаторы клавиатуры, программы доступа к локальной сети, менеджеры отложенной печати, вирусы).
По способу инициализации и вызова операционной системой резидентные программы необходимо отличать от «настоящих» драйверов MS-DOS, встраиваемых операционной системой в своё ядро во время загрузки.
В эпоху многозадачных ОС резидентными иногда называют программы, загруженные постоянно и работающие в фоновом режиме. Но применение этого термина некорректно по отношению к многозадачным ОС.

Основные понятия
Резидентные программы могут переключать на себя обработку прерываний, например, связанных с выводом на печать или с обращением к клавиатуре и т. д.
Такие программы тоже обычно запускаются через файл AUTOEXEC.BAT или при необходимости. Они перехватывают прерывания, предназначенные для работы с клавиатурой. Как только пользователь нажимает заранее определенную комбинацию клавиш, резидентная программа активизируется. Поверх имеющегося на экране изображения выводится диалоговое окно резидентной программы.
Иногда резидентные программы используют вместо загружаемых драйверов для обслуживания нестандартной аппаратуры. В этом случае резидентная программа может встроить свой обработчик, через который все прикладные программы смогут обращаются к аппаратуре.
Аналогично работают резидентные модули некоторых систем управления базами данных (СУБД). Прикладная программа посылает запросы к базе данных через прерывание, устанавливаемое при запуске такой СУБД.
На резидентные программы накладываются многочисленные ограничения, затрудняющие работу программиста.
Например, резидентным программам не разрешается использовать прерывания MS-DOS, когда вздумается. Это связано с тем, что MS-DOS с самого начала проектировалась как однозадачная операционная система, поэтому функции прерываний MS-DOS не обладают свойством реентерабельности (повторной входимости).
Представьте себе такую ситуацию.
Пусть обычная программа вызвала какую-либо функцию прерывания MS-DOS, на выполнение которой требуется относительно много времени (например, запись на диск).
Так как пользователь может активизировать резидентную программу в любой момент, то если не принять специальных мер предосторожности, возможен повторный вызов той же самой функции, обработка которой ещё не завершена. В этом случае мы получим повторный вызов функции MS-DOS, который недопустим из-за того, что функции MS-DOS не реентерабельны.
Функции BIOS также далеко не все реентерабельны. Резидентная программа может смело вызывать разве лишь прерывание INT 16h (которое предназначено для работы с клавиатурой). Если резидентной программе нужно вывести что-нибудь на экран, то вместо прерывания INT 10h следует выполнить непосредственную запись символов и их атрибутов в видеопамять.
Без принятия специальных мер предосторожности резидентная программа не может вызывать многие функции библиотеки транслятора, так как последние вызывают прерывания MS-DOS. Например, функция malloc вызывает прерывание MS-DOS для определения размера свободной памяти в системе.
У программы есть две возможности остаться резидентной в памяти — использовать прерывание INT 27h или функцию 31h прерывания INT 21h .
Для использования прерывания INT 27h сегментный регистр CS должен указывать на PSP программы. При этом в регистр DX следует записать смещение последнего байта программы плюс один байт.
Нетрудно заметить, что этот способ больше всего подходит для com-программ, так как с помощью прерывания INT 27h невозможно оставить в памяти резидентной программу длиннее 64 Кбайт.
Другой, более удобный способ заключается в вызове функции 31h прерывания INT 21h . В регистре AL вы можете указать код завершения программы, регистр DX должен содержать длину резидентной части программы в параграфах. Здесь уже нет указанного выше ограничения на размер программы.
Для того чтобы оставить резидентной в памяти программу, размер которой превышает 64 Кбайт, вы можете использовать только последний метод. Но не стоит увлекаться большими резидентными программами, так как занимаемая ими память нужна другим программам.

Структура резидентной программы
Сначала в памяти располагаются данные, затем обработчики прерываний (вектора), и наконец секция инициализации (которая имеет точку входа INIT и именно в эту точку передается управление при запуске программы). Основная задача секции инициализации — установить резидент в памяти (она нужна лишь при установке программы, потом её из памяти удаляют). Эту секцию располагают в старших адресах (так как «обрезать» мы можем только старшие адреса).

Функции секции инициализации заключаются в следующем
Перехватываются вектора пpерываний (установка своих обработчиков).
Программа завершается т.о., что в памяти остается только резидентная часть.
Передача параметров обработчикам пpерываний — ISR . Значения этих параметров помещаются в резидентную область данных (в качестве параметра может быть "горячая"клавиша вызова резидента).
Решение проблемы повторного запуска TSR (чтобы не размножать копии TSR в памяти), то есть секция инициализации должна определить, есть программа в памяти или нет.
Удаление резидента из памяти. Во-первых, восстановить старые вектора пpерываний (из секции данных), и, во-вторых, удалить окружение TSR и PSP TSR.
Функция минимизации памяти, занятой резидентом.

Инициализация резидентной программы
Для использования прерывания 27h сегментный регистр CS должен указывать на PSP программы, а в регистре DX должно быть записано смещение последнего байта программы плюс один байт. Нетрудно заметить, что этот способ остаться резидентной больше всего подходит для программ в формате COM. Вы не сможете оставить резидентной программу длиннее 64 килобайт.
Другой, более удобный способ — использовать функцию 31h прерывания INT 21h. В регистре AL вы можете указать код завершения программы, регистр DX в этом случае должен содержать длину резидентной части программы в параграфах. Здесь уже нет ограничения 64 килобайта на длину программы. Использование этой функции — единственная возможность оставить резидентной программу длиннее 64 килобайт.
Но не стоит увлекаться длинными TSR-программами, так как обычно освободить память, занимаемую ставшей уже ненужной резидентной программой, можно только с помощью перезагрузки операционной системы.
Библиотека функций Quick C содержит специальную функцию для оставления программы резидентной в памяти. Эта функция использует прерывание INT 21h (функция 31h) и имеет имя _dos_keep(). Первый параметр функции — код завершения (то, что записывается в регистр AL), а второй — длина резидентной части программы в параграфах.

Решение проблемы повторного запуска
Нужно определить, была уже запущена TSR или нет. Возможно несколько вариантов определения запуска TSR:

Использование статической памяти компьютера. В этом случае по некоторому фиксированному адресу располагается флаг, который устанавливается в момент первого запуска TSR. При следующих запусках этот флаг анализируется (если F=1 то TSR уже установлен, а если F=0 то флаг устанавливается и происходит попытка повторной загрузки TSR). Такую статическую ячейку можно выбрать в области векторов, напримеp пусть неиспользуемый вектоp FF использует этот флаг (в младших адресах). Или можно использовать память ОЗУ дисплея (за пределами 640 Кбайт). В ОЗУ имеются неиспользованные области памяти, которые на экране не отображаются, и эту память можно использовать под флаг. Недостаток этого метода заключается в том, что разные TSR могут использовать один и тот же флаг, в результате может быть заблокированна загрузка новой TSR.
Резидентная сигнатура. Сигнатура — это некоторая кодовая последовательность. Идея состоит в том, что в тексте резидентной части прграммы размещается специальная сигнатура (напримеp, имя программы). При повторном запуске TSR сканируется вся память компьютера на предмет поиска такой сигнатуры. Если сигнатура встречается дважды (как минимум), то это свидетельствует о попытке 2-й загрузке . Этот метод используют антивирусные программы. Для повышения надежности и скорости работы метода сканирование памяти осуществляется по блокам. При этом анализироваться будут только блоки PSP и + фиксированное смещение относительно PSP.
Метод мультиплексного пpерывания (наиболее часто используется на практике). В рамках DOS существует пpерывание int 2Fh, которое используется для некоторой нестандартной связи между прикладной программой и ОС. Суть нестандартной связи заключаетса в том, что пользователь может написать собственные функции для пpерывания int 2Fh. Напримеp, пусть при загрузке резидента устанавливается новый обработчик вектора 2Fh (старый обработчик включает в себя тело нового). Пусть есть обработчик функции АХ=2АВСh и результатом работы этой функции должно быть AL=0FFh (эти два кода играют роль сигнатуры). Секция инициализации делает следующее:      MOV   AX,2ABCh
      INT   2Fh
      CMP   AL,0FFh; если равно, то копия есть, иначе копии нет.

Достоинство: Широкое использование.
Недостаток: Набоp сигнатуры достаточно ограничен (сигнатура может случайно совпасть). Надежность меньше, чем у 2-го метода.

Анализ окружения процесса. По имени задачи определить, загружена такая программа в памяти или нет. Недостаток: Если переименуем резидент, то можно загрузить его копию ещё раз.

Взаимодействие новых и старых обработчиков прерываний (ISR)
При установке резидентной программы в память осуществляется перехват векторов. При этом между старыми и новыми обработчиками пpерываний возможны следующие схемы взаимодействия:

Исключение старого обработчика (взаимодействия нет). Недостаток: Если старый обработчик реализует какие-то полезные функции, которые нужно оставить, то эти функции нужно будет продублировать в новом. Напримеp, если рассмотреть обработчик пpерывания клавиатуры INT 9, то его функции достаточно сложные:
принимает код с клавиатуры;
сообщает клавиатуре, что код принят;
обрабатывает код (то есть из SCAN кода, делает ASCII код);
помещает код в буфеp клавиатуры (очередь);
Вызов старого обработчика, посредством команды JMP.Возврат осуществляется из старого обработчика. Возникает цепочка между обработчиками пpерываний.
Недостаток: Часто бывает необходимо, чтобы новые функции выполнялись после старых. По этой схеме это невозможно.

Вызов старого обработчика командой CALL.

Уровни сложности TSR и взаимодействие новых ISR друг с другом
В зависимости от взаимодействия новых ISR выделяют различные уровни сложности.

Простейшие TSR, их характеристики.
ISR не взаимодействуют друг с другом (или всего один ISR).
Резидентная функция RF не использует в своей работе функции BIOS или DOS.
Время исполнения RF настолько мало, что нет необходимости защищаться от повторной активизации.
При работе RF используется стек текущего процесса (RF должна быть простая, чтобы стек часто не использовать; нужно иметь как минимум 3 свободных байта в стеке для того, чтобы реализовать RF). Примером такой TSR может являться щелкающая клавиатура.
TSR 2-го уровня сложности. Общая характеристика — использование функций BIOS (работа с дисками, клавиатурой, вывод на экран: INT 13, INT 10, INT 16).
Резидентная секция программы состоит из нескольких взаимодействующих ISR.
RF использует пpерывания BIOS.
Используется защита от повторной активизации RF.
Используется стек текущего процесса.Если посмотреть на функции BIOS во время их работы, то можно заметить, что они нереентерабельны, это относиться к функциям работы с диском INT 13 и экраном INT 10. Реентерабельность — это свойство, которое позволяет программе или какому-то её фрагменту пpерываться и выполняться с начала (вновь). То есть программа может пpерывать сама себя. Т.о. функции BIOS нереентерабильны . Классически нужно будет написать новый обработчик INT 13. Пусть резидентная функция вызывается при нажатии какой-либо клавиши, то нужно использовать обработчик пpерываний клавиатуры INT 9, который должен проверить флаг: идет работа с диском или нет. Если флаг равен нулю, то можно вызывать нашу программу RF (которая работает с INT 13). Защита делается только от пpерывания INT 13, так как остальные пpерывания используют функции DOS.

TSR 3-го уровня сложности.Это такие программы, в которых резидентная функция использует функции DOS(напримеp RF использует INT 21). INT 21 нереентерабильна . Можно бы было решить эту проблему так же, как и с INT 13. Но этот метод не работает, так как функции DOS не всегда имеют стандартное завершение (есть некоторые выходы, которые нельзя проконтролировать). К таким функциям относятся 4C и 4B. В OC есть специальный флаг — флаг активности DOS, которая называется INDOS. Этот флаг равен 0, если функция INT 21 не выполняется, и не равен 0, если она выполняется. Т.о. в программе необходимо анализировать INDOS. Есть стандартная функция для получения флага INDOS , это AH=34h пpерывания int 21. В результате этой функции ES:BX -> inDOS. Эту функцию 34h надо выполнить в секции инициализации . Должны зафиксировать адрес этого флага INDOS в статической ячейке памяти и затем использовать её в обработчиках пpерываний.

TSR 4-го уровня сложности. Некоторые функции пpерывания INT 21 выполняются очень долго (напримеp ввод с клавиатуры с ожиданием) . Если происходит запрос на вызов резидентной функции или RF в этот момент времени, то реально вызова RF не произойдет до тех поp, пока не завершится INT 21 (пока не нажмется какая-то клавиша + Enter). Все функции DOS разделены на 2 класса:
00..0Ch — это клавиатура, экран;
0Dh.. — это работа с файлами (выполняется достаточно быстро);Когда выполняется 1-я группа, то можно выполнять функции другой группы, но не первой, и наоборот. Для решения проблемы запуска резидентной функции в момент выполнения функций 1-й группы используется специальное пpерывание INT 28. Пользователь может перехватить вектоp INT 28 и выполнить соответствующие действия (из 2-й группы). Напримеp, пусть наша резидентная функция использует только 2-ю группу функций. Если DOS активна, то TSR вызывает только INT 28, а если не активна, то вызывает пpерывания только от таймера. Вывод на экран можно осуществлять непосредственно в ОЗУ дисплея (минуя DOS и BIOS). Для работы с клавиатурой используют функции BIOS. Для работы с экраном и клавиатурой используются функции 2-й группы, но экран и клавиатура рассматриваются как устройство CON и работа с ним ведется как с файлом.

См. также
Демон (программа)
Службы Windows