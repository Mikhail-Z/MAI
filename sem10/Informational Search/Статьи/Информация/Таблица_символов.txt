В информатике таблица символов (от англ. symbol table «таблица идентификаторов») — это структура данных, используемая транслятором (компилятором или интерпретатором), в которой каждый идентификатор переменной или функции из исходного кода ассоциируется с информацией, связанной с его объявлением или появлением в коде: типом данных, областью видимости и в некоторых случаях местом в памяти (смещением).

Реализация
Общеиспользуемой реализацией является хеш-таблица. Компилятор может как использовать единую таблицу для символов, так и разделять символы на несколько иерархических таблиц по разным областям видимости. Бывают также реализации в виде деревьев, линейных и самоорганизовываемых списков.

Применение
Объектный модуль (англ. object file) содержит таблицу символов для внешне видимых (публичных) идентификаторов. При связывании (линковке) разных объектных модулей компоновщик использует таблицы символов для разрешения межмодульных упоминаний.
Таблица символов может существовать лишь на протяжении трансляции, но иногда она вкладывается в вывод этого процесса для дальнейшего использования, например, во время интерактивной отладки, или как источник для форматирования диагностического отчета во время или после исполнения программы.
Во время реверс-инжиниринга многие утилиты с помощью таблицы проверяют, каким адресам принадлежат глобальные переменные и известные функции. Если таблица символов была убрана из объектных модулей до линковки (например, с помощью strip из GNU binutils), утилитам будет сложнее определить адреса важных мест программы и проанализировать её.
При доступе к переменным и динамическом распределении памяти компилятор должен осуществить множество работ, отсюда — расширенной модели стека при динамическом распределении необходима таблица символов.[прояснить]Хорошим примером использования таблицы символов могут послужить модульные ядра ОС семейства Unix: таблица символов может использоваться подгружаемыми модулями ядра (например, драйверами) для доступа к неким символам. Однако это не является обязательным, если модуль не обращается к ядру, не использует внутренние функции, переменные, и т. д. Возможно обойтись без таблицы символов и обращаться к памяти внутри ядра напрямую, но в этом случае будет потеряна переносимость модулей, так как при разных конфигурациях ядра одинаковый код будет размещён в разных местах.

Пример
Снизу приведена таблица символов небольшой программы. Для её создания использовалась утилита nm из комплекта GNU binutils. В таблице размечен один символ данных (отмечен как тип «D») и множество функций (как из стандартной библиотеки, так и принадлежащие самой программе). Первая колонка содержит адрес смещения в памяти, вторая — тип символа, третья — его название.

См. также
Отладочные символы


== Примечания ==