Имитовста́вка (MAC, англ. message authentication code — код аутентификации сообщения) — средство обеспечения имитозащиты в протоколах аутентификации сообщений с доверяющими друг другу участниками — специальный набор символов, который добавляется к сообщению и предназначен для обеспечения его целостности и аутентификации источника данных.
Имитовста́вка обычно применяется для обеспечения целостности и защиты от подделки передаваемой информации.
Для проверки целостности (но не аутентичности) сообщения на отправляющей стороне к сообщению добавляется значение хеш-функции от этого сообщения, на приемной стороне также вырабатывается хеш от полученного сообщения. Выработанный на приёмной стороне и полученный хеш сравниваются, если они равны, то считается, что полученное сообщение дошло без изменений.
Для защиты от подделки (имитации) сообщения применяется имитовставка, выработанная с использованием секретного элемента (ключа), известного только отправителю и получателю.

Обзор
Простым способом преобразовать однонаправленную хеш-функцию в имитовставку (MAC) является шифрование хеш-значения симметричным алгоритмом. Такой MAC может быть преобразован в однонаправленную хеш-функцию с помощью раскрытия ключа.
Другим способом является выработка имитовставки (MAC) с помощью специализированного алгоритма имитозащиты на основе симметричного алгоритма шифрования.
CBC-MAC:
Простейший способ создать зависящую от ключа имитовставку — шифрование сообщения блочным алгоритмом в режимах CBC или CFB. Имитовставкой является последний шифрованный блок, зашифрованный в этих режимах.
Потенциальная проблема, связанная с безопасностью этого метода, состоит в том, что получатель должен знать ключ, и этот ключ позволяет ему генерировать сообщения с тем же значением имитовставки, что и у присланного сообщения, таким образом, имитовставка на основе симметричного шифра не дает знания — отправитель или получатель сформировал эту имитовставку. Отсюда следует, что имитовставка на основе симметричного шифра не может заменять собой электронную подпись.

Имитовставка по ГОСТ 28147-89
ГОСТ 28147-89 предусматривает выработку имитовставки в соответствующем режиме. Длина имитовставки — от 1 до 32 битов. Её выработка происходит по следующей схеме.
Открытый текст 
  
    
      
        
          T
          
            O
          
        
      
    
    {\displaystyle T_{O}}
   разбивается на блоки длиной 64 бита. Последний блок в случае необходимости дополняется нулями.

  
    
      
        
          T
          
            O
          
        
        =
        
          T
          
            O
          
          
            (
            1
            )
          
        
        
        
          T
          
            O
          
          
            (
            2
            )
          
        
        
        …
        
        
          T
          
            O
          
          
            (
            N
            )
          
        
      
    
    {\displaystyle T_{O}=T_{O}^{(1)}\,T_{O}^{(2)}\,\ldots \,T_{O}^{(N)}}
  Первый блок 
  
    
      
        
          T
          
            O
          
          
            (
            1
            )
          
        
      
    
    {\displaystyle T_{O}^{(1)}}
   шифруется в режиме простой замены ГОСТ 28147-89 тем же ключом, что и сообщение, но с применением 16 циклов вместо 32. Результат по битам по модулю 2 складывается со вторым блоком 
  
    
      
        
          T
          
            O
          
          
            (
            2
            )
          
        
      
    
    {\displaystyle T_{O}^{(2)}}
   и также шифруется. Результат складывается с третьим блоком, и так далее.

  
    
      
        I
        =
        
          E
          
            k
          
          ′
        
        (
        
          T
          
            O
          
          
            (
            N
            )
          
        
        ⊕
        
          E
          
            k
          
          ′
        
        (
        
          T
          
            O
          
          
            (
            N
            −
            1
            )
          
        
        ⊕
        
          E
          
            k
          
          ′
        
        (
        
        …
        
        
          E
          
            k
          
          ′
        
        (
        
          T
          
            O
          
          
            (
            2
            )
          
        
        ⊕
        
          E
          
            k
          
          ′
        
        (
        
          T
          
            O
          
          
            (
            1
            )
          
        
        )
        )
        
        …
        
        )
        )
      
    
    {\displaystyle I=E'_{k}(T_{O}^{(N)}\oplus E'_{k}(T_{O}^{(N-1)}\oplus E'_{k}(\,\ldots \,E'_{k}(T_{O}^{(2)}\oplus E'_{k}(T_{O}^{(1)}))\,\ldots \,))}
  Первые 32 бита получившегося блока составляют имитовставку. Спецификация шифра предусматривает использование в качестве имитовставки и меньшее количество битов по желанию, но не большее.
Имитовставка обычно передаётся в конце сообщения и может вычисляться либо отдельно от шифрования/расшифрования, либо в процессе оного.

MAA
MAA (Message Authenticator Algorithm) — Алгоритм проверки подлинности сообщений.
Этот алгоритм является стандартом ISO. Он выдает 32-битовое хеш-значение и был спроектирован для мэйнфреймов с быстрыми инструкциями умножения.
v=v<<<1
e=v xor w
x=((((e+y) mod 2^32)۷A۸C)*(x xor Mi))mod 2^32-1
y=((((e+x) mod 2^32)۷B۸D)*(y xor Mi))mod 2^32-1
Эти действия повторяются для каждого блока сообщений, Mi, и результирующее хеш-значение получается с помощью XOR x и y. Переменные v и e зависят от ключа. A, B, C и D являются константами.
Возможно, этот алгоритм широко используется, но он недостаточно безопасен. Он разработан давно и не слишком сложен.

Методы Джунемана
Сначала сообщение делится на m-битовые блоки.
Затем:

  
    
      
        
          H
          
            0
          
        
        =
        I
      
    
    {\displaystyle H_{0}=I}
  , где I — секретный ключ

  
    
      
        
          H
          
            i
          
        
        =
        (
        
          H
          
            i
            −
            1
          
        
        +
        
          M
          
            i
          
        
        
          )
          
            2
          
        
        m
        o
        d
        p
      
    
    {\displaystyle H_{i}=(H_{i-1}+M_{i})^{2}modp}
  , где p простое число меньше 
  
    
      
        
          2
          
            m
          
        
        −
        1
      
    
    {\displaystyle 2^{m}-1}
  .

Джунеман предложил значения n=16 и 
  
    
      
        p
        =
        
          2
          
            31
          
        
        −
        1
      
    
    {\displaystyle p=2^{31}-1}
  . Также он предложил, чтобы 
  
    
      
        
          H
          
            1
          
        
      
    
    {\displaystyle H_{1}}
   использовался в качестве дополнительного ключа, а действительное сообщение начиналось бы с 
  
    
      
        
          H
          
            2
          
        
      
    
    {\displaystyle H_{2}}
  .
Из-за множества вскрытий типа «дня рождения», было предложено вычислять QCMDC 4 раза, используя результат одной итерации в качестве 4 для следующей итерации, а затем результаты объединялись бы в 128-битовое хеш-значение. В дальнейшем эта идея была усилена за счет параллельного выполнения 4-х итераций с поперечными связями между ними. Данная схема была взломана Копперсмитом.

Другие методы
CBC-MAC
В качестве MAC берётся последний блок сообщения зашифрованного блочным алгоритмом в режимах CBC или СFB.
Недостатком является тот факт, что получатель должен знать ключ, что позволит ему генерировать сообщение с тем же MAC.

RIPE-MAC
Был придуман Бартом Пренелом в рамках проекта RIPE. Использует DES в качестве функции блочного шифрования. Существует две модификации данного алгоритма:

RIPE-MAC 1 — использует одно шифрование DES на каждый 64-битный блок сообщения;
RIPE-MAC 3 — использует тройное шифрование DES на каждый 64-битный блок сообщения.Свойства:

Длина сообщения увеличивается, так, чтобы она была кратна 64.
Сообщение разбивается на 64-битные блоки.
К сообщению применяется хеш-функция зависящая от ключа (DES или тройной DES).
Значение хеш-функции полученное на 3-ем шаге ещё раз шифруется DES-алгоритмом, с ключом полученным из ключа, который использовался на 3 шаге.

IBC-MAC
Так же использовалась в рамках проекта RIPE. Вероятность вскрытия IBC-MAC может быть оценена количественно. Ядром функции является  Hi = ((Mi mod p) + v) mod 2n 
Секретный ключ представляет собой пару чисел p и v 
p — n-битное простое число. 
v — случайное число меньше 2n. 
Mi — получается с помощью процедуры дополнения. 
Каждое сообщение должно хешироваться новым ключом. 
Вероятность вскрытия, однонаправленность и устойчивость к столкновениям могут оцениваться количественно, изменяя их можно задавать нужный уровень безопасности.
Минус в том, что выбранный уровень безопасности ограничивает размер хешируемого сообщения.

Двунаправленный MAC
Этот MAC выдает хеш-значение, которое в два раза длиннее блока алгоритма. 
Сначала для сообщения вычисляется CBC-MAC. Затем вычисляется CBC-MAC сообщения с обратным порядком блоков. Двунаправленный MAC просто является объединением этих двух значений. К сожалению, данная схема не безопасна.

Однонаправленная хеш-функция MAC
В качестве MAC может быть использована и однонаправленная хеш-функция.
Например, пусть пользователи А и В используют общий ключ К, и А хочет отправить В MAC сообщение М. А объединяет К и М, и вычисляет однонаправленную хеш-функцию объединения: Н(К,М). Это хеш-значение и является кодом MAC. Так как В знает К, он может воспроизвести результат А, а третий пользователь С, которому ключ неизвестен, не сможет это сделать.
С методами MD-усиления этот способ работает, но есть серьёзные проблемы. Пользователь С всегда может добавить новые блоки к концу сообщения и вычислить правильный MAC. Это вскрытие может быть предотвращено, если к началу сообщения добавить его длину, но это тоже не безопасно. Лучше добавлять ключ к концу сообщения, Н(М,К), но при этом также возникают проблемы. Если Н однонаправленная функция, которая не защищена от коллизий, С может подделывать сообщения. Ещё лучше Н(К,М,К) или Н(К1,М,К2), где К1 и К2 различны.
Безопасными кажутся следующие конструкции:
Н(К1, Н(К2,М))
Н(К, Н(К,М))
Н(К, р, М, К)), где р дополняет К до полного блока сообщения.
Лучшим подходом является объединение с каждым блоком сообщения по крайней мере 64 битов ключа. Это делает однонаправленную функцию менее эффективной, так как уменьшаются блоки сообщения, но так она становится намного безопаснее.
Или можно использовать однонаправленную хеш-функцию и симметричный алгоритм. Сначала хешируем файл, потом зашифровываем хеш-значение. Это безопаснее, чем сначала шифровать файл, а затем хешировать зашифрованный файл, но эта схема чувствительна к тому же вскрытию, что и конструкция Н(М,К).

MAC с использованием потокового шифра
Эта схема MAC использует потоковые шифры. Криптографически безопасный генератор псевдослучайных битов демультиплексирует поток сообщения на два подпотока. Если на выходе генератора битов ki единиц, то текущий бит сообщения mi отправляется в первый подпоток, если ноль, то mi отправляется во второй подпоток. Каждый подпоток отправляется на свой LFSR. Выходом MAC просто является конечное состояние обоих регистров.
К несчастью этот метод небезопасен по отношению к небольшим изменениям в сообщении. Например, если изменить последний бит сообщения, то для создания поддельного MAC нужно будет изменить только 2 бита соответствующего MAC; это может быть выполнено с заметной вероятностью.

См. также
Контрольная сумма
HMAC
UMAC
Message authentication algorithm

Примечания
Литература
Словарь криптографических терминов / Под ред. Б. А. Погорелова и В. Н. Сачкова. — М.: МЦНМО, 2006. — С. 94. — ISBN 5-94057-257-X.