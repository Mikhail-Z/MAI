Отбор признаков, известный также как отбор переменных, отбор атрибутов или отбор поднабора переменных, это процесс отбора подмножества значимых признаков (переменных зависимых и независимых) для использования в построении модели. Техники отбора признаков используются по четырём причинам:

упрощение моделей для того, чтобы сделать их проще для интерпретации исследователями/пользователями,
более короткое время тренировки,
чтобы избежать проклятие размерности,
улучшенное обобщение путём сокращения переобучения (формально, уменьшение дисперсии).Центральный посыл использования техники отбора признаков — что данные содержат некоторые признаки, которые либо излишни, либо не значимы, а потому могут быть удалены без существенной потери информации. Излишни и не значимы являются двумя различными понятиями, поскольку один значимый признак может быть излишним при присутствии другого существенного признака, с которым он сильно коррелирует .
Техники отбора признаков следует отличать от выделения признаков. Выделение признаков создаёт новые признаки как функции от оригинальных признаков, в то время как отбор признаков возвращает подмножество признаков. Техники отбора признаков часто используются в областях, где имеется много признаков и выборки сравнительно малы (мало точек данных). Классическими местами применения отбора признаков являются анализ рукописных текстов и ДНК-микрочипы, где имеется много тысяч признаков и от десятков до сотен экземпляров выборки.

Введение
Алгоритм отбора признаков можно рассматривать как комбинацию техник поиска для представления нового поднабора признаков вместе с вычислением меры, которая отражает различие подмножеств признаков. Простейшим алгоритмом является проверка каждого возможного подмножества признаков и нахождения того, который минимизирует величину ошибки. Это исчерпывающий поиск по пространству и он вычислительно труден для наборов признаков, не являющихся очень маленькими. Выбор метрики сильно влияет на алгоритм и они различны для трёх основных категорий алгоритмов отбора признаков: обёртки, фильтры и методы вложения.

Методы обёртывания используют модель априорной оценки результата для оценки поднаборов признаков. Каждый новый поднабор используется для тренировки модели, которая проверяется на контрольной выборке. На этой контрольной выборке считается число ошибок (показатель ошибок модели), которое даёт оценку для данного подмножества. Так как методы обёртывания тренируют модель для каждого поднабора, они вычислительно очень затратны, но дают, как правило, лучший набор признаков для конкретного типа модели.
Методы фильтров использует косвенный показатель вместо показателя ошибки для оценки поднабора признаков. Этот показатель выбирается так, чтобы его можно было легко вычислить при сохранении показателя полезности набора признаков. Обычно применяемые меры — взаимная информация, поточечная взаимная информация, коэффициент корреляции смешанных моментов Пирсона, алгоритм, основанный на Relief и расстояние между классами/внутри класса или результат критериев значимости для каждой комбинации класс/признак. Фильтры обычно вычислительно менее интенсивны, чем обёртки, но они дают наборы признаков, которые не настроены на специфичный тип прогнозирующей модели. Этот недостаток настройки означает, что набор признаков, полученный из фильтра более общий, чем набор, полученный из обёртки, что приводит к меньшей способности предсказания, чем у обёртки. Однако набор признаков не содержит при этом предположений о прогнозирующей модели, а потому более пригоден для обнаружения связей между признаками. Многие фильтры обеспечивают ранжирование признаков, не давая явного лучшего подмножества признаков, а точка отсечения в ранжировании выбирается с помощью перекрёстной проверки. Методы фильтров используются также как предварительные шаги обработки для методов обёртывания, что позволяет применять обёртывание для больших задач. Другим популярным подходом является алгоритм рекурсивного исключения признаков, обычно используемый вместе с методом опорных векторов для многократного построения модели и удаления признаков с малыми весами.
Методы вложения являются обобщающей группой техник, которые осуществляют отбор признаков как часть процесса построения модели. Экземпляром такого подхода является метод LASSO (англ. Least absolute shrinkage and selection operator  = метод оценивания коэффициентов линейной регрессионной модели) для построения линейной модели, который штрафует коэффициент регрессии на штраф L1, сокращая многие из них до нуля. Любые признаки, которые имеют ненулевые коэффициенты регрессии «выбираются» алгоритмом LASSO. Улучшения алгоритма LASSO включают алгоритм Bolasso, который формирует выборку путём бутстрепа, регуляризацию эластичной сети, которая комбинирует штраф L1 алгоритма LASSO со штрафом L2 гребневой регрессии, и метод FeaLect, который оценивает все признаки на основе комбинаторного анализа коэффициентов регрессии. Эти подходы по вычислительной сложности оказываются где-то между фильтрами и обёртками.В традиционной статистике наиболее популярной формой отбора признаков является ступенчатая регрессия, которая является техникой оборачивания.  Это жадный алгоритм, который добавляет лучший признак (или удаляет худший) на каждом шаге алгоритма. Главная проблема — когда остановить алгоритм. При обучении машин это обычно делается путём перекрёстной проверки.  В статистике некоторые критерии оптимизированы.  Это ведёт к наследованию проблемы вложения. Исследовались и более устойчивые методы, такие как метод ветвей и границ и кусочно-линейная сеть.

Выбор поднабора
Выбор поднабора оценивает поднабор признаков как группу стабильности. Алгоритмы выбора поднабора можно разбить на Обёртки, Фильтры и Вложения. Обёртки используют алгоритм поиска для поиска по пространству возможных признаков и оценивают каждый поднабор путём прогона модели на поднаборе. Обёртки может быть вычислительно затратна и имеет риск переподгонки (переобучения) модели. Фильтры похожи на Обёртки по подходу к поиску, но вместо оценки модели оценивается более простой фильтр. Техники вложения встраиваются в модель и специфичны для неё.
Многие популярные подходы используют жадный поиск восхождением к вершине, который итеративно оценивает поднабор признаков как кандидата, затем модифицирует поднабор и оценивает, насколько новый поднабор лучше старого. Оценка поднабора требует использования оценочной метрики, которая ранжирует поднаборы признаков.  Исчерпывающий поиск, как правило, невыполним, так что разработчик (или оператор) определяет точку останова, поднабор признаков с наибольшей достигнутой оценкой, обнаруженный к этому моменту выбирается как удовлетворительный поднабор признаков. Критерий остановки зависит от алгоритма. Возможные критерии: оценка поднабора превышает порог, программа превысила максимальное допустимое время, и так далее.
Альтернативные техники на основе поиска базируются на целевом поиске наилучшей проекции, который находит проекции низкой размерности данных с высокой оценкой — выбираются признаки, которые имеют наибольшие проекции в пространстве низкой размерности.
Подходы для поиска:

Исчерпывающий поиск
Поиск по первому наилучшему совпадению
Имитации отжига
Генетический алгоритм
жадный прямой отбор
Жадное обратное исключение
Метод роя частиц
Целевой поиск наилучшей проекции
Распределенный поиск
Поиск с чередующимися окрестностямиДве популярные метрики фильтров для задач классификации — корреляция и взаимная информация, хотя ни одна из них не является истинной метрикой или «мерой расстояния» в математическом смысле, поскольку для них не выполняется неравенство треугольника, а потому они не представляют действительного «расстояния» – их следует, скорее, понимать как «оценку». Эти оценки вычисляются между признаками-кандидатами (или наборами признаков) и желаемой категорией. Есть, однако, истинные метрики, которые являются простыми функциями от взаимной информации.
Другие возможные метрики фильтров:

Отделимость классов
Вероятность ошибки
Межклассовое расстояние
Вероятностное расстояние
Энтропия
Выбор признаков на основе непротиворечивости
Выбор признаков на основе корреляции

Критерий оптимальности
Выбор критерия оптимальности сложен, так как имеется несколько целей в задаче отбора признаков. Многие критерии включают меру точности со штрафованием числом выбранных признаков (например, байесовский информационный критерий). Наиболее старыми являются статистика Cp Мэллоуса и информационный критерий Акаике (англ. Akaike information criterion, AIC). Они добавляют переменные, если t-статистика превосходит 
  
    
      
        
          
            2
          
        
      
    
    {\displaystyle {\sqrt {2}}}
  .
Другими критериями являются байесовский информационный критерий (БИК, англ. Bayesian information criterion, BIC), который использует 
  
    
      
        
          
            log
            ⁡
            
              n
            
          
        
      
    
    {\displaystyle {\sqrt {\log {n}}}}
  , минимальная длина описания (англ. minimum description length, MDL), который асимптотически использует 
  
    
      
        
          
            log
            ⁡
            
              n
            
          
        
      
    
    {\displaystyle {\sqrt {\log {n}}}}
  , Бонферрони / RIC, который использует 
  
    
      
        
          
            2
            log
            ⁡
            
              p
            
          
        
      
    
    {\displaystyle {\sqrt {2\log {p}}}}
  , отбор признаков с максимальной зависимостью, и набор новых критериев, которые продиктованы идеей уровня ложноположительных результатов (англ. false discovery rate, FDR) и которые используют нечто, близкое к 
  
    
      
        
          
            2
            log
            ⁡
            
              
                p
                q
              
            
          
        
      
    
    {\displaystyle {\sqrt {2\log {\frac {p}{q}}}}}
  . Критерий максимума энтропийной скорости может также быть использован для выбора наиболее значимого поднабора признаков.

Структурное обучение
Фильтр отбора признаков является специальным случаем более общей парадигмы с названием «структурное обучение». Выбор признаков находит значимый набор признаков для конкретной целевой переменной, в то время как структурное обучение находит связи между переменными, обычно выражая эти связи в виде графа. Наиболее распространённые алгоритмы структурного обучения предполагают, что данные генерируются байесовской сетью, так что структура является ориентированной графовой моделью. Оптимальное решение задачи фильтра отбора признаков является марковским ограждением целевого узла и в байесовской сети имеется единственное марковское ограждение для каждого узла.

Механизмы отбора признаков на основе информационной теории
Есть различные механизмы отбора признаков, которые используют взаимную информацию для оценки различных признаков. Они обычно используют один и тот же алгоритм:

Вычисляется взаимная информация как оценка между всеми признаками (
  
    
      
        
          f
          
            i
          
        
        ∈
        F
      
    
    {\displaystyle f_{i}\in F}
  ) и целевым классом ( 
  
    
      
        c
      
    
    {\displaystyle c}
   )
Выбирается признак с наибольшей оценкой (например, 
  
    
      
        a
        r
        g
        m
        a
        
          x
          
            
              f
              
                i
              
            
            ∈
            F
          
        
        (
        I
        (
        
          f
          
            i
          
        
        ,
        c
        )
        )
      
    
    {\displaystyle argmax_{f_{i}\in F}(I(f_{i},c))}
  ) и добавляется в набор отобранных признаков (
  
    
      
        S
      
    
    {\displaystyle S}
  )
Вычисляется оценка, которая может быть получена из взаимной информации
Выбираем признак с наибольшей оценкой и добавляем в набор отобранных признаков (например, 
  
    
      
        a
        r
        g
        m
        a
        
          x
          
            
              f
              
                i
              
            
            ∈
            F
          
        
        (
        
          I
          
            d
            e
            r
            i
            v
            e
            d
          
        
        (
        
          f
          
            i
          
        
        ,
        c
        )
        )
      
    
    {\displaystyle argmax_{f_{i}\in F}(I_{derived}(f_{i},c))}
   )
Повторяем шаги 3. и 4. Пока не наберём определённое число признаков (например, 
  
    
      
        
          |
        
        S
        
          |
        
        =
        l
      
    
    {\displaystyle |S|=l}
   )Наиболее простой подход использует взаимную информацию в качестве «производной» оценки.
Однако, есть различные походы, которые пытаются уменьшить избыточность между признаками.

Выбор признаков на основе минимальной избыточности-максимальной релевантности
Пэн, Лон и Дин предложили метод отбора признаков, который может использовать взаимную информацию, корреляцию или оценку расстояния/похожести для отбора признаков. Целью является наложение штрафа на значимость признака при избыточности, вызванной присутствием в других выбранных признаках. Значимость набора признаков S для класса c определяется средним значением всех значений взаимной информации между индивидуальным признаком fi и классом c:

  
    
      
        D
        (
        S
        ,
        c
        )
        =
        
          
            1
            
              
                |
              
              S
              
                |
              
            
          
        
        
          ∑
          
            
              f
              
                i
              
            
            ∈
            S
          
        
        I
        (
        
          f
          
            i
          
        
        ;
        c
        )
      
    
    {\displaystyle D(S,c)={\frac {1}{|S|}}\sum _{f_{i}\in S}I(f_{i};c)}
  .Избыточность всех признаков в наборе S равна среднему значению всех значений ваимной информации между признакоим fi и признаком fj:

  
    
      
        R
        (
        S
        )
        =
        
          
            1
            
              
                |
              
              S
              
                
                  |
                
                
                  2
                
              
            
          
        
        
          ∑
          
            
              f
              
                i
              
            
            ,
            
              f
              
                j
              
            
            ∈
            S
          
        
        I
        (
        
          f
          
            i
          
        
        ;
        
          f
          
            j
          
        
        )
      
    
    {\displaystyle R(S)={\frac {1}{|S|^{2}}}\sum _{f_{i},f_{j}\in S}I(f_{i};f_{j})}
  Критерий минимальной избыточности-максимальной релевантности (англ. Minimum-redundancy-maximum-relevance, mRMR}} является комбинацией двух мер, заданных выше и определённой как:

  
    
      
        
          m
          R
          M
          R
        
        =
        
          max
          
            S
          
        
        
          [
          
            
              
                1
                
                  
                    |
                  
                  S
                  
                    |
                  
                
              
            
            
              ∑
              
                
                  f
                  
                    i
                  
                
                ∈
                S
              
            
            I
            (
            
              f
              
                i
              
            
            ;
            c
            )
            −
            
              
                1
                
                  
                    |
                  
                  S
                  
                    
                      |
                    
                    
                      2
                    
                  
                
              
            
            
              ∑
              
                
                  f
                  
                    i
                  
                
                ,
                
                  f
                  
                    j
                  
                
                ∈
                S
              
            
            I
            (
            
              f
              
                i
              
            
            ;
            
              f
              
                j
              
            
            )
          
          ]
        
        .
      
    
    {\displaystyle \mathrm {mRMR} =\max _{S}\left[{\frac {1}{|S|}}\sum _{f_{i}\in S}I(f_{i};c)-{\frac {1}{|S|^{2}}}\sum _{f_{i},f_{j}\in S}I(f_{i};f_{j})\right].}
  Предположим, что имеется полный набор из n признаков. Пусть xi будет индикаторной функцией вхождения в множество fi, так что xi=1 отражает присутствие, а xi=0 отражает отсутствие признака fi в глобальном оптимальном наборе признаков. Пусть 
  
    
      
        
          c
          
            i
          
        
        =
        I
        (
        
          f
          
            i
          
        
        ;
        c
        )
      
    
    {\displaystyle c_{i}=I(f_{i};c)}
   и 
  
    
      
        
          a
          
            i
            j
          
        
        =
        I
        (
        
          f
          
            i
          
        
        ;
        
          f
          
            j
          
        
        )
      
    
    {\displaystyle a_{ij}=I(f_{i};f_{j})}
  . Формула выше может теперь быть переписана как задача оптимизации:

  
    
      
        
          m
          R
          M
          R
        
        =
        
          max
          
            x
            ∈
            {
            0
            ,
            1
            
              }
              
                n
              
            
          
        
        
          [
          
            
              
                
                  
                    ∑
                    
                      i
                      =
                      1
                    
                    
                      n
                    
                  
                  
                    c
                    
                      i
                    
                  
                  
                    x
                    
                      i
                    
                  
                
                
                  
                    ∑
                    
                      i
                      =
                      1
                    
                    
                      n
                    
                  
                  
                    x
                    
                      i
                    
                  
                
              
            
            −
            
              
                
                  
                    ∑
                    
                      i
                      ,
                      j
                      =
                      1
                    
                    
                      n
                    
                  
                  
                    a
                    
                      i
                      j
                    
                  
                  
                    x
                    
                      i
                    
                  
                  
                    x
                    
                      j
                    
                  
                
                
                  (
                  
                    ∑
                    
                      i
                      =
                      1
                    
                    
                      n
                    
                  
                  
                    x
                    
                      i
                    
                  
                  
                    )
                    
                      2
                    
                  
                
              
            
          
          ]
        
        .
      
    
    {\displaystyle \mathrm {mRMR} =\max _{x\in \{0,1\}^{n}}\left[{\frac {\sum _{i=1}^{n}c_{i}x_{i}}{\sum _{i=1}^{n}x_{i}}}-{\frac {\sum _{i,j=1}^{n}a_{ij}x_{i}x_{j}}{(\sum _{i=1}^{n}x_{i})^{2}}}\right].}
  Алгоритм mRMR является аппроксимацией теоретически оптимального алгоритма отбора признаков с максимальной зависимостью, который максимизирует взаимную информацию между совместным распределением выбранных признаков и классификационной переменной. Так как mRMR аппроксимирует задачу комбинаторной оценки серией существенно меньших задач, каждая из которых использует только две переменные, он использует попарные совместные вероятности, которые более устойчивы. В некоторых ситуациях алгоритм может недооценить полезность признаков, так как он не имеет возможности измерить взаимосвязь между признаками, которая может увеличить значимость. Это может привести к плохой производительности, если признаки по отдельности бесполезны, но становятся значимыми в комбинации (патологический случай найден, когда класс является функцией чётности признаков). В общем случае алгоритм более эффективен (в терминах количества требуемых данных), чем теоретически оптимальный выбор максимальной зависимости, всё же даёт набор признаков с небольшой попарной избыточностью.
Алгоритм mRMR является представителем большого класса методов фильтров, которые балансируют различным образом между значимостью и избыточностью.

Квадратичное программирование для отбора признаков
Алгоритм mRMR является типичным примером инкрементальной жадной стратегии для отбора признаков — как только признак выбран, он не может быть удалён из выборки на последующих шагах. В то время как mRMR можно оптимизировать с помощью плавающего поиска для сокращения некоторых признаков, его можно переформулировать как глобальную оптимизационную задачу квадратичного програмирования:

  
    
      
        
          Q
          P
          F
          S
        
        :
        
          min
          
            
              x
            
          
        
        
          {
          
            α
            
              
                x
              
              
                T
              
            
            H
            
              x
            
            −
            
              
                x
              
              
                T
              
            
            F
          
          }
        
        
         
        
          ∑
          
            i
            =
            1
          
          
            n
          
        
        
          x
          
            i
          
        
        =
        1
        ,
        
          x
          
            i
          
        
        ≥
        0
      
    
    {\displaystyle \mathrm {QPFS} :\min _{\mathbf {x} }\left\{\alpha \mathbf {x} ^{T}H\mathbf {x} -\mathbf {x} ^{T}F\right\}\quad \ \sum _{i=1}^{n}x_{i}=1,x_{i}\geq 0}
  где 
  
    
      
        
          F
          
            n
            ×
            1
          
        
        =
        [
        I
        (
        
          f
          
            1
          
        
        ;
        c
        )
        ,
        …
        ,
        I
        (
        
          f
          
            n
          
        
        ;
        c
        )
        
          ]
          
            T
          
        
      
    
    {\displaystyle F_{n\times 1}=[I(f_{1};c),\ldots ,I(f_{n};c)]^{T}}
   является вектором значимости признаков в предположении, что имеется всего n признаков, 
  
    
      
        
          H
          
            n
            ×
            n
          
        
        =
        [
        I
        (
        
          f
          
            i
          
        
        ;
        
          f
          
            j
          
        
        )
        
          ]
          
            i
            ,
            j
            =
            1
            …
            n
          
        
      
    
    {\displaystyle H_{n\times n}=[I(f_{i};f_{j})]_{i,j=1\ldots n}}
   является матрицей попарной значимости, а 
  
    
      
        
          
            x
          
          
            n
            ×
            1
          
        
      
    
    {\displaystyle \mathbf {x} _{n\times 1}}
   представляет относительные веса признаков. Задача QPFS решается методами квадратичного программирования. Было показано, что QFPS смещена в направлении признаков с меньшей энтропией вследствие самоизбыточности признака 
  
    
      
        I
        (
        
          f
          
            i
          
        
        ;
        
          f
          
            i
          
        
        )
      
    
    {\displaystyle I(f_{i};f_{i})}
   на диагонали матрицы H.

Условная взаимная информация
Другая оценка, производная от взаимной информации, основана на условной значимости:

  
    
      
        
          S
          P
          E
          
            C
            
              C
              M
              I
            
          
        
        :
        
          max
          
            
              x
            
          
        
        
          {
          
            
              
                x
              
              
                T
              
            
            Q
            
              x
            
          
          }
        
        
         
        ‖
        
          x
        
        ‖
        =
        1
        ,
        
          x
          
            i
          
        
        ≥
        0
      
    
    {\displaystyle \mathrm {SPEC_{CMI}} :\max _{\mathbf {x} }\left\{\mathbf {x} ^{T}Q\mathbf {x} \right\}\quad \ \|\mathbf {x} \|=1,x_{i}\geq 0}
  где 
  
    
      
        
          Q
          
            i
            i
          
        
        =
        I
        (
        
          f
          
            i
          
        
        ;
        c
        )
      
    
    {\displaystyle Q_{ii}=I(f_{i};c)}
   и 
  
    
      
        
          Q
          
            i
            j
          
        
        =
        I
        (
        
          f
          
            i
          
        
        ;
        c
        
          |
        
        
          f
          
            j
          
        
        )
        ,
        i
        ≠
        j
      
    
    {\displaystyle Q_{ij}=I(f_{i};c|f_{j}),i\neq j}
  .
Преимущество SPECCMI заключается в том, что оно может быть решено просто путём нахождения доминирующего собственного вектора Q. SPECCMI обрабатывает также для признаков взаимосвязи второго порядка.

Совместная взаимная информация
При изучении различных оценок Браун, Поукок, Чжао и Лухан  рекомендовали совместную взаимную информацию в качестве хорошей оценки для отбора признаков. Оценка пытается найти признак, который добавляет наибольшую новую информацию к уже отобранным признакам, чтобы избежать избыточность. Оценка формулируется следующим образом:

  
    
      
        
          
            
              
                J
                M
                I
                (
                
                  f
                  
                    i
                  
                
                )
              
              
                
                =
                
                  ∑
                  
                    
                      f
                      
                        j
                      
                    
                    ∈
                    S
                  
                
                (
                I
                (
                
                  f
                  
                    i
                  
                
                ;
                c
                )
                +
                I
                (
                
                  f
                  
                    i
                  
                
                ;
                c
                
                  |
                
                
                  f
                  
                    j
                  
                
                )
                )
              
            
            
              
              
                
                =
                
                  ∑
                  
                    
                      f
                      
                        j
                      
                    
                    ∈
                    S
                  
                
                
                  
                    [
                  
                
                I
                (
                
                  f
                  
                    j
                  
                
                ;
                c
                )
                +
                I
                (
                
                  f
                  
                    i
                  
                
                ;
                c
                )
                −
                
                  
                    (
                  
                
                I
                (
                
                  f
                  
                    i
                  
                
                ;
                
                  f
                  
                    j
                  
                
                )
                −
                I
                (
                
                  f
                  
                    i
                  
                
                ;
                
                  f
                  
                    j
                  
                
                
                  |
                
                c
                )
                
                  
                    )
                  
                
                
                  
                    ]
                  
                
              
            
          
        
      
    
    {\displaystyle {\begin{aligned}JMI(f_{i})&=\sum _{f_{j}\in S}(I(f_{i};c)+I(f_{i};c|f_{j}))\\&=\sum _{f_{j}\in S}{\bigl [}I(f_{j};c)+I(f_{i};c)-{\bigl (}I(f_{i};f_{j})-I(f_{i};f_{j}|c){\bigr )}{\bigr ]}\end{aligned}}}
  
Оценка использует условную взаимную информацию и взаимную информацию для оценки избыточности между уже отобранными признаками (
  
    
      
        
          f
          
            j
          
        
        ∈
        S
      
    
    {\displaystyle f_{j}\in S}
  ) и исследуемым признаком (
  
    
      
        
          f
          
            i
          
        
      
    
    {\displaystyle f_{i}}
  ).

Выбор признаков на основе критерия независимости Lasso Гильберта — Шмидта
Для данных высокой размерности и небольших данных (например, размерность > 
  
    
      
        
          10
          
            5
          
        
      
    
    {\displaystyle 10^{5}}
   и размер выборки < 
  
    
      
        
          10
          
            3
          
        
      
    
    {\displaystyle 10^{3}}
  ), полезным является критерий независимости Lasso Гильберта — Шмидта (HSIC Lasso). Задача оптимизации HSIC Lasso задаётся как

  
    
      
        
          H
          S
          I
          
            C
            
              L
              a
              s
              s
              o
            
          
        
        :
        
          min
          
            
              x
            
          
        
        
          
            1
            2
          
        
        
          ∑
          
            k
            ,
            l
            =
            1
          
          
            n
          
        
        
          x
          
            k
          
        
        
          x
          
            l
          
        
        
          
            HSIC
          
        
        (
        
          f
          
            k
          
        
        ,
        
          f
          
            l
          
        
        )
        −
        
          ∑
          
            k
            =
            1
          
          
            n
          
        
        
          x
          
            k
          
        
        
          
            HSIC
          
        
        (
        
          f
          
            k
          
        
        ,
        c
        )
        +
        λ
        ‖
        
          x
        
        
          ‖
          
            1
          
        
        ,
        
         
        
          x
          
            1
          
        
        ,
        …
        ,
        
          x
          
            n
          
        
        ≥
        0
        ,
      
    
    {\displaystyle \mathrm {HSIC_{Lasso}} :\min _{\mathbf {x} }{\frac {1}{2}}\sum _{k,l=1}^{n}x_{k}x_{l}{\mbox{HSIC}}(f_{k},f_{l})-\sum _{k=1}^{n}x_{k}{\mbox{HSIC}}(f_{k},c)+\lambda \|\mathbf {x} \|_{1},\quad \ x_{1},\ldots ,x_{n}\geq 0,}
  где 
  
    
      
        
          
            HSIC
          
        
        (
        
          f
          
            k
          
        
        ,
        c
        )
        =
        
          
            tr
          
        
        (
        
          
            
              
                
                  K
                
                ¯
              
            
          
          
            (
            k
            )
          
        
        
          
            
              
                L
              
              ¯
            
          
        
        )
      
    
    {\displaystyle {\mbox{HSIC}}(f_{k},c)={\mbox{tr}}({\bar {\mathbf {K} }}^{(k)}{\bar {\mathbf {L} }})}
   является ядерной мерой независимости, называемой (эмпирическим) критерием независимости Гильберта — Шмидта (англ. Hilbert-Schmidt independence criterion, HSIC), 
  
    
      
        
          
            tr
          
        
        (
        ⋅
        )
      
    
    {\displaystyle {\mbox{tr}}(\cdot )}
   обозначает след, 
  
    
      
        λ
      
    
    {\displaystyle \lambda }
   является параметром регуляризации, 
  
    
      
        
          
            
              
                
                  K
                
                ¯
              
            
          
          
            (
            k
            )
          
        
        =
        
          Γ
        
        
          
            K
          
          
            (
            k
            )
          
        
        
          Γ
        
      
    
    {\displaystyle {\bar {\mathbf {K} }}^{(k)}=\mathbf {\Gamma } \mathbf {K} ^{(k)}\mathbf {\Gamma } }
   и 
  
    
      
        
          
            
              
                L
              
              ¯
            
          
        
        =
        
          Γ
        
        
          L
        
        
          Γ
        
      
    
    {\displaystyle {\bar {\mathbf {L} }}=\mathbf {\Gamma } \mathbf {L} \mathbf {\Gamma } }
   являются входными и выходными центрироваными матрицами Грама, 
  
    
      
        
          K
          
            i
            ,
            j
          
          
            (
            k
            )
          
        
        =
        K
        (
        
          u
          
            k
            ,
            i
          
        
        ,
        
          u
          
            k
            ,
            j
          
        
        )
      
    
    {\displaystyle K_{i,j}^{(k)}=K(u_{k,i},u_{k,j})}
   и 
  
    
      
        
          L
          
            i
            ,
            j
          
        
        =
        L
        (
        
          c
          
            i
          
        
        ,
        
          c
          
            j
          
        
        )
      
    
    {\displaystyle L_{i,j}=L(c_{i},c_{j})}
   являются матрицами Грама, 
  
    
      
        K
        (
        u
        ,
        
          u
          ′
        
        )
      
    
    {\displaystyle K(u,u')}
   и 
  
    
      
        L
        (
        c
        ,
        
          c
          ′
        
        )
      
    
    {\displaystyle L(c,c')}
   являются ядерными функциями, 
  
    
      
        
          Γ
        
        =
        
          
            E
          
          
            m
          
        
        −
        
          
            1
            m
          
        
        
          
            1
          
          
            m
          
        
        
          
            1
          
          
            m
          
          
            T
          
        
      
    
    {\displaystyle \mathbf {\Gamma } =\mathbf {E} _{m}-{\frac {1}{m}}\mathbf {1} _{m}\mathbf {1} _{m}^{T}}
   является центрированной матрицей, 
  
    
      
        
          
            E
          
          
            m
          
        
      
    
    {\displaystyle \mathbf {E} _{m}}
   является m-мерной единичной матрицей (m: число элемнтов выборки), 
  
    
      
        
          
            1
          
          
            m
          
        
      
    
    {\displaystyle \mathbf {1} _{m}}
   является m-мерным вектором со всеми единицами, а  
  
    
      
        ‖
        ⋅
        
          ‖
          
            1
          
        
      
    
    {\displaystyle \|\cdot \|_{1}}
   является 
  
    
      
        
          ℓ
          
            1
          
        
      
    
    {\displaystyle \ell _{1}}
  -нормой.  HSIC всегда принимает неотрицательное значение и равно нулю тогда и только тогда, когда две случайные переменные статистически независимы при применении универсального производящего ядра, такого как гауссово ядро.
HSIC Lasso можно записать как

  
    
      
        
          H
          S
          I
          
            C
            
              L
              a
              s
              s
              o
            
          
        
        :
        
          min
          
            
              x
            
          
        
        
          
            1
            2
          
        
        
          
            ‖
            
              
                
                  
                    
                      L
                    
                    ¯
                  
                
              
              −
              
                ∑
                
                  k
                  =
                  1
                
                
                  n
                
              
              
                x
                
                  k
                
              
              
                
                  
                    
                      
                        K
                      
                      ¯
                    
                  
                
                
                  (
                  k
                  )
                
              
            
            ‖
          
          
            F
          
          
            2
          
        
        +
        λ
        ‖
        
          x
        
        
          ‖
          
            1
          
        
        ,
        
         
        
          x
          
            1
          
        
        ,
        …
        ,
        
          x
          
            n
          
        
        ≥
        0
        ,
      
    
    {\displaystyle \mathrm {HSIC_{Lasso}} :\min _{\mathbf {x} }{\frac {1}{2}}\left\|{\bar {\mathbf {L} }}-\sum _{k=1}^{n}x_{k}{\bar {\mathbf {K} }}^{(k)}\right\|_{F}^{2}+\lambda \|\mathbf {x} \|_{1},\quad \ x_{1},\ldots ,x_{n}\geq 0,}
  где 
  
    
      
        ‖
        ⋅
        
          ‖
          
            F
          
        
      
    
    {\displaystyle \|\cdot \|_{F}}
   является нормой Фробениуса. Задача оптимизации является задачей Lasso, а потому она может быть эффективно решена с помощью современных методов решения Lasso, таких как двойственный метод обобщённого Лагранжиана.

Отбор признаков на основе корреляции
Отбор признаков на основе меры корреляции (англ. Correlation Feature Selection, CFS) оценивает подмножества признаков на базе следующей гипотезы: «Хорошие поднаборы признаков содержат признаки, сильно коррелирующие с классификацией, но не коррелирующие друг с другом». Следующе равенство даёт оценку поднабора признаков S, состоящего из k признаков:

  
    
      
        
          
            M
            e
            r
            i
            t
          
          
            
              S
              
                k
              
            
          
        
        =
        
          
            
              k
              
                
                  
                    r
                    
                      c
                      f
                    
                  
                  ¯
                
              
            
            
              k
              +
              k
              (
              k
              −
              1
              )
              
                
                  
                    r
                    
                      f
                      f
                    
                  
                  ¯
                
              
            
          
        
        .
      
    
    {\displaystyle \mathrm {Merit} _{S_{k}}={\frac {k{\overline {r_{cf}}}}{\sqrt {k+k(k-1){\overline {r_{ff}}}}}}.}
  Здесь 
  
    
      
        
          
            
              r
              
                c
                f
              
            
            ¯
          
        
      
    
    {\displaystyle {\overline {r_{cf}}}}
   является средним значением всех корреляций признак-классификация, а 
  
    
      
        
          
            
              r
              
                f
                f
              
            
            ¯
          
        
      
    
    {\displaystyle {\overline {r_{ff}}}}
   является средним всех корреляций признак-признак. Критерий CFS определяется следующим образом:

  
    
      
        
          C
          F
          S
        
        =
        
          max
          
            
              S
              
                k
              
            
          
        
        
          [
          
            
              
                
                  r
                  
                    c
                    
                      f
                      
                        1
                      
                    
                  
                
                +
                
                  r
                  
                    c
                    
                      f
                      
                        2
                      
                    
                  
                
                +
                ⋯
                +
                
                  r
                  
                    c
                    
                      f
                      
                        k
                      
                    
                  
                
              
              
                k
                +
                2
                (
                
                  r
                  
                    
                      f
                      
                        1
                      
                    
                    
                      f
                      
                        2
                      
                    
                  
                
                +
                ⋯
                +
                
                  r
                  
                    
                      f
                      
                        i
                      
                    
                    
                      f
                      
                        j
                      
                    
                  
                
                +
                ⋯
                +
                
                  r
                  
                    
                      f
                      
                        k
                      
                    
                    
                      f
                      
                        1
                      
                    
                  
                
                )
              
            
          
          ]
        
        .
      
    
    {\displaystyle \mathrm {CFS} =\max _{S_{k}}\left[{\frac {r_{cf_{1}}+r_{cf_{2}}+\cdots +r_{cf_{k}}}{\sqrt {k+2(r_{f_{1}f_{2}}+\cdots +r_{f_{i}f_{j}}+\cdots +r_{f_{k}f_{1}})}}}\right].}
  Переменные 
  
    
      
        
          r
          
            c
            
              f
              
                i
              
            
          
        
      
    
    {\displaystyle r_{cf_{i}}}
   и 
  
    
      
        
          r
          
            
              f
              
                i
              
            
            
              f
              
                j
              
            
          
        
      
    
    {\displaystyle r_{f_{i}f_{j}}}
   являются корреляциями, но не обязательно коэффициентами корреляции Пирсона или ρ Спирмена. Диссертация Марка Холла не использует ни одну из них, но использует три различных меры связанности, минимальную длину описания (англ. minimum description length, MDL), симметричную неопределённость и Relief.
Пусть xi будет индикаторной функцией вхождения в множество для признака fi. Тогда формула выше может быть переписана как задача оптимизации:

  
    
      
        
          C
          F
          S
        
        =
        
          max
          
            x
            ∈
            {
            0
            ,
            1
            
              }
              
                n
              
            
          
        
        
          [
          
            
              
                (
                
                  ∑
                  
                    i
                    =
                    1
                  
                  
                    n
                  
                
                
                  a
                  
                    i
                  
                
                
                  x
                  
                    i
                  
                
                
                  )
                  
                    2
                  
                
              
              
                
                  ∑
                  
                    i
                    =
                    1
                  
                  
                    n
                  
                
                
                  x
                  
                    i
                  
                
                +
                
                  ∑
                  
                    i
                    ≠
                    j
                  
                
                2
                
                  b
                  
                    i
                    j
                  
                
                
                  x
                  
                    i
                  
                
                
                  x
                  
                    j
                  
                
              
            
          
          ]
        
        .
      
    
    {\displaystyle \mathrm {CFS} =\max _{x\in \{0,1\}^{n}}\left[{\frac {(\sum _{i=1}^{n}a_{i}x_{i})^{2}}{\sum _{i=1}^{n}x_{i}+\sum _{i\neq j}2b_{ij}x_{i}x_{j}}}\right].}
  Комбинаторные задачи выше являются, фактически, смешанными 0–1 задачами линйного программирования, которые могут быть решены с помощью алгоритма ветвей и границ.

Регуляризованные деревья
Было показано, что признаки из дерева решений или ансамбли деревьев избыточны. Недавний метод с названием «регуляризованное дерево» может быть использован для выбора поднабора признаков. Регуляризованные деревья штрафуются с помощью переменной, подобной переменным, выбранным на предыдущих узлах дерева для расщепления текущего узла. Для регуляризованных деревьев нужно строить только одну модель (иди один ансамбль деревьев), а потому вычислительно алгорим эффективен.
Регуляризованные деревья естественным образом работают с численными и категорийными признаками, взаимодействиями и нелинейностями. Они инвариантны относительно масштаба атрибутов (единиц) и нечувствительны к выбросам, а потому требуют малой предварительной обработки данных, такой как нормализация. Регуляризованный случайный лес (англ. Regularized random forest, RRF) является одним из типов регуляризованных деревьев. Управляемый RRF является улучшенным методом RRF, который управляется оценкой важности из обычного случайного леса.

Обзор методов метаэвристики
Метаалгоритм (или метаэвристика) является общим описанием алгоритма, предназначенного для решения трудных (типично, NP-трудных задач) задач оптимизации для которых не имеется никаких методов решения. Обычно метаалгоритм является стохастическим алгоритмом, стремящимся достичь глобального оптимума. Есть много метаалгоритмов от простого локального поиска до сложного алгоритма глобального поиска.

Основные принципы
Методы отбора признаков обычно представлены тремя классами по тому, как они комбинируют алгоритмы выбора и построения модели.

Метод фильтров
Методы фильтров выбирают переменные независимо от модели. Они базируются только на общих признаках, таких как корреляция переменной с предсказанием. Методы фильтров подавляют наименее интересные переменные. Другие переменные будут частью классификации или модели регрессии, использованной для классификации или предсказания. Эти методы очень эффективны по времени вычисления и устойчивы к переобучению.
Однако, методы фильтров стремятся к выбору избыточных переменных, поскольку они не учитывают связь между переменными. По этой причине эти методы главным образом используются как методы предварительной обработки.

Метод обёртывания
Методы обёртывания оценивают поднаборы переменных и позволяют, в отличие от подходов фильтрации, обнаружить возможную взаимосвязь между переменными. Два главных недостатка этих методов: 

Увеличивается риск переобучения, когда число наблюдений недостаточно.
Существенное время вычисления, когда число переменных велико.

Метод вложения
Методы вложения были предложены как попытка комбинации преимуществ двух предыдущих методов. Обучающий алгоритм имеет преимущество собственного процесса выбора переменной и осуществляет выбор признаков и классификацию одновременно.

Приложение метаэвристики отбора признаков
Ниже обзор приложений метаалгоритмов отбора признаков, использованных в литературе. Обзор был приведён в тезисах Джулии Хэммон.

Выбор признаков, вложенных в алгоритмы обучения
Некоторые обучающие алгоритмы осуществляют отбор признаков как часть алгоритма:

Техники 
  
    
      
        
          l
          
            1
          
        
      
    
    {\displaystyle l_{1}}
  -регуляризации, такие как разреженная регрессия, LASSO, и 
  
    
      
        
          l
          
            1
          
        
      
    
    {\displaystyle l_{1}}
  -SVM
Регуляризованные деревья, например, регуляризованный случайный лес, реализованный в пакете RRF
Дерево решений
Меметический алгоритм
Случайный мультиномиальный логит (англ. Random multinomial logit, RMNL)
Автокодирующая сеть с узким уровнем
Выделение субмодулярных признаков
Выбор признаков на основе локального обучения. По сравнению с традиционными методами данный метод не использует эвристического поиска, может легко справляться с задачами с многими классами, и работает как на линейных, так и нелинейных задачах. Метод также поддержан с теоретической стороны. Численные эксперименты показали, что метод может достичь близкое к оптимальному решение даже в случае, когда данные содержат более 1M незначимых признаков.

См. также
Кластерный анализ
Data mining
Снижение размерности
Выделение признаков
Оптимизация гиперпараметров
Алгоритм Relief

Примечания
Литература
Литература для дальнейшего чтения
Feature Selection for Classification: A Review (Survey, 2014)
Feature Selection for Clustering: A Review (Survey, 2013)
Tutorial Outlining Feature Selection Algorithms, Arizona State University
JMLR Special Issue on Variable and Feature Selection
Feature Selection for Knowledge Discovery and Data Mining (Book)
An Introduction to Variable and Feature Selection (Survey)
Toward integrating feature selection algorithms for classification and clustering (Survey)
Efficient Feature Subset Selection and Subset Size Optimization (Survey, 2010)
Searching for Interacting Features
Feature Subset Selection Bias for Classification Learning

Ссылки
Feature Selection Package, Arizona State University (Matlab Code)
NIPS challenge 2003 (see also NIPS)
Naive Bayes implementation with feature selection in Visual Basic (includes executable and source code)
Minimum-redundancy-maximum-relevance (mRMR) feature selection program
FEAST (Open source Feature Selection algorithms in C and MATLAB)