В области математики и теории информации линейный код — это важный тип блокового кода, использующийся в схемах определения и коррекции ошибок. Линейные коды, по сравнению с другими кодами, позволяют реализовывать более эффективные алгоритмы кодирования и декодирования информации.

Основы
В процессе хранения данных и передачи информации по сетям связи неизбежно возникают ошибки. Контроль целостности данных и исправление ошибок — важные задачи на многих уровнях работы с информацией (в частности, физическом, канальном, транспортном уровнях модели OSI).
В системах связи возможны несколько стратегий борьбы с ошибками:

обнаружение ошибок в блоках данных и автоматический запрос повторной передачи поврежденных блоков — этот подход применяется в основном на канальном и транспортном уровнях;
обнаружение ошибок в блоках данных и отбрасывание поврежденных блоков — такой подход иногда применяется в системах потокового мультимедиа, где важна задержка передачи и нет времени на повторную передачу;
исправление ошибок (англ. forward error correction) применяется на физическом уровне.

Коды обнаружения и исправления ошибок
Корректирующие коды — коды, служащие для обнаружения или исправления ошибок, возникающих при передаче информации под влиянием помех, а также при её хранении.
Для этого при записи (передаче) в полезные данные добавляют специальным образом структурированную избыточную информацию, а при чтении (приеме) её используют для того, чтобы обнаружить или исправить ошибки. Естественно, что число ошибок, которое можно исправить, ограничено и зависит от конкретного применяемого кода.
С кодами, исправляющими ошибки, тесно связаны коды обнаружения ошибок. В отличие от первых, последние могут только установить факт наличия ошибки в переданных данных, но не исправить её.
В действительности, используемые коды обнаружения ошибок принадлежат к тем же классам кодов, что и коды, исправляющие ошибки. Фактически, любой код, исправляющий ошибки, может быть также использован для обнаружения ошибок (при этом он будет способен обнаружить большее число ошибок, чем был способен исправить).
По способу работы с данными коды, исправляющие ошибки делятся на блоковые, делящие информацию на фрагменты постоянной длины и обрабатывающие каждый из них в отдельности, и сверточные, работающие с данными как с непрерывным потоком.

Блоковые коды
Пусть кодируемая информация делится на фрагменты длиной 
  
    
      
        k
      
    
    {\displaystyle k}
   бит, которые преобразуются в кодовые слова длиной 
  
    
      
        n
      
    
    {\displaystyle n}
   бит. Тогда соответствующий блоковый код обычно обозначают 
  
    
      
        (
        n
        ,
        k
        )
      
    
    {\displaystyle (n,k)}
  . При этом число 
  
    
      
        R
        =
        
          
            k
            n
          
        
      
    
    {\displaystyle R={\frac {k}{n}}}
   называется скоростью кода.
Если исходные 
  
    
      
        k
      
    
    {\displaystyle k}
   бит код оставляет неизменными, и добавляет 
  
    
      
        n
        −
        k
      
    
    {\displaystyle n-k}
   проверочных, такой код называется систематическим, иначе несистематическим.
Задать блоковый код можно по-разному, в том числе таблицей, где каждой совокупности из 
  
    
      
        k
      
    
    {\displaystyle k}
   информационных бит сопоставляется 
  
    
      
        n
      
    
    {\displaystyle n}
   бит кодового слова. Однако, хороший код должен удовлетворять, как минимум, следующим критериям:

способность исправлять как можно большее число ошибок,
как можно меньшая избыточность,
простота кодирования и декодирования.Нетрудно видеть, что приведённые требования противоречат друг другу. Именно поэтому существует большое количество кодов, каждый из которых пригоден для своего круга задач.
Практически все используемые коды являются линейными. Это связано с тем, что нелинейные коды значительно сложнее исследовать, и для них трудно обеспечить приемлемую лёгкость кодирования и декодирования.

Линейные пространства
Порождающая матрица
Пусть векторы 
  
    
      
        
          
            
              x
              
                1
              
            
            →
          
        
        =
        (
        
          x
          
            11
          
        
        ,
        .
        .
        ,
        
          x
          
            1
            n
          
        
        )
        ,
        
          
            
              x
              
                2
              
            
            →
          
        
        =
        (
        
          x
          
            21
          
        
        ,
        .
        .
        ,
        
          x
          
            2
            n
          
        
        )
        ,
        .
        .
        ,
        
          
            
              x
              
                k
              
            
            →
          
        
        =
        (
        
          x
          
            k
            1
          
        
        ,
        .
        .
        ,
        
          x
          
            k
            n
          
        
        )
      
    
    {\displaystyle {\overrightarrow {x_{1}}}=(x_{11},..,x_{1n}),{\overrightarrow {x_{2}}}=(x_{21},..,x_{2n}),..,{\overrightarrow {x_{k}}}=(x_{k1},..,x_{kn})}
   являются базисом линейного пространства 
  
    
      
        C
      
    
    {\displaystyle C}
  . По определению базиса, любой вектор 
  
    
      
        
          
            v
            →
          
        
        ∈
        C
      
    
    {\displaystyle {\overrightarrow {v}}\in C}
   можно представить в виде линейной комбинации базисных векторов:

  
    
      
        
          
            v
            →
          
        
        =
        
          
            c
            
              1
            
          
        
        
          
            
              x
              
                1
              
            
            →
          
        
        +
        
          
            c
            
              2
            
          
        
        
          
            
              x
              
                2
              
            
            →
          
        
        +
        .
        .
        .
        +
        
          
            c
            
              k
            
          
        
        
          
            
              x
              
                k
              
            
            →
          
        
      
    
    {\displaystyle {\overrightarrow {v}}={c_{1}}{\overrightarrow {x_{1}}}+{c_{2}}{\overrightarrow {x_{2}}}+...+{c_{k}}{\overrightarrow {x_{k}}}}
  ,
либо в матричной форме, как:

  
    
      
        
          
            v
            →
          
        
        =
        (
        
          
            c
            
              1
            
          
        
        ,
        
          
            c
            
              2
            
          
        
        ,
        .
        .
        ,
        
          
            c
            
              k
            
          
        
        )
        
          
            [
            
              
                
                  
                    x
                    
                      11
                    
                  
                
                
                  
                    x
                    
                      12
                    
                  
                
                
                  .
                  .
                
                
                  
                    x
                    
                      1
                      n
                    
                  
                
              
              
                
                  
                    x
                    
                      21
                    
                  
                
                
                  
                    x
                    
                      22
                    
                  
                
                
                  .
                  .
                
                
                  
                    x
                    
                      2
                      n
                    
                  
                
              
              
                
                  .
                  .
                
                
                  .
                  .
                
                
                  .
                  .
                
                
                  .
                  .
                
              
              
                
                  
                    x
                    
                      k
                      1
                    
                  
                
                
                  
                    x
                    
                      k
                      2
                    
                  
                
                
                  .
                  .
                
                
                  
                    x
                    
                      k
                      n
                    
                  
                
              
            
            ]
          
        
        =
        
          
            c
            →
          
        
        G
      
    
    {\displaystyle {\overrightarrow {v}}=({c_{1}},{c_{2}},..,{c_{k}}){\begin{bmatrix}x_{11}&x_{12}&..&x_{1n}\\x_{21}&x_{22}&..&x_{2n}\\..&..&..&..\\x_{k1}&x_{k2}&..&x_{kn}\\\end{bmatrix}}={\overrightarrow {c}}G}
  ,
где

  
    
      
        G
        =
        
          
            [
            
              
                
                  
                    x
                    
                      11
                    
                  
                
                
                  
                    x
                    
                      12
                    
                  
                
                
                  .
                  .
                
                
                  
                    x
                    
                      1
                      n
                    
                  
                
              
              
                
                  
                    x
                    
                      21
                    
                  
                
                
                  
                    x
                    
                      22
                    
                  
                
                
                  .
                  .
                
                
                  
                    x
                    
                      2
                      n
                    
                  
                
              
              
                
                  .
                  .
                
                
                  .
                  .
                
                
                  .
                  .
                
                
                  .
                  .
                
              
              
                
                  
                    x
                    
                      k
                      1
                    
                  
                
                
                  
                    x
                    
                      k
                      2
                    
                  
                
                
                  .
                  .
                
                
                  
                    x
                    
                      k
                      n
                    
                  
                
              
            
            ]
          
        
      
    
    {\displaystyle G={\begin{bmatrix}x_{11}&x_{12}&..&x_{1n}\\x_{21}&x_{22}&..&x_{2n}\\..&..&..&..\\x_{k1}&x_{k2}&..&x_{kn}\\\end{bmatrix}}}
  
называется порождающей матрицей линейного пространства.
Это соотношение устанавливает связь между векторами коэффициентов 
  
    
      
        
          
            c
            →
          
        
        =
        (
        
          
            c
            
              1
            
          
        
        ,
        
          
            c
            
              2
            
          
        
        ,
        .
        .
        ,
        
          
            c
            
              k
            
          
        
        )
      
    
    {\displaystyle {\overrightarrow {c}}=({c_{1}},{c_{2}},..,{c_{k}})}
  
и векторами 
  
    
      
        
          
            v
            →
          
        
        ∈
        C
      
    
    {\displaystyle {\overrightarrow {v}}\in C}
  . Перечисляя все векторы коэффициентов 
  
    
      
        
          
            c
            →
          
        
        =
        (
        
          
            c
            
              1
            
          
        
        ,
        
          
            c
            
              2
            
          
        
        ,
        .
        .
        ,
        
          
            c
            
              k
            
          
        
        )
      
    
    {\displaystyle {\overrightarrow {c}}=({c_{1}},{c_{2}},..,{c_{k}})}
   можно получить все векторы 
  
    
      
        
          
            v
            →
          
        
        ∈
        C
      
    
    {\displaystyle {\overrightarrow {v}}\in C}
  . Иными словами, матрица 
  
    
      
        G
      
    
    {\displaystyle G}
   порождает линейное пространство.

Проверочная матрица
Другим способом задания линейных пространств является описание через проверочную матрицу.
Пусть 
  
    
      
        
          C
        
      
    
    {\displaystyle \mathbb {C} }
   — линейное k-мерное пространство над конечным полем 
  
    
      
        
          
            F
          
          
            q
          
        
      
    
    {\displaystyle \mathbb {F} _{q}}
   и 
  
    
      
        
          W
        
      
    
    {\displaystyle \mathbb {W} }
   — ортогональное дополнение 
  
    
      
        
          C
        
      
    
    {\displaystyle \mathbb {C} }
  . Тогда по одной из теорем линейной алгебры, размерность 
  
    
      
        
          W
        
      
    
    {\displaystyle \mathbb {W} }
   равна 
  
    
      
        r
        =
        n
        −
        k
      
    
    {\displaystyle r=n-k}
  . Поэтому в 
  
    
      
        
          W
        
      
    
    {\displaystyle \mathbb {W} }
   существует r базисных векторов. Пусть 
  
    
      
        
          
            
              h
              →
            
          
          
            1
          
        
        =
        (
        
          
            
              
                h
                
                  1
                
              
            
            
              1
            
          
        
        ,
        .
        .
        .
        ,
        
          
            
              
                h
                
                  1
                
              
            
            
              n
            
          
        
        )
        ,
        
          
            
              h
              →
            
          
          
            2
          
        
        =
        (
        
          
            
              
                h
                
                  2
                
              
            
            
              1
            
          
        
        ,
        .
        .
        .
        ,
        
          
            
              
                h
                
                  2
                
              
            
            
              n
            
          
        
        )
        ,
        .
        .
        .
        ,
        
          
            
              h
              →
            
          
          
            r
          
        
        =
        (
        
          
            
              
                h
                
                  r
                
              
            
            
              1
            
          
        
        ,
        .
        .
        .
        ,
        
          
            
              
                h
                
                  r
                
              
            
            
              n
            
          
        
        )
      
    
    {\displaystyle {\overrightarrow {h}}_{1}=({{h_{1}}_{1}},...,{{h_{1}}_{n}}),{\overrightarrow {h}}_{2}=({{h_{2}}_{1}},...,{{h_{2}}_{n}}),...,{\overrightarrow {h}}_{r}=({{h_{r}}_{1}},...,{{h_{r}}_{n}})}
   базис в 
  
    
      
        
          W
        
      
    
    {\displaystyle \mathbb {W} }
  .
Тогда любой вектор 
  
    
      
        
          
            v
            →
          
        
        ∈
        C
      
    
    {\displaystyle {\overrightarrow {v}}\in C}
   удовлетворяет следующей системе линейных уравнений:

  
    
      
        
          
            {
            
              
                
                  
                    h
                    
                      11
                    
                  
                  
                    x
                    
                      1
                    
                  
                  +
                  
                    h
                    
                      12
                    
                  
                  
                    x
                    
                      2
                    
                  
                  +
                  .
                  .
                  .
                  +
                  
                    h
                    
                      1
                      n
                    
                  
                  
                    x
                    
                      n
                    
                  
                  =
                  0
                
              
              
                
                  
                    h
                    
                      21
                    
                  
                  
                    x
                    
                      1
                    
                  
                  +
                  
                    h
                    
                      22
                    
                  
                  
                    x
                    
                      2
                    
                  
                  +
                  .
                  .
                  .
                  +
                  
                    h
                    
                      2
                      n
                    
                  
                  
                    x
                    
                      n
                    
                  
                  =
                  0
                
              
              
                
                  .
                  .
                  .
                
              
              
                
                  
                    h
                    
                      r
                      1
                    
                  
                  
                    x
                    
                      1
                    
                  
                  +
                  
                    h
                    
                      r
                      2
                    
                  
                  
                    x
                    
                      2
                    
                  
                  +
                  .
                  .
                  .
                  +
                  
                    h
                    
                      r
                      n
                    
                  
                  
                    x
                    
                      n
                    
                  
                  =
                  0
                
              
            
            
          
        
      
    
    {\displaystyle {\begin{cases}h_{11}x_{1}+h_{12}x_{2}+...+h_{1n}x_{n}=0\\h_{21}x_{1}+h_{22}x_{2}+...+h_{2n}x_{n}=0\\...\\h_{r1}x_{1}+h_{r2}x_{2}+...+h_{rn}x_{n}=0\end{cases}}}
  
Или в матричной форме:

  
    
      
        
          
            v
            →
          
        
        
          H
          
            T
          
        
        =
        0
      
    
    {\displaystyle {\overrightarrow {v}}H^{T}=0}
  ,
где 
  
    
      
        H
        =
        
          
            [
            
              
                
                  
                    
                      
                        h
                        →
                      
                    
                    
                      1
                    
                  
                
              
              
                
                  
                    
                      
                        h
                        →
                      
                    
                    
                      2
                    
                  
                
              
              
                
                  .
                  .
                  .
                
              
              
                
                  
                    
                      
                        h
                        →
                      
                    
                    
                      r
                    
                  
                
              
            
            ]
          
        
        =
        
          
            [
            
              
                
                  
                    h
                    
                      11
                    
                  
                
                
                  
                    h
                    
                      12
                    
                  
                
                
                  .
                  .
                
                
                  
                    h
                    
                      1
                      n
                    
                  
                
              
              
                
                  
                    h
                    
                      21
                    
                  
                
                
                  
                    h
                    
                      22
                    
                  
                
                
                  .
                  .
                
                
                  
                    h
                    
                      2
                      n
                    
                  
                
              
              
                
                  .
                  .
                
                
                  .
                  .
                
                
                  .
                  .
                
                
                  .
                  .
                
              
              
                
                  
                    h
                    
                      r
                      1
                    
                  
                
                
                  
                    h
                    
                      r
                      2
                    
                  
                
                
                  .
                  .
                
                
                  
                    h
                    
                      r
                      n
                    
                  
                
              
            
            ]
          
        
      
    
    {\displaystyle H={\begin{bmatrix}{\overrightarrow {h}}_{1}\\{\overrightarrow {h}}_{2}\\...\\{\overrightarrow {h}}_{r}\\\end{bmatrix}}={\begin{bmatrix}h_{11}&h_{12}&..&h_{1n}\\h_{21}&h_{22}&..&h_{2n}\\..&..&..&..\\h_{r1}&h_{r2}&..&h_{rn}\\\end{bmatrix}}}
  
— проверочная матрица.
Приведённую систему линейных уравнений следует рассматривать как систему проверок для всех векторов линейного пространства, поэтому матрица 
  
    
      
        
          H
        
      
    
    {\displaystyle \mathbb {H} }
   называется проверочной матрицей.

Формальное определение
Линейный код длины n и ранга k является линейным подпространством C размерности k векторного пространства 
  
    
      
        
          
            F
          
          
            q
          
          
            n
          
        
      
    
    {\displaystyle \mathbb {F} _{q}^{n}}
  , где 
  
    
      
        
          
            F
          
          
            q
          
        
      
    
    {\displaystyle \mathbb {F} _{q}}
   — конечное поле из q элементов. Такой код с параметром q называется q-арным кодом (напр. если q = 5 — то это 5-арный код). Если q = 2 или q = 3, то код представляет собой двоичный код, или тернарный соответственно.
Линейный (блоковый) код — такой код, что множество его кодовых слов образует 
  
    
      
        k
      
    
    {\displaystyle k}
  -мерное линейное подпространство (назовем его 
  
    
      
        C
      
    
    {\displaystyle C}
  ) в 
  
    
      
        n
      
    
    {\displaystyle n}
  -мерном линейном пространстве, изоморфное пространству 
  
    
      
        k
      
    
    {\displaystyle k}
  -битных векторов.
Это значит, что операция кодирования соответствует умножению исходного 
  
    
      
        k
      
    
    {\displaystyle k}
  -битного вектора на невырожденную матрицу 
  
    
      
        G
      
    
    {\displaystyle G}
  , называемую порождающей матрицей.
Пусть 
  
    
      
        
          C
          
            ⊥
          
        
      
    
    {\displaystyle C^{\perp }}
   — ортогональное подпространство по отношению к 
  
    
      
        C
      
    
    {\displaystyle C}
  , а 
  
    
      
        H
      
    
    {\displaystyle H}
   — матрица, задающая базис этого подпространства. Тогда для любого вектора 
  
    
      
        
          
            v
            →
          
        
        ∈
        C
      
    
    {\displaystyle {\overrightarrow {v}}\in C}
   справедливо:

  
    
      
        
          
            v
            →
          
        
        
          H
          
            T
          
        
        =
        
          
            0
            →
          
        
      
    
    {\displaystyle {\overrightarrow {v}}H^{T}={\overrightarrow {0}}}
  .

Свойства и важные теоремы
Минимальное расстояние и корректирующая способность
Расстоянием Хемминга (метрикой Хемминга) между двумя кодовыми словами 
  
    
      
        
          
            
              v
              
                1
              
            
            →
          
        
      
    
    {\displaystyle {\overrightarrow {v_{1}}}}
   и 
  
    
      
        
          
            
              v
              
                2
              
            
            →
          
        
      
    
    {\displaystyle {\overrightarrow {v_{2}}}}
   называется количество отличных бит на соответствующих позициях, то есть число «единиц» в векторе 
  
    
      
        
          
            
              v
              
                1
              
            
            →
          
        
        ⊕
        
          
            
              v
              
                2
              
            
            →
          
        
      
    
    {\displaystyle {\overrightarrow {v_{1}}}\oplus {\overrightarrow {v_{2}}}}
  .
Минимальное расстояние  
  
    
      
        d
      
    
    {\displaystyle d}
   линейного кода является минимальным из всех расстояний Хемминга всех пар кодовых слов.
Вес вектора 
  
    
      
        w
      
    
    {\displaystyle w}
   — расстояние Хемминга между этим вектором и нулевым вектором, иными словами — число ненулевых компонент вектора.
Теорема 1:
Минимальное расстояние 
  
    
      
        d
      
    
    {\displaystyle d}
   линейного кода равно минимальному из весов Хемминга ненулевых кодовых слов:

  
    
      
        d
        =
        
          min
          
            
              
                c
                →
              
            
            ∈
            C
            ,
            
              
                c
                →
              
            
            ≠
            
              
                0
                →
              
            
          
        
        (
        w
        (
        
          
            c
            →
          
        
        )
        )
      
    
    {\displaystyle d=\min _{{\overrightarrow {c}}\in C,{\overrightarrow {c}}\not ={\overrightarrow {0}}}(w({\overrightarrow {c}}))}
  
Доказательство:
Расстояние между двумя векторами 
  
    
      
        d
        (
        
          
            x
            →
          
        
        ,
        
          
            y
            →
          
        
        )
      
    
    {\displaystyle d({\overrightarrow {x}},{\overrightarrow {y}})}
   удовлетворяет равенству 
  
    
      
        d
        (
        
          
            x
            →
          
        
        ,
        
          
            y
            →
          
        
        )
        =
        w
        (
        
          
            x
            →
          
        
        −
        
          
            y
            →
          
        
        )
      
    
    {\displaystyle d({\overrightarrow {x}},{\overrightarrow {y}})=w({\overrightarrow {x}}-{\overrightarrow {y}})}
  , где 
  
    
      
        w
        (
        
          
            t
            →
          
        
        )
      
    
    {\displaystyle w({\overrightarrow {t}})}
   — вес Хемминга вектора 
  
    
      
        
          
            t
            →
          
        
      
    
    {\displaystyle {\overrightarrow {t}}}
  . Из того, что разность любых двух кодовых слов линейного кода также является кодовым словом линейного кода, вытекает утверждение теоремы:

  
    
      
        d
        =
        
          min
          
            
              
                c
                →
              
            
            ∈
            C
            ,
            
              
                c
                →
              
            
            ≠
            
              
                0
                →
              
            
          
        
        w
        (
        
          
            c
            →
          
        
        )
      
    
    {\displaystyle d=\min _{{\overrightarrow {c}}\in C,{\overrightarrow {c}}\not ={\overrightarrow {0}}}w({\overrightarrow {c}})}
  
Минимальное расстояние Хемминга 
  
    
      
        d
      
    
    {\displaystyle d}
   является важной характеристикой линейного блокового кода. Она определяет другую, не менее важную характеристику — корректирующую способность:

  
    
      
        t
        =
        
          ⌊
          
            
              
                d
                −
                1
              
              2
            
          
          ⌋
        
      
    
    {\displaystyle t=\left\lfloor {\frac {d-1}{2}}\right\rfloor }
  , здесь угловые скобки обозначают округление «вниз».
Корректирующая способность определяет, какое максимальное число ошибок в одном кодовом слове код может гарантированно исправить.
Поясним на примере. Предположим, что есть два кодовых слова A и B, расстояние Хемминга между ними равно 3. Если было передано слово A, и канал внёс ошибку в одном бите, она может быть исправлена, так как даже в этом случае принятое слово ближе к кодовому слову A, чем B. Но если каналом были внесены ошибки в двух битах, декодер может посчитать, что было передано слово B.
Число обнаруживаемых ошибок — число ошибок, при котором декодер может обнаружить ошибочную ситуацию (и, например, инициировать повторную передачу сообщения). Это число равно

  
    
      
        f
        =
        d
        −
        1
      
    
    {\displaystyle f=d-1}
  .Теорема 2 (без доказательства):
Если любые 
  
    
      
        l
        ⩽
        d
        −
        1
      
    
    {\displaystyle l\leqslant d-1}
   столбцов проверочной матрицы H линейного (n, k)-кода линейно независимы, то минимальное расстояние кода равно по меньшей мере d. Если при этом найдутся d линейно зависимых столбцов, то минимальное расстояние кода равно d в точности.
Теорема 3 (без доказательства):
Если минимальное расстояние линейного (n, k)-кода равно d, то любые 
  
    
      
        l
        ⩽
        d
        −
        1
      
    
    {\displaystyle l\leqslant d-1}
   столбцов проверочной матрицы H линейно независимы и найдутся d линейно зависимых столбцов.

Коды Хемминга
Исторически «коды Хемминга» должны называться кодами Р. Фишера и были представлены в 1942г (Fisher R.A. The theory of confouding in factor to thr theory).
Коды Хемминга — простейшие линейные коды с минимальным расстоянием 3, то есть способные исправить одну ошибку. Код Хемминга может быть представлен в таком виде, что синдром

  
    
      
        
          
            s
            →
          
        
        =
        
          
            r
            →
          
        
        
          H
          
            T
          
        
      
    
    {\displaystyle {\overrightarrow {s}}={\overrightarrow {r}}H^{T}}
  , где 
  
    
      
        
          
            r
            →
          
        
      
    
    {\displaystyle {\overrightarrow {r}}}
   — принятый вектор,будет равен номеру позиции, в которой произошла ошибка. Это свойство позволяет сделать декодирование очень простым.

Код Рида-Маллера
Код Рида-Маллера — линейный двоичный блочный код. При определённом построении он может быть систематическим. В общем случае код Рида-Маллера не является циклическим. Коды Рида-Маллера задаются следующими параметрами для любых значений m и r, называемого порядком кода, меньшего, чем m:
— длина кодового слова n=2m;
— длина информационной части k=1+Cm1+…+Cmr;
— длина проверочной части n-k=1+Cm1+…+Cmm-r-1;
— минимальное кодовое расстояние dmin=2m-r.
Код Рида-Маллера определяется при помощи порождающей матрицы, состоящей из базисных векторов. Строится по правилу:
— пусть V0 — вектор, все компоненты которого равны 1;
— пусть V1, V2,…, Vm — строки матрицы, столбцами которого являются все двоичные наборы длины m. Код Рида-Маллера r-го порядка содержит в качестве базиса векторы V0, V1,…, Vm и все компонентные произведения r или меньшего числа этих векторов.

Общий метод кодирования линейных кодов
Линейный код длины n с k информационными символами является k-мерным линейным подпространством, поэтому каждое кодовое слово является линейной комбинацией базисных векторов 
  
    
      
        
          
            
              g
              
                1
              
            
            →
          
        
        =
        (
        
          g
          
            11
          
        
        ,
        .
        .
        ,
        
          g
          
            1
            n
          
        
        )
        ,
        
          
            
              g
              
                2
              
            
            →
          
        
        =
        (
        
          g
          
            21
          
        
        ,
        .
        .
        ,
        
          g
          
            2
            n
          
        
        )
        ,
        .
        .
        ,
        
          
            
              g
              
                k
              
            
            →
          
        
        =
        (
        
          g
          
            k
            1
          
        
        ,
        .
        .
        ,
        
          g
          
            k
            n
          
        
        )
      
    
    {\displaystyle {\overrightarrow {g_{1}}}=(g_{11},..,g_{1n}),{\overrightarrow {g_{2}}}=(g_{21},..,g_{2n}),..,{\overrightarrow {g_{k}}}=(g_{k1},..,g_{kn})}
   подпространства:

  
    
      
        
          
            c
            →
          
        
        =
        
          
            m
            
              1
            
          
        
        
          
            
              g
              
                1
              
            
            →
          
        
        +
        
          
            m
            
              2
            
          
        
        
          
            
              g
              
                2
              
            
            →
          
        
        +
        .
        .
        .
        +
        
          
            m
            
              k
            
          
        
        
          
            
              g
              
                k
              
            
            →
          
        
      
    
    {\displaystyle {\overrightarrow {c}}={m_{1}}{\overrightarrow {g_{1}}}+{m_{2}}{\overrightarrow {g_{2}}}+...+{m_{k}}{\overrightarrow {g_{k}}}}
  .
Либо с помощью порождающей матрицы:

  
    
      
        
          
            c
            →
          
        
        =
        
          
            m
            →
          
        
        G
        =
        (
        
          
            m
            
              1
            
          
        
        ,
        
          
            m
            
              2
            
          
        
        ,
        .
        .
        ,
        
          
            m
            
              k
            
          
        
        )
        
          
            [
            
              
                
                  
                    g
                    
                      11
                    
                  
                
                
                  
                    g
                    
                      12
                    
                  
                
                
                  .
                  .
                
                
                  
                    g
                    
                      1
                      n
                    
                  
                
              
              
                
                  
                    g
                    
                      21
                    
                  
                
                
                  
                    g
                    
                      22
                    
                  
                
                
                  .
                  .
                
                
                  
                    g
                    
                      2
                      n
                    
                  
                
              
              
                
                  .
                  .
                
                
                  .
                  .
                
                
                  .
                  .
                
                
                  .
                  .
                
              
              
                
                  
                    g
                    
                      k
                      1
                    
                  
                
                
                  
                    g
                    
                      k
                      2
                    
                  
                
                
                  .
                  .
                
                
                  
                    g
                    
                      k
                      n
                    
                  
                
              
            
            ]
          
        
      
    
    {\displaystyle {\overrightarrow {c}}={\overrightarrow {m}}G=({m_{1}},{m_{2}},..,{m_{k}}){\begin{bmatrix}g_{11}&g_{12}&..&g_{1n}\\g_{21}&g_{22}&..&g_{2n}\\..&..&..&..\\g_{k1}&g_{k2}&..&g_{kn}\\\end{bmatrix}}}
  ,
где 
  
    
      
        
          
            m
            →
          
        
        =
        (
        
          
            m
            
              1
            
          
        
        ,
        .
        .
        ,
        
          
            m
            
              k
            
          
        
        )
        ,
        
          
            m
            
              1
            
          
        
        ,
        .
        .
        ,
        
          
            m
            
              k
            
          
        
        ∈
        
          Q
        
      
    
    {\displaystyle {\overrightarrow {m}}=({m_{1}},..,{m_{k}}),{m_{1}},..,{m_{k}}\in \mathbb {Q} }
  
Это соотношение есть правило кодирования, по которому информационное слово 
  
    
      
        
          
            m
            →
          
        
        =
        (
        
          
            m
            
              1
            
          
        
        ,
        .
        .
        ,
        
          
            m
            
              k
            
          
        
        )
      
    
    {\displaystyle {\overrightarrow {m}}=({m_{1}},..,{m_{k}})}
   отображается в кодовое 
  
    
      
        
          
            c
            →
          
        
        =
        (
        
          
            c
            
              1
            
          
        
        ,
        .
        .
        ,
        
          
            c
            
              n
            
          
        
        )
      
    
    {\displaystyle {\overrightarrow {c}}=({c_{1}},..,{c_{n}})}

Общий метод обнаружения ошибок в линейном коде
Любой код (в том числе нелинейный) можно декодировать с помощью обычной таблицы, где каждому значению принятого слова 
  
    
      
        
          
            
              r
              
                i
              
            
            →
          
        
      
    
    {\displaystyle {\overrightarrow {r_{i}}}}
   соответствует наиболее вероятное переданное слово 
  
    
      
        
          
            
              u
              
                i
              
            
            →
          
        
      
    
    {\displaystyle {\overrightarrow {u_{i}}}}
  . Однако, данный метод требует применения огромных таблиц уже для кодовых слов сравнительно небольшой длины.
Для линейных кодов этот метод можно существенно упростить. При этом для каждого принятого вектора 
  
    
      
        
          
            
              r
              
                i
              
            
            →
          
        
      
    
    {\displaystyle {\overrightarrow {r_{i}}}}
   вычисляется синдром 
  
    
      
        
          
            
              s
              
                i
              
            
            →
          
        
        =
        
          
            
              r
              
                i
              
            
            →
          
        
        
          H
          
            T
          
        
      
    
    {\displaystyle {\overrightarrow {s_{i}}}={\overrightarrow {r_{i}}}H^{T}}
  . Поскольку 
  
    
      
        
          
            
              r
              
                i
              
            
            →
          
        
        =
        
          
            
              v
              
                i
              
            
            →
          
        
        +
        
          
            
              e
              
                i
              
            
            →
          
        
      
    
    {\displaystyle {\overrightarrow {r_{i}}}={\overrightarrow {v_{i}}}+{\overrightarrow {e_{i}}}}
  , где 
  
    
      
        
          
            
              v
              
                i
              
            
            →
          
        
      
    
    {\displaystyle {\overrightarrow {v_{i}}}}
   — кодовое слово, а 
  
    
      
        
          
            
              e
              
                i
              
            
            →
          
        
      
    
    {\displaystyle {\overrightarrow {e_{i}}}}
   — вектор ошибки, то 
  
    
      
        
          
            
              s
              
                i
              
            
            →
          
        
        =
        
          
            
              e
              
                i
              
            
            →
          
        
        
          H
          
            T
          
        
      
    
    {\displaystyle {\overrightarrow {s_{i}}}={\overrightarrow {e_{i}}}H^{T}}
  . Затем с помощью таблицы по синдрому определяется вектор ошибки, с помощью которого определяется переданное кодовое слово. При этом таблица получается гораздо меньше, чем при использовании предыдущего метода.

Линейные циклические коды
Несмотря на то, что исправление ошибок в линейных кодах уже значительно проще исправления в большинстве нелинейных, для большинства кодов этот процесс все ещё достаточно сложен. Циклические коды, кроме более простого декодирования, обладают и другими важными свойствами.
Циклическим кодом является линейный код, обладающий следующим свойством: если 
  
    
      
        
          
            v
            →
          
        
      
    
    {\displaystyle {\overrightarrow {v}}}
   является кодовым словом, то его циклическая перестановка также является кодовым словом.
Слова циклического кода удобно представлять в виде многочленов. Например, кодовое слово 
  
    
      
        
          
            v
            →
          
        
        =
        (
        
          v
          
            0
          
        
        ,
        
          v
          
            1
          
        
        ,
        .
        .
        .
        ,
        
          v
          
            n
            −
            1
          
        
        )
      
    
    {\displaystyle {\overrightarrow {v}}=(v_{0},v_{1},...,v_{n-1})}
   представляется в виде полинома 
  
    
      
        v
        (
        x
        )
        =
        
          v
          
            0
          
        
        +
        
          v
          
            1
          
        
        x
        +
        .
        .
        .
        +
        
          v
          
            n
            −
            1
          
        
        
          x
          
            n
            −
            1
          
        
      
    
    {\displaystyle v(x)=v_{0}+v_{1}x+...+v_{n-1}x^{n-1}}
  . При этом циклический сдвиг кодового слова эквивалентен умножению многочлена на 
  
    
      
        x
      
    
    {\displaystyle x}
   по модулю 
  
    
      
        
          x
          
            n
          
        
        −
        1
      
    
    {\displaystyle x^{n}-1}
  .
В дальнейшем, если не указано иное, мы будем считать, что циклический код является двоичным, то есть 
  
    
      
        
          v
          
            0
          
        
        ,
        
          v
          
            1
          
        
      
    
    {\displaystyle v_{0},v_{1}}
  … могут принимать значения 0 или 1.

Порождающий полином
Можно показать, что все кодовые слова конкретного циклического кода кратны определённому порождающему полиному 
  
    
      
        g
        (
        x
        )
      
    
    {\displaystyle g(x)}
  . Порождающий полином является делителем 
  
    
      
        
          x
          
            n
          
        
        −
        1
      
    
    {\displaystyle x^{n}-1}
  .
С помощью порождающего полинома осуществляется кодирование циклическим кодом. В частности:

несистематическое кодирование осуществляется путём умножения кодируемого вектора на 
  
    
      
        g
        (
        x
        )
      
    
    {\displaystyle g(x)}
  : 
  
    
      
        v
        (
        x
        )
        =
        u
        (
        x
        )
        g
        (
        x
        )
      
    
    {\displaystyle v(x)=u(x)g(x)}
  ;систематическое кодирование осуществляется путём «дописывания» к кодируемому слову остатка от деления 
  
    
      
        
          x
          
            n
            −
            k
          
        
        u
        (
        x
        )
      
    
    {\displaystyle x^{n-k}u(x)}
   на 
  
    
      
        g
        (
        x
        )
      
    
    {\displaystyle g(x)}
  , то есть 
  
    
      
        v
        (
        x
        )
        =
        
          x
          
            n
            −
            k
          
        
        u
        (
        x
        )
        +
        [
        
          x
          
            n
            −
            k
          
        
        u
        (
        x
        )
        
        mod
        
        
        g
        (
        x
        )
        ]
      
    
    {\displaystyle v(x)=x^{n-k}u(x)+[x^{n-k}u(x)\mod g(x)]}
  .

Коды CRC
Коды CRC (cyclic redundancy check — циклическая избыточная проверка) являются систематическими кодами, предназначенными не для исправления ошибок, а для их обнаружения. Они используют способ систематического кодирования, изложенный выше: «контрольная сумма» вычисляется путём деления 
  
    
      
        
          x
          
            n
            −
            k
          
        
        u
        (
        x
        )
      
    
    {\displaystyle x^{n-k}u(x)}
   на 
  
    
      
        g
        (
        x
        )
      
    
    {\displaystyle g(x)}
  . Ввиду того, что исправление ошибок не требуется, проверка правильности передачи может производиться точно так же.
Таким образом, вид полинома g(x) задаёт конкретный код CRC. Примеры наиболее популярных полиномов:

Коды БЧХ
Коды Боуза-Чоудхури-Хоквингема (БЧХ) являются подклассом двоичных циклических кодов. Их отличительное свойство — возможность построения кода БЧХ с минимальным расстоянием не меньше заданного. Это важно, потому что, вообще говоря, определение минимального расстояния кода есть очень сложная задача.
Математически построение кодов БЧХ и их декодирование используют разложение порождающего полинома 
  
    
      
        g
        (
        x
        )
      
    
    {\displaystyle g(x)}
   на множители в поле Галуа.

Коды Рида-Соломона
Коды Рида-Соломона (РС-коды) фактически являются недвоичными кодами БЧХ, то есть элементы кодового вектора являются не битами, а группами битов. Очень распространены коды Рида-Соломона, работающие с байтами (октетами).

Преимущества и недостатки линейных кодов
+ Благодаря линейности для запоминания или перечисления всех кодовых слов достаточно хранить в памяти кодера или декодера существенно меньшую их часть, а именно только те слова, которые образуют базис соответствующего линейного пространства. Это существенно упрощает реализацию устройств кодирования и декодирования и делает линейные коды весьма привлекательными с точки зрения практических приложений.
— Хотя линейные коды, как правило, хорошо справляются с редкими, но большими пачками ошибок, их эффективность при частых, но небольших ошибках (например, в канале с АБГШ), менее высока.

Оценка эффективности
Эффективность кодов определяется количеством ошибок, которые тот может исправить, количеством избыточной информации, добавление которой требуется, а также сложностью реализации кодирования и декодирования (как аппаратной, так и в виде программы для ЭВМ).

Граница Хемминга и совершенные коды
Пусть имеется двоичный блоковый 
  
    
      
        (
        n
        ,
        k
        )
      
    
    {\displaystyle (n,k)}
   код с корректирующей способностью 
  
    
      
        t
      
    
    {\displaystyle t}
  . Тогда справедливо неравенство (называемое границей Хемминга):

  
    
      
        
          ∑
          
            i
            =
            0
          
          
            t
          
        
        
          
            
              (
            
            
              n
              i
            
            
              )
            
          
        
        ≤
        
          2
          
            n
            −
            k
          
        
      
    
    {\displaystyle \sum _{i=0}^{t}{n \choose i}\leq 2^{n-k}}
  .Коды, удовлетворяющие этой границе с равенством, называются совершенными. К совершенным кодам относятся, например, коды Хемминга. Часто применяемые на практике коды с большой корректирующей способностью (такие, как коды Рида-Соломона) не являются совершенными.

Энергетический выигрыш
При передаче информации по каналу связи вероятность ошибки зависит от отношения сигнал/шум на входе демодулятора, таким образом при постоянном уровне шума решающее значение имеет мощность передатчика. В системах спутниковой и мобильной, а также других типов связи остро стоит вопрос экономии энергии. Кроме того, в определённых системах связи (например, телефонной) неограниченно повышать мощность сигнала не дают технические ограничения.
Поскольку помехоустойчивое кодирование позволяет исправлять ошибки, при его применении мощность передатчика можно снизить, оставляя скорость передачи информации неизменной. Энергетический выигрыш определяется как разница отношений с/ш при наличии и отсутствии кодирования.

Применение
Линейные коды применяются:

в системах цифровой связи, в том числе: спутниковой, радиорелейной, сотовой, передаче данных по телефонным каналам;
в системах хранения информации, в том числе магнитных и оптических;
в сетевых протоколах различных уровней.

См. также
Циклический код
LDPC
Турбо-код
Полярные коды