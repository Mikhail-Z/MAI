### Криптографический протокол для голосования

Сервер является многопоточным. Главный поток слушает новых клиентов. В случае его появления запускается новый поток, который будет обрабатывать нового клиента, пока его бюллетень не будет учтена, если это избиратель.
Обмен данными происходит следующим образом.
1.	Клиент посылает серверу свой номер в незашифрованном виде.
2.	Сервер, получив новое подключение, запускает отдельный поток для обработки клиента.
3.	Поток, получив первое сообщение (в нем номер клиента), смотрит, есть ли этот номер в списке избирателей. Если нет, то отсылает в незашифрованном виде ответ “Нет”, и заканчивают работу как клиент, так и поток, которы его обработал. Если же есть номер в списке избирателей, то отправляет пока еще в незашифрованном виде название папки, в которой будут находить необходимые в процессе обмена данными файлы, такие как подпись, ключ сессии, открытый и закрытый ключи клиента.
4.	Клиент, получив положительный ответ, создает открытый и закрытый ключи. Далее заполняет бюллетень в формате “45432*3”, где I-ый символ – оценка I-го кандидата и отправляет его в зашифрованном виде.
5.	Сервер, получив сообщение и расшифровав его, проверяет правильность заполнения. Если есть ошибки, то отправляет “нет” клиенту и снова ждет его бюллетени. Если бюллетень правильно заполнена, то она заносится в базу (структура данных вида “словарь”).
6.	Сервер отправляет клиенту в зашифрованном виде ответ “да”, что его голос учтен.
7.	Клиент, получив это сообщение, отправляет серверу сообщение “ok”, после чего сервер может удалять всю папку с файлами, которая использовалась при шифровании.
Само шифрование происходит следующим образом.
1.	Цифровая подпись своего сообщения и шифрование её с помощью открытого ключа сервера с помощью алгоритма RSA и сохранения её в файл.
2.	Генерация случайного сеансового ключа и шифрование этим ключом своего сообщения с помощью симметричного шифрования AES .
3.	Шифрование сеансового ключа алгоритмом RSA с помощью открытого ключа сервера и сохранение его в файл.
Дешифрование выглядит так:
1.	Сервер открывает файл с зашифрованным сеансовым, расшифровывает его с помощью своего закрытого ключа.
2.	Расшифровка сообщения с помощью расшифрованного сеансового ключа
3.	Расшифровка подписи с помощью своего закрытого ключа. Проверка подписи.

## Использование:

1. python `thread-server.py 1 num_of_candidates port_num`
2. python `cr3_client.py id num_of_candidates port_num`